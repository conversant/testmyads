/* prebid.js v9.49.0-pre
Updated: 2025-06-10
Modules: fpdModule, prebidServerBidAdapter, conversantBidAdapter, appnexusBidAdapter, openxBidAdapter, adpod, userId, schain, paapi, topLevelPaapi, priceFloors, publinkIdSystem, sharedIdSystem, identityLinkIdSystem, dfpAdServerVideo, tcfControl, consentManagementTcf, consentManagementGpp, consentManagementUsp, gptPreAuction, topicsFpdModule, paapiForGpt, idImportLibrary, currency, dsaControl, gppControl_usnat, gppControl_usstates, debugging */

if (!window.pbjs || !window.pbjs.libLoaded) {
 (function(){
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/dlv/index.js":
/*!***********************************!*\
  !*** ./node_modules/dlv/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ dlv)
/* harmony export */ });
function dlv(obj, key, def, p, undef) {
	key = key.split ? key.split('.') : key;
	for (p = 0; p < key.length; p++) {
		obj = obj ? obj[key[p]] : undef;
	}
	return obj === undef ? def : obj;
}


/***/ }),

/***/ "./node_modules/fun-hooks/no-eval/index.js":
/*!*************************************************!*\
  !*** ./node_modules/fun-hooks/no-eval/index.js ***!
  \*************************************************/
/***/ ((module) => {

/*
* @license MIT
* Fun Hooks v0.9.10
* (c) @snapwich
*/
create.SYNC = 1;
create.ASYNC = 2;
create.QUEUE = 4;

var packageName = "fun-hooks";

function hasProxy() {
  return !!(typeof Proxy === "function" && Proxy.revocable);
}

var defaults = Object.freeze({
  useProxy: true,
  ready: 0
});

var hookableMap = new WeakMap();

// detect incorrectly implemented reduce and if found use polyfill
// https://github.com/prebid/Prebid.js/issues/3576
// polyfill from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce
var reduce =
  [1]
    .reduce(function(a, b, c) {
      return [a, b, c];
    }, 2)
    .toString() === "2,1,0"
    ? Array.prototype.reduce
    : function(callback, initial) {
        var o = Object(this);
        var len = o.length >>> 0;
        var k = 0;
        var value;
        if (initial) {
          value = initial;
        } else {
          while (k < len && !(k in o)) {
            k++;
          }
          value = o[k++];
        }
        while (k < len) {
          if (k in o) {
            value = callback(value, o[k], k, o);
          }
          k++;
        }
        return value;
      };

function rest(args, skip) {
  return Array.prototype.slice.call(args, skip);
}

var assign =
  Object.assign ||
  function assign(target) {
    return reduce.call(
      rest(arguments, 1),
      function(target, obj) {
        if (obj) {
          Object.keys(obj).forEach(function(prop) {
            target[prop] = obj[prop];
          });
        }
        return target;
      },
      target
    );
  };

function runAll(queue) {
  var queued;
  // eslint-disable-next-line no-cond-assign
  while ((queued = queue.shift())) {
    queued();
  }
}

function create(config) {
  var hooks = {};
  var postReady = [];

  config = assign({}, defaults, config);

  function dispatch(arg1, arg2) {
    if (typeof arg1 === "function") {
      return hookFn.call(null, "sync", arg1, arg2);
    } else if (typeof arg1 === "string" && typeof arg2 === "function") {
      return hookFn.apply(null, arguments);
    } else if (typeof arg1 === "object") {
      return hookObj.apply(null, arguments);
    }
  }

  var ready;
  if (config.ready) {
    dispatch.ready = function() {
      ready = true;
      runAll(postReady);
    };
  } else {
    ready = true;
  }

  function hookObj(obj, props, objName) {
    var walk = true;
    if (typeof props === "undefined") {
      props = Object.getOwnPropertyNames(obj);
      walk = false;
    }
    var objHooks = {};
    var doNotHook = ["constructor"];
    do {
      props = props.filter(function(prop) {
        return (
          typeof obj[prop] === "function" &&
          !(doNotHook.indexOf(prop) !== -1) &&
          !prop.match(/^_/)
        );
      });
      props.forEach(function(prop) {
        var parts = prop.split(":");
        var name = parts[0];
        var type = parts[1] || "sync";
        if (!objHooks[name]) {
          var fn = obj[name];
          objHooks[name] = obj[name] = hookFn(
            type,
            fn,
            objName ? [objName, name] : undefined
          );
        }
      });
      obj = Object.getPrototypeOf(obj);
    } while (walk && obj);
    return objHooks;
  }

  /**
   * Navigates a string path to return a hookable function.  If not found, creates a placeholder for hooks.
   * @param {(Array<string> | string)} path
   */
  function get(path) {
    var parts = Array.isArray(path) ? path : path.split(".");
    return reduce.call(
      parts,
      function(memo, part, i) {
        var item = memo[part];
        var installed = false;
        if (item) {
          return item;
        } else if (i === parts.length - 1) {
          if (!ready) {
            postReady.push(function() {
              if (!installed) {
                // eslint-disable-next-line no-console
                console.warn(
                  packageName +
                    ": referenced '" +
                    path +
                    "' but it was never created"
                );
              }
            });
          }
          return (memo[part] = newHookable(function(fn) {
            memo[part] = fn;
            installed = true;
          }));
        }
        return (memo[part] = {});
      },
      hooks
    );
  }

  function newHookable(onInstall) {
    var before = [];
    var after = [];
    var generateTrap = function() {};

    var api = {
      before: function(hook, priority) {
        return add.call(this, before, "before", hook, priority);
      },
      after: function(hook, priority) {
        return add.call(this, after, "after", hook, priority);
      },
      getHooks: function(match) {
        var hooks = before.concat(after);
        if (typeof match === "object") {
          hooks = hooks.filter(function(entry) {
            return Object.keys(match).every(function(prop) {
              return entry[prop] === match[prop];
            });
          });
        }
        try {
          assign(hooks, {
            remove: function() {
              hooks.forEach(function(entry) {
                entry.remove();
              });
              return this;
            }
          });
        } catch (e) {
          console.error(
            "error adding `remove` to array, did you modify Array.prototype?"
          );
        }
        return hooks;
      },
      removeAll: function() {
        return this.getHooks().remove();
      }
    };

    var meta = {
      install: function(type, fn, generate) {
        this.type = type;
        generateTrap = generate;
        generate(before, after);
        onInstall && onInstall(fn);
      }
    };

    // store meta data related to hookable. use `api.after` since `api` reference is not available on our proxy.
    hookableMap.set(api.after, meta);

    return api;

    function add(store, type, hook, priority) {
      var entry = {
        hook: hook,
        type: type,
        priority: priority || 10,
        remove: function() {
          var index = store.indexOf(entry);
          if (index !== -1) {
            store.splice(index, 1);
            generateTrap(before, after);
          }
        }
      };
      store.push(entry);
      store.sort(function(a, b) {
        return b.priority - a.priority;
      });
      generateTrap(before, after);
      return this;
    }
  }

  function hookFn(type, fn, name) {
    // check if function has already been wrapped
    var meta = fn.after && hookableMap.get(fn.after);
    if (meta) {
      if (meta.type !== type) {
        throw packageName + ": recreated hookable with different type";
      } else {
        return fn;
      }
    }

    var hookable = name ? get(name) : newHookable();

    var trap;
    var hookedFn;
    var handlers = {
      get: function(target, prop) {
        return hookable[prop] || Reflect.get.apply(Reflect, arguments);
      }
    };

    if (!ready) {
      postReady.push(setTrap);
    }

    if (config.useProxy && hasProxy()) {
      hookedFn = new Proxy(fn, handlers);
    } else {
      hookedFn = function() {
        return handlers.apply
          ? handlers.apply(fn, this, rest(arguments))
          : fn.apply(this, arguments);
      };
      assign(hookedFn, hookable);
    }

    hookableMap.get(hookedFn.after).install(type, hookedFn, generateTrap);

    return hookedFn;

    // eslint-disable-next-line no-redeclare
    function generateTrap(before, after) {
      var order = [];
      var targetIndex;
      if (before.length || after.length) {
        before.forEach(addToOrder);
        // placeholder for target function wrapper
        targetIndex = order.push(undefined) - 1;
        after.forEach(addToOrder);
        trap = function(target, thisArg, args) {
          var curr = 0;
          var result;
          var callback =
            type === "async" &&
            typeof args[args.length - 1] === "function" &&
            args.pop();
          function bail(value) {
            if (type === "sync") {
              result = value;
            } else if (callback) {
              callback.apply(null, arguments);
            }
          }
          function next(value) {
            if (order[curr]) {
              var args = rest(arguments);
              next.bail = bail;
              args.unshift(next);
              return order[curr++].apply(thisArg, args);
            }
            if (type === "sync") {
              result = value;
            } else if (callback) {
              callback.apply(null, arguments);
            }
          }
          order[targetIndex] = function() {
            var args = rest(arguments, 1);
            if (type === "async" && callback) {
              delete next.bail;
              args.push(next);
            }
            var result = target.apply(thisArg, args);
            if (type === "sync") {
              next(result);
            }
          };
          next.apply(null, args);
          return result;
        };
      } else {
        trap = undefined;
      }
      setTrap();

      function addToOrder(entry) {
        order.push(entry.hook);
      }
    }

    function setTrap() {
      if (
        ready ||
        (type === "sync" && !(config.ready & create.SYNC)) ||
        (type === "async" && !(config.ready & create.ASYNC))
      ) {
        handlers.apply = trap;
      } else if (type === "sync" || !(config.ready & create.QUEUE)) {
        handlers.apply = function() {
          throw packageName + ": hooked function not ready";
        };
      } else {
        handlers.apply = function() {
          var args = arguments;
          postReady.push(function() {
            hookedFn.apply(args[1], args[2]);
          });
        };
      }
    }
  }

  dispatch.get = get;
  return dispatch;
}

/* global module */
module.exports = create;


/***/ }),

/***/ "./node_modules/dset/dist/index.mjs":
/*!******************************************!*\
  !*** ./node_modules/dset/dist/index.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dset: () => (/* binding */ dset)
/* harmony export */ });
function dset(obj, keys, val) {
	keys.split && (keys=keys.split('.'));
	var i=0, l=keys.length, t=obj, x, k;
	while (i < l) {
		k = ''+keys[i++];
		if (k === '__proto__' || k === 'constructor' || k === 'prototype') break;
		t = t[k] = (i === l) ? val : (typeof(x=t[k])===typeof(keys)) ? x : (keys[i]*0 !== 0 || !!~(''+keys[i]).indexOf('.')) ? {} : [];
	}
}


/***/ }),

/***/ "./node_modules/klona/json/index.mjs":
/*!*******************************************!*\
  !*** ./node_modules/klona/json/index.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   klona: () => (/* binding */ klona)
/* harmony export */ });
function klona(val) {
	var k, out, tmp;

	if (Array.isArray(val)) {
		out = Array(k=val.length);
		while (k--) out[k] = (tmp=val[k]) && typeof tmp === 'object' ? klona(tmp) : tmp;
		return out;
	}

	if (Object.prototype.toString.call(val) === '[object Object]') {
		out = {}; // null
		for (k in val) {
			if (k === '__proto__') {
				Object.defineProperty(out, k, {
					value: klona(val[k]),
					configurable: true,
					enumerable: true,
					writable: true,
				});
			} else {
				out[k] = (tmp=val[k]) && typeof tmp === 'object' ? klona(tmp) : tmp;
			}
		}
		return out;
	}

	return val;
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var chunkIds = deferred[i][0];
/******/ 				var fn = deferred[i][1];
/******/ 				var priority = deferred[i][2];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"prebid-core": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["pbjsChunk"] = self["pbjsChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_require__("./src/prebid.js")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["chunk-core"],{

/***/ "./src/Renderer.js":
/*!*************************!*\
  !*** ./src/Renderer.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Renderer: () => (/* binding */ Renderer),
/* harmony export */   executeRenderer: () => (/* binding */ executeRenderer),
/* harmony export */   isRendererRequired: () => (/* binding */ isRendererRequired)
/* harmony export */ });
/* harmony import */ var _adloader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./adloader.js */ "./src/adloader.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _activities_modules_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./activities/modules.js */ "./src/activities/modules.js");




const pbjsInstance = (0,_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__.getGlobal)();
const moduleCode = 'outstream';

/**
 * @typedef {object} Renderer
 *
 * A Renderer stores some functions which are used to render a particular Bid.
 * These are used in Outstream Video Bids, returned on the Bid by the adapter, and will
 * be used to render that bid unless the Publisher overrides them.
 */

function Renderer(options) {
  const {
    url,
    config,
    id,
    callback,
    loaded,
    adUnitCode,
    renderNow
  } = options;
  this.url = url;
  this.config = config;
  this.handlers = {};
  this.id = id;
  this.renderNow = renderNow;
  this.adUnitCode = adUnitCode;

  // a renderer may push to the command queue to delay rendering until the
  // render function is loaded by loadExternalScript, at which point the the command
  // queue will be processed
  this.loaded = loaded;
  this.cmd = [];
  this.push = func => {
    if (typeof func !== 'function') {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)('Commands given to Renderer.push must be wrapped in a function');
      return;
    }
    this.loaded ? func.call() : this.cmd.push(func);
  };

  // bidders may override this with the `callback` property given to `install`
  this.callback = callback || (() => {
    this.loaded = true;
    this.process();
  });

  // use a function, not an arrow, in order to be able to pass "arguments" through
  this.render = function () {
    const renderArgs = arguments;
    const runRender = () => {
      if (this._render) {
        this._render.apply(this, renderArgs);
      } else {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`No render function was provided, please use .setRender on the renderer`);
      }
    };
    if (isRendererPreferredFromAdUnit(adUnitCode)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`External Js not loaded by Renderer since renderer url and callback is already defined on adUnit ${adUnitCode}`);
      runRender();
    } else if (renderNow) {
      runRender();
    } else {
      // we expect to load a renderer url once only so cache the request to load script
      this.cmd.unshift(runRender); // should render run first ?
      (0,_adloader_js__WEBPACK_IMPORTED_MODULE_2__.loadExternalScript)(url, _activities_modules_js__WEBPACK_IMPORTED_MODULE_3__.MODULE_TYPE_PREBID, moduleCode, this.callback, this.documentContext);
    }
  }.bind(this); // bind the function to this object to avoid 'this' errors
}
Renderer.install = function (_ref) {
  let {
    url,
    config,
    id,
    callback,
    loaded,
    adUnitCode,
    renderNow
  } = _ref;
  return new Renderer({
    url,
    config,
    id,
    callback,
    loaded,
    adUnitCode,
    renderNow
  });
};
Renderer.prototype.getConfig = function () {
  return this.config;
};
Renderer.prototype.setRender = function (fn) {
  this._render = fn;
};
Renderer.prototype.setEventHandlers = function (handlers) {
  this.handlers = handlers;
};
Renderer.prototype.handleVideoEvent = function (_ref2) {
  let {
    id,
    eventName
  } = _ref2;
  if (typeof this.handlers[eventName] === 'function') {
    this.handlers[eventName]();
  }
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logMessage)(`Prebid Renderer event for id ${id} type ${eventName}`);
};

/*
 * Calls functions that were pushed to the command queue before the
 * renderer was loaded by `loadExternalScript`
 */
Renderer.prototype.process = function () {
  while (this.cmd.length > 0) {
    try {
      this.cmd.shift().call();
    } catch (error) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`Error processing Renderer command on ad unit '${this.adUnitCode}':`, error);
    }
  }
};

/**
 * Checks whether creative rendering should be done by Renderer or not.
 * @param {Object} renderer Renderer object installed by adapter
 * @returns {Boolean}
 */
function isRendererRequired(renderer) {
  return !!(renderer && (renderer.url || renderer.renderNow));
}

/**
 * Render the bid returned by the adapter
 * @param {Object} renderer Renderer object installed by adapter
 * @param {Object} bid Bid response
 * @param {Document} doc context document of bid
 */
function executeRenderer(renderer, bid, doc) {
  let docContext = null;
  if (renderer.config && renderer.config.documentResolver) {
    docContext = renderer.config.documentResolver(bid, document, doc); // a user provided callback, which should return a Document, and expect the parameters; bid, sourceDocument, renderDocument
  }
  if (!docContext) {
    docContext = document;
  }
  renderer.documentContext = docContext;
  renderer.render(bid, renderer.documentContext);
}
function isRendererPreferredFromAdUnit(adUnitCode) {
  const adUnits = pbjsInstance.adUnits;
  const adUnit = adUnits.find(adUnit => {
    return adUnit.code === adUnitCode;
  });
  if (!adUnit) {
    return false;
  }

  // renderer defined at adUnit level
  const adUnitRenderer = adUnit?.renderer;
  const hasValidAdUnitRenderer = !!(adUnitRenderer && adUnitRenderer.url && adUnitRenderer.render);

  // renderer defined at adUnit.mediaTypes level
  const mediaTypeRenderer = adUnit?.mediaTypes?.video?.renderer;
  const hasValidMediaTypeRenderer = !!(mediaTypeRenderer && mediaTypeRenderer.url && mediaTypeRenderer.render);
  return !!(hasValidAdUnitRenderer && !(adUnitRenderer.backupOnly === true) || hasValidMediaTypeRenderer && !(mediaTypeRenderer.backupOnly === true));
}

/***/ }),

/***/ "./src/activities/activities.js":
/*!**************************************!*\
  !*** ./src/activities/activities.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ACTIVITY_ACCESS_DEVICE: () => (/* binding */ ACTIVITY_ACCESS_DEVICE),
/* harmony export */   ACTIVITY_ENRICH_EIDS: () => (/* binding */ ACTIVITY_ENRICH_EIDS),
/* harmony export */   ACTIVITY_ENRICH_UFPD: () => (/* binding */ ACTIVITY_ENRICH_UFPD),
/* harmony export */   ACTIVITY_FETCH_BIDS: () => (/* binding */ ACTIVITY_FETCH_BIDS),
/* harmony export */   ACTIVITY_REPORT_ANALYTICS: () => (/* binding */ ACTIVITY_REPORT_ANALYTICS),
/* harmony export */   ACTIVITY_SYNC_USER: () => (/* binding */ ACTIVITY_SYNC_USER),
/* harmony export */   ACTIVITY_TRANSMIT_EIDS: () => (/* binding */ ACTIVITY_TRANSMIT_EIDS),
/* harmony export */   ACTIVITY_TRANSMIT_PRECISE_GEO: () => (/* binding */ ACTIVITY_TRANSMIT_PRECISE_GEO),
/* harmony export */   ACTIVITY_TRANSMIT_TID: () => (/* binding */ ACTIVITY_TRANSMIT_TID),
/* harmony export */   ACTIVITY_TRANSMIT_UFPD: () => (/* binding */ ACTIVITY_TRANSMIT_UFPD),
/* harmony export */   LOAD_EXTERNAL_SCRIPT: () => (/* binding */ LOAD_EXTERNAL_SCRIPT)
/* harmony export */ });
/**
 * Activity (that are relevant for privacy) definitions
 *
 * ref. https://docs.google.com/document/d/1dRxFUFmhh2jGanzGZvfkK_6jtHPpHXWD7Qsi6KEugeE
 * & https://github.com/prebid/Prebid.js/issues/9546
 */

/**
 * accessDevice: some component wants to read or write to localStorage or cookies.
 */
const ACTIVITY_ACCESS_DEVICE = 'accessDevice';
/**
 * syncUser: A bid adapter wants to run a user sync.
 */
const ACTIVITY_SYNC_USER = 'syncUser';
/**
 * enrichUfpd: some component wants to add user first-party data to bid requests.
 */
const ACTIVITY_ENRICH_UFPD = 'enrichUfpd';
/**
 * enrichEids: some component wants to add user IDs to bid requests.
 */
const ACTIVITY_ENRICH_EIDS = 'enrichEids';
/**
 * fetchBid: a bidder wants to bid.
 */
const ACTIVITY_FETCH_BIDS = 'fetchBids';

/**
 * reportAnalytics: some component wants to phone home with analytics data.
 */
const ACTIVITY_REPORT_ANALYTICS = 'reportAnalytics';

/**
 * some component wants access to (and send along) user IDs
 */
const ACTIVITY_TRANSMIT_EIDS = 'transmitEids';

/**
 * transmitUfpd: some component wants access to (and send along) user FPD
 */
const ACTIVITY_TRANSMIT_UFPD = 'transmitUfpd';

/**
 * transmitPreciseGeo: some component wants access to (and send along) geolocation info
 */
const ACTIVITY_TRANSMIT_PRECISE_GEO = 'transmitPreciseGeo';

/**
 * transmit TID: some component wants access ot (and send along) transaction IDs
 */
const ACTIVITY_TRANSMIT_TID = 'transmitTid';

/**
 * loadExternalScript: adLoader.js is allowed to load external script
 */
const LOAD_EXTERNAL_SCRIPT = 'loadExternalScript';

/***/ }),

/***/ "./src/activities/activityParams.js":
/*!******************************************!*\
  !*** ./src/activities/activityParams.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   activityParams: () => (/* binding */ activityParams)
/* harmony export */ });
/* harmony import */ var _adapterManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../adapterManager.js */ "./src/adapterManager.js");
/* harmony import */ var _params_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./params.js */ "./src/activities/params.js");



/**
 * Utility function for building common activity parameters - broken out to its own
 * file to avoid circular imports.
 */
const activityParams = (0,_params_js__WEBPACK_IMPORTED_MODULE_0__.activityParamsBuilder)(alias => _adapterManager_js__WEBPACK_IMPORTED_MODULE_1__["default"].resolveAlias(alias));

/***/ }),

/***/ "./src/activities/modules.js":
/*!***********************************!*\
  !*** ./src/activities/modules.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MODULE_TYPE_ANALYTICS: () => (/* binding */ MODULE_TYPE_ANALYTICS),
/* harmony export */   MODULE_TYPE_BIDDER: () => (/* binding */ MODULE_TYPE_BIDDER),
/* harmony export */   MODULE_TYPE_PREBID: () => (/* binding */ MODULE_TYPE_PREBID),
/* harmony export */   MODULE_TYPE_RTD: () => (/* binding */ MODULE_TYPE_RTD),
/* harmony export */   MODULE_TYPE_UID: () => (/* binding */ MODULE_TYPE_UID)
/* harmony export */ });
const MODULE_TYPE_PREBID = 'prebid';
const MODULE_TYPE_BIDDER = 'bidder';
const MODULE_TYPE_UID = 'userId';
const MODULE_TYPE_RTD = 'rtd';
const MODULE_TYPE_ANALYTICS = 'analytics';

/***/ }),

/***/ "./src/activities/params.js":
/*!**********************************!*\
  !*** ./src/activities/params.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ACTIVITY_PARAM_ADAPTER_CODE: () => (/* binding */ ACTIVITY_PARAM_ADAPTER_CODE),
/* harmony export */   ACTIVITY_PARAM_ANL_CONFIG: () => (/* binding */ ACTIVITY_PARAM_ANL_CONFIG),
/* harmony export */   ACTIVITY_PARAM_COMPONENT: () => (/* binding */ ACTIVITY_PARAM_COMPONENT),
/* harmony export */   ACTIVITY_PARAM_COMPONENT_NAME: () => (/* binding */ ACTIVITY_PARAM_COMPONENT_NAME),
/* harmony export */   ACTIVITY_PARAM_COMPONENT_TYPE: () => (/* binding */ ACTIVITY_PARAM_COMPONENT_TYPE),
/* harmony export */   ACTIVITY_PARAM_S2S_NAME: () => (/* binding */ ACTIVITY_PARAM_S2S_NAME),
/* harmony export */   ACTIVITY_PARAM_STORAGE_TYPE: () => (/* binding */ ACTIVITY_PARAM_STORAGE_TYPE),
/* harmony export */   ACTIVITY_PARAM_SYNC_TYPE: () => (/* binding */ ACTIVITY_PARAM_SYNC_TYPE),
/* harmony export */   ACTIVITY_PARAM_SYNC_URL: () => (/* binding */ ACTIVITY_PARAM_SYNC_URL),
/* harmony export */   activityParamsBuilder: () => (/* binding */ activityParamsBuilder),
/* harmony export */   buildActivityParams: () => (/* binding */ buildActivityParams)
/* harmony export */ });
/* harmony import */ var _modules_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules.js */ "./src/activities/modules.js");
/* harmony import */ var _hook_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hook.js */ "./src/hook.js");



/**
 * Component ID - who is trying to perform the activity?
 * Relevant for all activities.
 */
const ACTIVITY_PARAM_COMPONENT = 'component';
const ACTIVITY_PARAM_COMPONENT_TYPE = ACTIVITY_PARAM_COMPONENT + 'Type';
const ACTIVITY_PARAM_COMPONENT_NAME = ACTIVITY_PARAM_COMPONENT + 'Name';

/**
 * Code of the bid adapter that `componentName` is an alias of.
 * May be the same as the component name.
 *
 * relevant for all activities, but only when componentType is 'bidder'.
 */
const ACTIVITY_PARAM_ADAPTER_CODE = 'adapterCode';

/**
 * Storage type - either 'html5' or 'cookie'.
 * Relevant for: accessDevice
 */
const ACTIVITY_PARAM_STORAGE_TYPE = 'storageType';

/**
 * s2sConfig[].configName, used to identify a particular s2s instance
 * relevant for: fetchBids, but only when component is 'prebid.pbsBidAdapter'
 */
const ACTIVITY_PARAM_S2S_NAME = 'configName';
/**
 * user sync type - 'iframe' or 'pixel'
 * relevant for: syncUser
 */
const ACTIVITY_PARAM_SYNC_TYPE = 'syncType';
/**
 * user sync URL
 * relevant for: syncUser
 */
const ACTIVITY_PARAM_SYNC_URL = 'syncUrl';
/**
 * Configuration options for analytics adapter - the argument passed to `enableAnalytics`.
 * Relevant for: reportAnalytics
 * @private
 * @constant
 * @type {string}
 */
const ACTIVITY_PARAM_ANL_CONFIG = '_config';
function activityParamsBuilder(resolveAlias) {
  return function activityParams(moduleType, moduleName, params) {
    const defaults = {
      [ACTIVITY_PARAM_COMPONENT_TYPE]: moduleType,
      [ACTIVITY_PARAM_COMPONENT_NAME]: moduleName,
      [ACTIVITY_PARAM_COMPONENT]: `${moduleType}.${moduleName}`
    };
    if (moduleType === _modules_js__WEBPACK_IMPORTED_MODULE_0__.MODULE_TYPE_BIDDER) {
      defaults[ACTIVITY_PARAM_ADAPTER_CODE] = resolveAlias(moduleName);
    }
    return buildActivityParams(Object.assign(defaults, params));
  };
}
const buildActivityParams = (0,_hook_js__WEBPACK_IMPORTED_MODULE_1__.hook)('sync', params => params);

/***/ }),

/***/ "./src/activities/redactor.js":
/*!************************************!*\
  !*** ./src/activities/redactor.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ORTB_EIDS_PATHS: () => (/* binding */ ORTB_EIDS_PATHS),
/* harmony export */   redactor: () => (/* binding */ redactor)
/* harmony export */ });
/* unused harmony exports ORTB_UFPD_PATHS, ORTB_GEO_PATHS, ORTB_IPV4_PATHS, ORTB_IPV6_PATHS, redactRule, objectTransformer, sessionedApplies, isData, appliesWhenActivityDenied, ortb2TransmitRules, redactorFactory */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../config.js */ "./src/config.js");
/* harmony import */ var _rules_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rules.js */ "./src/activities/rules.js");
/* harmony import */ var _activities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./activities.js */ "./src/activities/activities.js");
/* harmony import */ var _utils_ipUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/ipUtils.js */ "./src/utils/ipUtils.js");





const ORTB_UFPD_PATHS = ['data', 'ext.data', 'yob', 'gender', 'keywords', 'kwarray', 'id', 'buyeruid', 'customdata'].map(f => `user.${f}`).concat('device.ext.cdep');
const ORTB_EIDS_PATHS = ['user.eids', 'user.ext.eids'];
const ORTB_GEO_PATHS = ['user.geo.lat', 'user.geo.lon', 'device.geo.lat', 'device.geo.lon'];
const ORTB_IPV4_PATHS = ['device.ip'];
const ORTB_IPV6_PATHS = ['device.ipv6'];

/**
 * @typedef TransformationRuleDef
 * @property {name}
 * @property {Array[string]} paths dot-separated list of paths that this rule applies to.
 * @property {function(*): boolean} applies a predicate that should return true if this rule applies
 * (and the transformation defined herein should be applied). The arguments are those passed to the transformation function.
 * @property {name} a name for the rule; used to debounce calls to `applies` (and avoid excessive logging):
 * if a rule with the same name was already found to apply (or not), this one will (or won't) as well.
 */

/**
 * @typedef RedactRuleDef A rule that removes, or replaces, values from an object (modifications are done in-place).
 * @augments TransformationRuleDef
 * @property {function(*): *} get? substitution functions for values that should be redacted;
 *  takes in the original (unredacted) value as an input, and returns a substitute to use in the redacted
 *  version. If it returns undefined, or this option is omitted, protected paths will be removed
 *  from the redacted object.
 */

/**
 * @param {RedactRuleDef} ruleDef
 * @return {TransformationRule}
 */
function redactRule(ruleDef) {
  return Object.assign({
    get() {},
    run(root, path, object, property, applies) {
      const val = object && object[property];
      if (isData(val) && applies()) {
        const repl = this.get(val);
        if (repl === undefined) {
          delete object[property];
        } else {
          object[property] = repl;
        }
      }
    }
  }, ruleDef);
}

/**
 * @typedef TransformationRule
 * @augments TransformationRuleDef
 * @property {function} run rule logic - see `redactRule` for an example.
 */

/**
 * @typedef {Function} TransformationFunction
 * @param object object to transform
 * @param ...args arguments to pass down to rule's `apply` methods.
 */

/**
 * Return a transformation function that will apply the given rules to an object.
 *
 * @param {Array[TransformationRule]} rules
 * @return {TransformationFunction}
 */
function objectTransformer(rules) {
  rules.forEach(rule => {
    rule.paths = rule.paths.map(path => {
      const parts = path.split('.');
      const tail = parts.pop();
      return [parts.length > 0 ? parts.join('.') : null, tail];
    });
  });
  return function applyTransform(session, obj) {
    const result = [];
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    const applies = sessionedApplies(session, ...args);
    rules.forEach(rule => {
      if (session[rule.name] === false) return;
      for (const [head, tail] of rule.paths) {
        const parent = head == null ? obj : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"])(obj, head);
        result.push(rule.run(obj, head, parent, tail, applies.bind(null, rule)));
        if (session[rule.name] === false) return;
      }
    });
    return result.filter(el => el != null);
  };
}
function sessionedApplies(session) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  return function applies(rule) {
    if (!session.hasOwnProperty(rule.name)) {
      session[rule.name] = !!rule.applies(...args);
    }
    return session[rule.name];
  };
}
function isData(val) {
  return val != null && (typeof val !== 'object' || Object.keys(val).length > 0);
}
function appliesWhenActivityDenied(activity) {
  let isAllowed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _rules_js__WEBPACK_IMPORTED_MODULE_1__.isActivityAllowed;
  return function applies(params) {
    return !isAllowed(activity, params);
  };
}
function bidRequestTransmitRules() {
  let isAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _rules_js__WEBPACK_IMPORTED_MODULE_1__.isActivityAllowed;
  return [{
    name: _activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_EIDS,
    paths: ['userId', 'userIdAsEids'],
    applies: appliesWhenActivityDenied(_activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_EIDS, isAllowed)
  }, {
    name: _activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_TID,
    paths: ['ortb2Imp.ext.tid'],
    applies: appliesWhenActivityDenied(_activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_TID, isAllowed)
  }].map(redactRule);
}
function ortb2TransmitRules() {
  let isAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _rules_js__WEBPACK_IMPORTED_MODULE_1__.isActivityAllowed;
  return [{
    name: _activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_UFPD,
    paths: ORTB_UFPD_PATHS,
    applies: appliesWhenActivityDenied(_activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_UFPD, isAllowed)
  }, {
    name: _activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_EIDS,
    paths: ORTB_EIDS_PATHS,
    applies: appliesWhenActivityDenied(_activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_EIDS, isAllowed)
  }, {
    name: _activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_PRECISE_GEO,
    paths: ORTB_GEO_PATHS,
    applies: appliesWhenActivityDenied(_activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_PRECISE_GEO, isAllowed),
    get(val) {
      return Math.round((val + Number.EPSILON) * 100) / 100;
    }
  }, {
    name: _activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_PRECISE_GEO,
    paths: ORTB_IPV4_PATHS,
    applies: appliesWhenActivityDenied(_activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_PRECISE_GEO, isAllowed),
    get(val) {
      return (0,_utils_ipUtils_js__WEBPACK_IMPORTED_MODULE_3__.scrubIPv4)(val);
    }
  }, {
    name: _activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_PRECISE_GEO,
    paths: ORTB_IPV6_PATHS,
    applies: appliesWhenActivityDenied(_activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_PRECISE_GEO, isAllowed),
    get(val) {
      return (0,_utils_ipUtils_js__WEBPACK_IMPORTED_MODULE_3__.scrubIPv6)(val);
    }
  }, {
    name: _activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_TID,
    paths: ['source.tid'],
    applies: appliesWhenActivityDenied(_activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_TID, isAllowed)
  }].map(redactRule);
}
function redactorFactory() {
  let isAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _rules_js__WEBPACK_IMPORTED_MODULE_1__.isActivityAllowed;
  const redactOrtb2 = objectTransformer(ortb2TransmitRules(isAllowed));
  const redactBidRequest = objectTransformer(bidRequestTransmitRules(isAllowed));
  return function redactor(params) {
    const session = {};
    return {
      ortb2(obj) {
        redactOrtb2(session, obj, params);
        return obj;
      },
      bidRequest(obj) {
        redactBidRequest(session, obj, params);
        return obj;
      }
    };
  };
}

/**
 * Returns an object that can redact other privacy-sensitive objects according
 * to activity rules.
 *
 * @param {{}} params activity parameters to use for activity checks
 * @return {{ortb2: function({}): {}, bidRequest: function({}): {}}} methods
 *  that can redact disallowed data from ORTB2 and/or bid request objects.
 */
const redactor = redactorFactory();

// by default, TIDs are off since version 8
(0,_rules_js__WEBPACK_IMPORTED_MODULE_1__.registerActivityControl)(_activities_js__WEBPACK_IMPORTED_MODULE_2__.ACTIVITY_TRANSMIT_TID, 'enableTIDs config', () => {
  if (!_config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('enableTIDs')) {
    return {
      allow: false,
      reason: 'TIDs are disabled'
    };
  }
});

/***/ }),

/***/ "./src/activities/rules.js":
/*!*********************************!*\
  !*** ./src/activities/rules.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isActivityAllowed: () => (/* binding */ isActivityAllowed),
/* harmony export */   registerActivityControl: () => (/* binding */ registerActivityControl)
/* harmony export */ });
/* unused harmony export ruleRegistry */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./src/utils.js");
/* harmony import */ var _params_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./params.js */ "./src/activities/params.js");


function ruleRegistry() {
  let logger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.prefixLog)('Activity control:');
  const registry = {};
  function getRules(activity) {
    return registry[activity] = registry[activity] || [];
  }
  function runRule(activity, name, rule, params) {
    let res;
    try {
      res = rule(params);
    } catch (e) {
      logger.logError(`Exception in rule ${name} for '${activity}'`, e);
      res = {
        allow: false,
        reason: e
      };
    }
    return res && Object.assign({
      activity,
      name,
      component: params[_params_js__WEBPACK_IMPORTED_MODULE_1__.ACTIVITY_PARAM_COMPONENT]
    }, res);
  }
  const dupes = {};
  const DEDUPE_INTERVAL = 1000;
  function logResult(_ref) {
    let {
      activity,
      name,
      allow,
      reason,
      component
    } = _ref;
    const msg = `${name} ${allow ? 'allowed' : 'denied'} '${activity}' for '${component}'${reason ? ':' : ''}`;
    const deduping = dupes.hasOwnProperty(msg);
    if (deduping) {
      clearTimeout(dupes[msg]);
    }
    dupes[msg] = setTimeout(() => delete dupes[msg], DEDUPE_INTERVAL);
    if (!deduping) {
      const parts = [msg];
      reason && parts.push(reason);
      (allow ? logger.logInfo : logger.logWarn).apply(logger, parts);
    }
  }
  return [
  /**
   * Register an activity control rule.
   *
   * @param {string} activity - Activity name, as defined in `activities.js`.
   * @param {string} ruleName - A name for this rule, used for logging.
   * @param {function(Object): {allow: boolean, reason?: string}} rule - Rule definition function. Takes in activity
   *        parameters as a single map; MAY return an object {allow, reason}, where allow is true/false,
   *        and reason is an optional message used for logging.
   *
   *        {allow: true} will allow this activity AS LONG AS no other rules with the same or higher priority return {allow: false};
   *        {allow: false} will deny this activity AS LONG AS no other rules with higher priority return {allow: true};
   *        Returning null/undefined has no effect - the decision is left to other rules.
   *        If no rule returns an allow value, the default is to allow the activity.
   *
   * @param {number} [priority=10] - Rule priority; lower number means higher priority.
   * @returns {function(): void} - A function that unregisters the rule when called.
   */
  function registerActivityControl(activity, ruleName, rule) {
    let priority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
    const rules = getRules(activity);
    const pos = rules.findIndex(_ref2 => {
      let [itemPriority] = _ref2;
      return priority < itemPriority;
    });
    const entry = [priority, ruleName, rule];
    rules.splice(pos < 0 ? rules.length : pos, 0, entry);
    return function () {
      const idx = rules.indexOf(entry);
      if (idx >= 0) rules.splice(idx, 1);
    };
  },
  /**
   * Test whether an activity is allowed.
   *
   * @param {string} activity activity name
   * @param {{}} params activity parameters; should be generated through the `activityParams` utility.
   * @return {boolean} true for allow, false for deny.
   */
  function isActivityAllowed(activity, params) {
    let lastPriority, foundAllow;
    for (const [priority, name, rule] of getRules(activity)) {
      if (lastPriority !== priority && foundAllow) break;
      lastPriority = priority;
      const ruleResult = runRule(activity, name, rule, params);
      if (ruleResult) {
        if (!ruleResult.allow) {
          logResult(ruleResult);
          return false;
        } else {
          foundAllow = ruleResult;
        }
      }
    }
    foundAllow && logResult(foundAllow);
    return true;
  }];
}
const [registerActivityControl, isActivityAllowed] = ruleRegistry();

/***/ }),

/***/ "./src/adRendering.js":
/*!****************************!*\
  !*** ./src/adRendering.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deferRendering: () => (/* binding */ deferRendering),
/* harmony export */   getBidToRender: () => (/* binding */ getBidToRender),
/* harmony export */   getRenderingData: () => (/* binding */ getRenderingData),
/* harmony export */   handleCreativeEvent: () => (/* binding */ handleCreativeEvent),
/* harmony export */   handleNativeMessage: () => (/* binding */ handleNativeMessage),
/* harmony export */   handleRender: () => (/* binding */ handleRender),
/* harmony export */   insertLocatorFrame: () => (/* binding */ insertLocatorFrame),
/* harmony export */   markBidAsRendered: () => (/* binding */ markBidAsRendered),
/* harmony export */   markWinner: () => (/* binding */ markWinner),
/* harmony export */   markWinningBid: () => (/* binding */ markWinningBid),
/* harmony export */   renderAdDirect: () => (/* binding */ renderAdDirect),
/* harmony export */   renderIfDeferred: () => (/* binding */ renderIfDeferred)
/* harmony export */ });
/* unused harmony exports emitAdRenderFail, emitAdRenderSucceeded, doRender */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./events.js */ "./src/events.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./src/constants.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./config.js */ "./src/config.js");
/* harmony import */ var _Renderer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Renderer.js */ "./src/Renderer.js");
/* harmony import */ var _mediaTypes_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mediaTypes.js */ "./src/mediaTypes.js");
/* harmony import */ var _auctionManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./auctionManager.js */ "./src/auctionManager.js");
/* harmony import */ var _creativeRenderers_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./creativeRenderers.js */ "./src/creativeRenderers.js");
/* harmony import */ var _hook_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hook.js */ "./src/hook.js");
/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./native.js */ "./src/native.js");
/* harmony import */ var _utils_promise_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _adapterManager_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./adapterManager.js */ "./src/adapterManager.js");
/* harmony import */ var _utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/perfMetrics.js */ "./src/utils/perfMetrics.js");
/* harmony import */ var _targeting_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./targeting.js */ "./src/targeting.js");
/* harmony import */ var _eventTrackers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./eventTrackers.js */ "./src/eventTrackers.js");















const {
  AD_RENDER_FAILED,
  AD_RENDER_SUCCEEDED,
  STALE_RENDER,
  BID_WON,
  EXPIRED_RENDER
} = _constants_js__WEBPACK_IMPORTED_MODULE_0__.EVENTS;
const {
  EXCEPTION
} = _constants_js__WEBPACK_IMPORTED_MODULE_0__.AD_RENDER_FAILED_REASON;
const getBidToRender = (0,_hook_js__WEBPACK_IMPORTED_MODULE_1__.hook)('sync', function (adId) {
  let forRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  let override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _utils_promise_js__WEBPACK_IMPORTED_MODULE_2__.PbPromise.resolve();
  return override.then(bid => bid ?? _auctionManager_js__WEBPACK_IMPORTED_MODULE_3__.auctionManager.findBidByAdId(adId)).catch(() => {});
});
const markWinningBid = (0,_hook_js__WEBPACK_IMPORTED_MODULE_1__.hook)('sync', function (bid) {
  ((0,_eventTrackers_js__WEBPACK_IMPORTED_MODULE_4__.parseEventTrackers)(bid.eventtrackers)[_eventTrackers_js__WEBPACK_IMPORTED_MODULE_4__.EVENT_TYPE_WIN]?.[_eventTrackers_js__WEBPACK_IMPORTED_MODULE_4__.TRACKER_METHOD_IMG] || []).forEach(url => (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.triggerPixel)(url));
  _events_js__WEBPACK_IMPORTED_MODULE_6__.emit(BID_WON, bid);
  _auctionManager_js__WEBPACK_IMPORTED_MODULE_3__.auctionManager.addWinningBid(bid);
});

/**
 * Emit the AD_RENDER_FAILED event.
 *
 * @param {Object} data
 * @param data.reason one of the values in AD_RENDER_FAILED_REASON
 * @param data.message failure description
 * @param [data.bid] bid response object that failed to render
 * @param [data.id] adId that failed to render
 */
function emitAdRenderFail(_ref) {
  let {
    reason,
    message,
    bid,
    id
  } = _ref;
  const data = {
    reason,
    message
  };
  if (bid) {
    data.bid = bid;
    data.adId = bid.adId;
  }
  if (id) data.adId = id;
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logError)(`Error rendering ad (id: ${id}): ${message}`);
  _events_js__WEBPACK_IMPORTED_MODULE_6__.emit(AD_RENDER_FAILED, data);
}

/**
 * Emit the AD_RENDER_SUCCEEDED event.
 * (Note: Invocation of this function indicates that the render function did not generate an error, it does not guarantee that tracking for this event has occurred yet.)
 * @param {Object} data
 * @param data.doc document object that was used to `.write` the ad. Should be `null` if unavailable (e.g. for documents in
 * a cross-origin frame).
 * @param [data.bid] bid response object for the ad that was rendered
 * @param [data.id] adId that was rendered.
 */
function emitAdRenderSucceeded(_ref2) {
  let {
    doc,
    bid,
    id
  } = _ref2;
  const data = {
    doc
  };
  if (bid) data.bid = bid;
  if (id) data.adId = id;
  _adapterManager_js__WEBPACK_IMPORTED_MODULE_7__["default"].callAdRenderSucceededBidder(bid.adapterCode || bid.bidder, bid);
  _events_js__WEBPACK_IMPORTED_MODULE_6__.emit(AD_RENDER_SUCCEEDED, data);
}
function handleCreativeEvent(data, bidResponse) {
  switch (data.event) {
    case _constants_js__WEBPACK_IMPORTED_MODULE_0__.EVENTS.AD_RENDER_FAILED:
      emitAdRenderFail({
        bid: bidResponse,
        id: bidResponse.adId,
        reason: data.info.reason,
        message: data.info.message
      });
      break;
    case _constants_js__WEBPACK_IMPORTED_MODULE_0__.EVENTS.AD_RENDER_SUCCEEDED:
      emitAdRenderSucceeded({
        doc: null,
        bid: bidResponse,
        id: bidResponse.adId
      });
      break;
    default:
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logError)(`Received event request for unsupported event: '${data.event}' (adId: '${bidResponse.adId}')`);
  }
}
function handleNativeMessage(data, bidResponse, _ref3) {
  let {
    resizeFn,
    fireTrackers = _native_js__WEBPACK_IMPORTED_MODULE_8__.fireNativeTrackers
  } = _ref3;
  switch (data.action) {
    case 'resizeNativeHeight':
      resizeFn(data.width, data.height);
      break;
    default:
      fireTrackers(data, bidResponse);
  }
}
const HANDLERS = {
  [_constants_js__WEBPACK_IMPORTED_MODULE_0__.MESSAGES.EVENT]: handleCreativeEvent
};
if (true) {
  HANDLERS[_constants_js__WEBPACK_IMPORTED_MODULE_0__.MESSAGES.NATIVE] = handleNativeMessage;
}
function creativeMessageHandler(deps) {
  return function (type, data, bidResponse) {
    if (HANDLERS.hasOwnProperty(type)) {
      HANDLERS[type](data, bidResponse, deps);
    }
  };
}
const getRenderingData = (0,_hook_js__WEBPACK_IMPORTED_MODULE_1__.hook)('sync', function (bidResponse, options) {
  const {
    ad,
    adUrl,
    cpm,
    originalCpm,
    width,
    height,
    instl
  } = bidResponse;
  const repl = {
    AUCTION_PRICE: originalCpm || cpm,
    CLICKTHROUGH: options?.clickUrl || ''
  };
  return {
    ad: (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.replaceMacros)(ad, repl),
    adUrl: (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.replaceMacros)(adUrl, repl),
    width,
    height,
    instl
  };
});
const doRender = (0,_hook_js__WEBPACK_IMPORTED_MODULE_1__.hook)('sync', function (_ref4) {
  let {
    renderFn,
    resizeFn,
    bidResponse,
    options,
    doc,
    isMainDocument = doc === document && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.inIframe)()
  } = _ref4;
  const videoBid =  true && bidResponse.mediaType === _mediaTypes_js__WEBPACK_IMPORTED_MODULE_9__.VIDEO;
  if (isMainDocument || videoBid) {
    emitAdRenderFail({
      reason: _constants_js__WEBPACK_IMPORTED_MODULE_0__.AD_RENDER_FAILED_REASON.PREVENT_WRITING_ON_MAIN_DOCUMENT,
      message: videoBid ? 'Cannot render video ad without a renderer' : `renderAd was prevented from writing to the main document.`,
      bid: bidResponse,
      id: bidResponse.adId
    });
    return;
  }
  const data = getRenderingData(bidResponse, options);
  renderFn(Object.assign({
    adId: bidResponse.adId
  }, data));
  const {
    width,
    height
  } = data;
  if ((width ?? height) != null) {
    resizeFn(width, height);
  }
});
doRender.before(function (next, args) {
  // run renderers from a high priority hook to allow the video module to insert itself between this and "normal" rendering.
  const {
    bidResponse,
    doc
  } = args;
  if ((0,_Renderer_js__WEBPACK_IMPORTED_MODULE_10__.isRendererRequired)(bidResponse.renderer)) {
    (0,_Renderer_js__WEBPACK_IMPORTED_MODULE_10__.executeRenderer)(bidResponse.renderer, bidResponse, doc);
    emitAdRenderSucceeded({
      doc,
      bid: bidResponse,
      id: bidResponse.adId
    });
    next.bail();
  } else {
    next(args);
  }
}, 100);
function handleRender(_ref5) {
  let {
    renderFn,
    resizeFn,
    adId,
    options,
    bidResponse,
    doc
  } = _ref5;
  deferRendering(bidResponse, () => {
    if (bidResponse == null) {
      emitAdRenderFail({
        reason: _constants_js__WEBPACK_IMPORTED_MODULE_0__.AD_RENDER_FAILED_REASON.CANNOT_FIND_AD,
        message: `Cannot find ad '${adId}'`,
        id: adId
      });
      return;
    }
    if (bidResponse.status === _constants_js__WEBPACK_IMPORTED_MODULE_0__.BID_STATUS.RENDERED) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logWarn)(`Ad id ${adId} has been rendered before`);
      _events_js__WEBPACK_IMPORTED_MODULE_6__.emit(STALE_RENDER, bidResponse);
      if (_config_js__WEBPACK_IMPORTED_MODULE_11__.config.getConfig('auctionOptions')?.suppressStaleRender) {
        return;
      }
    }
    if (!_targeting_js__WEBPACK_IMPORTED_MODULE_12__.filters.isBidNotExpired(bidResponse)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logWarn)(`Ad id ${adId} has been expired`);
      _events_js__WEBPACK_IMPORTED_MODULE_6__.emit(EXPIRED_RENDER, bidResponse);
      if (_config_js__WEBPACK_IMPORTED_MODULE_11__.config.getConfig('auctionOptions')?.suppressExpiredRender) {
        return;
      }
    }
    try {
      doRender({
        renderFn,
        resizeFn,
        bidResponse,
        options,
        doc
      });
    } catch (e) {
      emitAdRenderFail({
        reason: _constants_js__WEBPACK_IMPORTED_MODULE_0__.AD_RENDER_FAILED_REASON.EXCEPTION,
        message: e.message,
        id: adId,
        bid: bidResponse
      });
    }
  });
}
function markBidAsRendered(bidResponse) {
  const metrics = (0,_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_13__.useMetrics)(bidResponse.metrics);
  metrics.checkpoint('bidRender');
  metrics.timeBetween('bidWon', 'bidRender', 'render.deferred');
  metrics.timeBetween('auctionEnd', 'bidRender', 'render.pending');
  metrics.timeBetween('requestBids', 'bidRender', 'render.e2e');
  bidResponse.status = _constants_js__WEBPACK_IMPORTED_MODULE_0__.BID_STATUS.RENDERED;
}
const DEFERRED_RENDER = new WeakMap();
const WINNERS = new WeakSet();
function deferRendering(bidResponse, renderFn) {
  if (bidResponse == null) {
    // if the bid is missing, let renderFn deal with it now
    renderFn();
    return;
  }
  DEFERRED_RENDER.set(bidResponse, renderFn);
  if (!bidResponse.deferRendering) {
    renderIfDeferred(bidResponse);
  }
  markWinner(bidResponse);
}
function markWinner(bidResponse) {
  if (!WINNERS.has(bidResponse)) {
    WINNERS.add(bidResponse);
    markWinningBid(bidResponse);
  }
}
function renderIfDeferred(bidResponse) {
  const renderFn = DEFERRED_RENDER.get(bidResponse);
  if (renderFn) {
    renderFn();
    markBidAsRendered(bidResponse);
    DEFERRED_RENDER.delete(bidResponse);
  }
}
function renderAdDirect(doc, adId, options) {
  let bid;
  function fail(reason, message) {
    emitAdRenderFail(Object.assign({
      id: adId,
      bid
    }, {
      reason,
      message
    }));
  }
  function resizeFn(width, height) {
    const frame = doc.defaultView?.frameElement;
    if (frame) {
      if (width) {
        frame.width = width;
        frame.style.width && (frame.style.width = `${width}px`);
      }
      if (height) {
        frame.height = height;
        frame.style.height && (frame.style.height = `${height}px`);
      }
    }
  }
  const messageHandler = creativeMessageHandler({
    resizeFn
  });
  function renderFn(adData) {
    if (adData.ad) {
      doc.write(adData.ad);
      doc.close();
      emitAdRenderSucceeded({
        doc,
        bid,
        id: bid.adId
      });
    } else {
      (0,_creativeRenderers_js__WEBPACK_IMPORTED_MODULE_14__.getCreativeRenderer)(bid).then(render => render(adData, {
        sendMessage: (type, data) => messageHandler(type, data, bid),
        mkFrame: _utils_js__WEBPACK_IMPORTED_MODULE_5__.createIframe
      }, doc.defaultView)).then(() => emitAdRenderSucceeded({
        doc,
        bid,
        id: bid.adId
      }), e => {
        fail(e?.reason || _constants_js__WEBPACK_IMPORTED_MODULE_0__.AD_RENDER_FAILED_REASON.EXCEPTION, e?.message);
        e?.stack && (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logError)(e);
      });
    }
    // TODO: this is almost certainly the wrong way to do this
    const creativeComment = document.createComment(`Creative ${bid.creativeId} served by ${bid.bidder} Prebid.js Header Bidding`);
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.insertElement)(creativeComment, doc, 'html');
  }
  try {
    if (!adId || !doc) {
      fail(_constants_js__WEBPACK_IMPORTED_MODULE_0__.AD_RENDER_FAILED_REASON.MISSING_DOC_OR_ADID, `missing ${adId ? 'doc' : 'adId'}`);
    } else {
      getBidToRender(adId).then(bidResponse => {
        bid = bidResponse;
        handleRender({
          renderFn,
          resizeFn,
          adId,
          options: {
            clickUrl: options?.clickThrough
          },
          bidResponse,
          doc
        });
      });
    }
  } catch (e) {
    fail(EXCEPTION, e.message);
  }
}

/**
 * Insert an invisible, named iframe that can be used by creatives to locate the window Prebid is running in
 * (by looking for one that has `.frames[PB_LOCATOR]` defined).
 * This is necessary because in some situations creatives may be rendered inside nested iframes - Prebid is not necessarily
 * in the immediate parent window.
 */
function insertLocatorFrame() {
  if (!window.frames[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PB_LOCATOR]) {
    if (!document.body) {
      window.requestAnimationFrame(insertLocatorFrame);
    } else {
      const frame = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.createInvisibleIframe)();
      frame.name = _constants_js__WEBPACK_IMPORTED_MODULE_0__.PB_LOCATOR;
      document.body.appendChild(frame);
    }
  }
}

/***/ }),

/***/ "./src/adServerManager.js":
/*!********************************!*\
  !*** ./src/adServerManager.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerVideoSupport: () => (/* binding */ registerVideoSupport)
/* harmony export */ });
/* harmony import */ var _prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");


const prebid = (0,_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__.getGlobal)();

/**
 * This file defines the plugin points in prebid-core for AdServer-specific functionality.
 *
 * Its main job is to expose functions for AdServer modules to append functionality to the Prebid public API.
 * For a given Ad Server with name "adServerName", these functions will only change the API in the
 * $$PREBID_GLOBAL$$.adServers[adServerName] namespace.
 */

/**
 * @typedef {Object} CachedVideoBid
 *
 * @property {string} videoCacheId The ID which can be used to retrieve this video from prebid-server.
 *   This is the same ID given to the callback in the videoCache's store function.
 */

/**
 * @function VideoAdUrlBuilder
 *
 * @param {CachedVideoBid} bid The winning Bid which the ad server should show, assuming it beats out
 *   the competition.
 *
 * @param {Object} options Options required by the Ad Server to make a valid AdServer URL.
 *   This object will have different properties depending on the specific ad server supported.
 *   For more information, see the docs inside the ad server module you're supporting.
 *
 * @return {string} A URL which can be passed into the Video player to play an ad.
 */

/**
 * @typedef {Object} VideoSupport
 *
 * @property {VideoAdUrlBuilder} buildVideoAdUrl
 */

/**
 * Enable video support for the Ad Server.
 *
 * @property {string} name The identifying name for this adserver.
 * @property {VideoSupport} videoSupport An object with the functions needed to support video in Prebid.
 */
function registerVideoSupport(name, videoSupport) {
  prebid.adServers = prebid.adServers || {};
  prebid.adServers[name] = prebid.adServers[name] || {};
  Object.keys(videoSupport).forEach(key => {
    if (prebid.adServers[name][key]) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Attempting to add an already registered function property ${key} for AdServer ${name}.`);
      return;
    }
    prebid.adServers[name][key] = videoSupport[key];
  });
}

/***/ }),

/***/ "./src/adUnits.js":
/*!************************!*\
  !*** ./src/adUnits.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getAuctionsCounter: () => (/* binding */ getAuctionsCounter),
/* harmony export */   getBidderRequestsCounter: () => (/* binding */ getBidderRequestsCounter),
/* harmony export */   getBidderWinsCounter: () => (/* binding */ getBidderWinsCounter),
/* harmony export */   getRequestsCounter: () => (/* binding */ getRequestsCounter),
/* harmony export */   incrementAuctionsCounter: () => (/* binding */ incrementAuctionsCounter),
/* harmony export */   incrementBidderRequestsCounter: () => (/* binding */ incrementBidderRequestsCounter),
/* harmony export */   incrementBidderWinsCounter: () => (/* binding */ incrementBidderWinsCounter),
/* harmony export */   incrementRequestsCounter: () => (/* binding */ incrementRequestsCounter)
/* harmony export */ });
/* unused harmony export reset */
let adUnits = {};
function reset() {
  adUnits = {};
}
function ensureAdUnit(adunit, bidderCode) {
  let adUnit = adUnits[adunit] = adUnits[adunit] || {
    bidders: {}
  };
  if (bidderCode) {
    return adUnit.bidders[bidderCode] = adUnit.bidders[bidderCode] || {};
  }
  return adUnit;
}
function incrementAdUnitCount(adunit, counter, bidderCode) {
  let adUnit = ensureAdUnit(adunit, bidderCode);
  adUnit[counter] = (adUnit[counter] || 0) + 1;
  return adUnit[counter];
}

/**
 * Increments and returns current Adunit counter
 * @param {string} adunit id
 * @returns {number} current adunit count
 */
function incrementRequestsCounter(adunit) {
  return incrementAdUnitCount(adunit, 'requestsCounter');
}

/**
 * Increments and returns current Adunit requests counter for a bidder
 * @param {string} adunit id
 * @param {string} bidderCode code
 * @returns {number} current adunit bidder requests count
 */
function incrementBidderRequestsCounter(adunit, bidderCode) {
  return incrementAdUnitCount(adunit, 'requestsCounter', bidderCode);
}

/**
 * Increments and returns current Adunit wins counter for a bidder
 * @param {string} adunit id
 * @param {string} bidderCode code
 * @returns {number} current adunit bidder requests count
 */
function incrementBidderWinsCounter(adunit, bidderCode) {
  return incrementAdUnitCount(adunit, 'winsCounter', bidderCode);
}

/**
 * Increments and returns current Adunit auctions counter
 * @param {string} adunit id
 * @returns {number} current adunit auctions count
 */
function incrementAuctionsCounter(adunit) {
  return incrementAdUnitCount(adunit, 'auctionsCounter');
}

/**
 * Returns current Adunit counter
 * @param {string} adunit id
 * @returns {number} current adunit count
 */
function getRequestsCounter(adunit) {
  return adUnits?.[adunit]?.requestsCounter || 0;
}

/**
 * Returns current Adunit requests counter for a specific bidder code
 * @param {string} adunit id
 * @param {string} bidder code
 * @returns {number} current adunit bidder requests count
 */
function getBidderRequestsCounter(adunit, bidder) {
  return adUnits?.[adunit]?.bidders?.[bidder]?.requestsCounter || 0;
}

/**
 * Returns current Adunit requests counter for a specific bidder code
 * @param {string} adunit id
 * @param {string} bidder code
 * @returns {number} current adunit bidder requests count
 */
function getBidderWinsCounter(adunit, bidder) {
  return adUnits?.[adunit]?.bidders?.[bidder]?.winsCounter || 0;
}

/**
 * Returns current Adunit auctions counter
 * @param {string} adunit id
 * @returns {number} current adunit auctions count
 */
function getAuctionsCounter(adunit) {
  return adUnits?.[adunit]?.auctionsCounter || 0;
}

/***/ }),

/***/ "./src/adapter.js":
/*!************************!*\
  !*** ./src/adapter.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Adapter)
/* harmony export */ });
function Adapter(code) {
  var bidderCode = code;
  function setBidderCode(code) {
    bidderCode = code;
  }
  function getBidderCode() {
    return bidderCode;
  }
  function callBids() {}
  return {
    callBids: callBids,
    setBidderCode: setBidderCode,
    getBidderCode: getBidderCode
  };
}

/***/ }),

/***/ "./src/adapterManager.js":
/*!*******************************!*\
  !*** ./src/adapterManager.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getS2SBidderSet: () => (/* binding */ getS2SBidderSet),
/* harmony export */   s2sActivityParams: () => (/* binding */ s2sActivityParams)
/* harmony export */ });
/* unused harmony exports PBS_ADAPTER_NAME, PARTITIONS, dep, _filterBidsForAdUnit, filterBidsForAdUnit, setupAdUnitMediaTypes, _partitionBidders, partitionBidders */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./native.js */ "./src/native.js");
/* harmony import */ var _adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./adapters/bidderFactory.js */ "./src/adapters/bidderFactory.js");
/* harmony import */ var _ajax_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./ajax.js */ "./src/ajax.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config.js */ "./src/config.js");
/* harmony import */ var _hook_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hook.js */ "./src/hook.js");
/* harmony import */ var _adUnits_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./adUnits.js */ "./src/adUnits.js");
/* harmony import */ var _refererDetection_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./refererDetection.js */ "./src/refererDetection.js");
/* harmony import */ var _consentHandler_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./consentHandler.js */ "./src/consentHandler.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./events.js */ "./src/events.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./constants.js */ "./src/constants.js");
/* harmony import */ var _utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/perfMetrics.js */ "./src/utils/perfMetrics.js");
/* harmony import */ var _auctionManager_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./auctionManager.js */ "./src/auctionManager.js");
/* harmony import */ var _activities_modules_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./activities/modules.js */ "./src/activities/modules.js");
/* harmony import */ var _activities_rules_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activities/rules.js */ "./src/activities/rules.js");
/* harmony import */ var _activities_activities_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./activities/activities.js */ "./src/activities/activities.js");
/* harmony import */ var _activities_params_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./activities/params.js */ "./src/activities/params.js");
/* harmony import */ var _activities_redactor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./activities/redactor.js */ "./src/activities/redactor.js");
/* harmony import */ var _eventTrackers_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./eventTrackers.js */ "./src/eventTrackers.js");
/** @module adaptermanger */





















const PBS_ADAPTER_NAME = 'pbsBidAdapter';
const PARTITIONS = {
  CLIENT: 'client',
  SERVER: 'server'
};
const dep = {
  isAllowed: _activities_rules_js__WEBPACK_IMPORTED_MODULE_0__.isActivityAllowed,
  redact: _activities_redactor_js__WEBPACK_IMPORTED_MODULE_1__.redactor
};
let adapterManager = {};
let _bidderRegistry = adapterManager.bidderRegistry = {};
let _aliasRegistry = adapterManager.aliasRegistry = {};
let _s2sConfigs = [];
_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('s2sConfig', config => {
  if (config && config.s2sConfig) {
    _s2sConfigs = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.isArray)(config.s2sConfig) ? config.s2sConfig : [config.s2sConfig];
  }
});
var _analyticsRegistry = {};
const activityParams = (0,_activities_params_js__WEBPACK_IMPORTED_MODULE_4__.activityParamsBuilder)(alias => adapterManager.resolveAlias(alias));
function getConfigName(s2sConfig) {
  // According to our docs, "module" bid (stored impressions)
  // have params.configName referring to s2sConfig.name,
  // but for a long while this was checking against s2sConfig.configName.
  // Keep allowing s2sConfig.configName to avoid the breaking change
  return s2sConfig.configName ?? s2sConfig.name;
}
function s2sActivityParams(s2sConfig) {
  return activityParams(_activities_modules_js__WEBPACK_IMPORTED_MODULE_5__.MODULE_TYPE_PREBID, PBS_ADAPTER_NAME, {
    [_activities_params_js__WEBPACK_IMPORTED_MODULE_4__.ACTIVITY_PARAM_S2S_NAME]: getConfigName(s2sConfig)
  });
}

/**
 * @typedef {object} LabelDescriptor
 * @property {boolean} labelAll describes whether or not this object expects all labels to match, or any label to match
 * @property {Array<string>} labels the labels listed on the bidder or adUnit
 * @property {Array<string>} activeLabels the labels specified as being active by requestBids
 */

function getBids(_ref) {
  let {
    bidderCode,
    auctionId,
    bidderRequestId,
    adUnits,
    src,
    metrics
  } = _ref;
  return adUnits.reduce((result, adUnit) => {
    const bids = adUnit.bids.filter(bid => bid.bidder === bidderCode);
    if (bidderCode == null && bids.length === 0 && adUnit.s2sBid != null) {
      bids.push({
        bidder: null
      });
    }
    result.push(bids.reduce((bids, bid) => {
      bid = Object.assign({}, bid, {
        ortb2Imp: (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.mergeDeep)({}, adUnit.ortb2Imp, bid.ortb2Imp)
      }, (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.getDefinedParams)(adUnit, ['nativeParams', 'nativeOrtbRequest', 'mediaType', 'renderer']));
      const mediaTypes = bid.mediaTypes == null ? adUnit.mediaTypes : bid.mediaTypes;
      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.isValidMediaTypes)(mediaTypes)) {
        bid = Object.assign({}, bid, {
          mediaTypes
        });
      } else {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`mediaTypes is not correctly configured for adunit ${adUnit.code}`);
      }
      if (src === 'client') {
        (0,_adUnits_js__WEBPACK_IMPORTED_MODULE_6__.incrementBidderRequestsCounter)(adUnit.code, bidderCode);
      }
      bids.push(Object.assign({}, bid, {
        adUnitCode: adUnit.code,
        transactionId: adUnit.transactionId,
        adUnitId: adUnit.adUnitId,
        sizes: mediaTypes?.banner?.sizes || mediaTypes?.video?.playerSize || [],
        bidId: bid.bid_id || (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.getUniqueIdentifierStr)(),
        bidderRequestId,
        auctionId,
        src,
        metrics,
        auctionsCount: (0,_adUnits_js__WEBPACK_IMPORTED_MODULE_6__.getAuctionsCounter)(adUnit.code),
        bidRequestsCount: (0,_adUnits_js__WEBPACK_IMPORTED_MODULE_6__.getRequestsCounter)(adUnit.code),
        bidderRequestsCount: (0,_adUnits_js__WEBPACK_IMPORTED_MODULE_6__.getBidderRequestsCounter)(adUnit.code, bid.bidder),
        bidderWinsCount: (0,_adUnits_js__WEBPACK_IMPORTED_MODULE_6__.getBidderWinsCounter)(adUnit.code, bid.bidder),
        deferBilling: !!adUnit.deferBilling
      }));
      return bids;
    }, []));
    return result;
  }, []).reduce(_utils_js__WEBPACK_IMPORTED_MODULE_3__.flatten, []).filter(val => val !== '');
}
const hookedGetBids = (0,_hook_js__WEBPACK_IMPORTED_MODULE_7__.hook)('sync', getBids, 'getBids');

/**
 * Filter an adUnit's  bids for building client and/or server requests
 *
 * @param bids an array of bids as defined in an adUnit
 * @param s2sConfig null if the adUnit is being routed to a client adapter; otherwise the s2s adapter's config
 * @returns the subset of `bids` that are pertinent for the given `s2sConfig`
 */
function _filterBidsForAdUnit(bids, s2sConfig) {
  let {
    getS2SBidders = getS2SBidderSet
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (s2sConfig == null) {
    return bids;
  } else {
    const serverBidders = getS2SBidders(s2sConfig);
    return bids.filter(bid => {
      if (!serverBidders.has(bid.bidder)) return false;
      if (bid.s2sConfigName == null) return true;
      const configName = getConfigName(s2sConfig);
      const allowedS2SConfigs = Array.isArray(bid.s2sConfigName) ? bid.s2sConfigName : [bid.s2sConfigName];
      return allowedS2SConfigs.includes(configName);
    });
  }
}
const filterBidsForAdUnit = (0,_hook_js__WEBPACK_IMPORTED_MODULE_7__.hook)('sync', _filterBidsForAdUnit, 'filterBidsForAdUnit');
function getAdUnitCopyForPrebidServer(adUnits, s2sConfig) {
  let adUnitsCopy = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.deepClone)(adUnits);
  let hasModuleBids = false;
  adUnitsCopy.forEach(adUnit => {
    // filter out client side bids
    const s2sBids = adUnit.bids.filter(b => b.module === PBS_ADAPTER_NAME && b.params?.configName === getConfigName(s2sConfig));
    if (s2sBids.length === 1) {
      adUnit.s2sBid = s2sBids[0];
      hasModuleBids = true;
      adUnit.ortb2Imp = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.mergeDeep)({}, adUnit.s2sBid.ortb2Imp, adUnit.ortb2Imp);
    } else if (s2sBids.length > 1) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)('Multiple "module" bids for the same s2s configuration; all will be ignored', s2sBids);
    }
    adUnit.bids = filterBidsForAdUnit(adUnit.bids, s2sConfig).map(bid => {
      bid.bid_id = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.getUniqueIdentifierStr)();
      return bid;
    });
  });

  // don't send empty requests
  adUnitsCopy = adUnitsCopy.filter(adUnit => {
    return adUnit.bids.length !== 0 || adUnit.s2sBid != null;
  });
  return {
    adUnits: adUnitsCopy,
    hasModuleBids
  };
}
function getAdUnitCopyForClientAdapters(adUnits) {
  let adUnitsClientCopy = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.deepClone)(adUnits);
  adUnitsClientCopy.forEach(adUnit => {
    adUnit.bids = filterBidsForAdUnit(adUnit.bids, null);
  });

  // don't send empty requests
  adUnitsClientCopy = adUnitsClientCopy.filter(adUnit => {
    return adUnit.bids.length !== 0;
  });
  return adUnitsClientCopy;
}

/**
 * Filter and/or modify media types for ad units based on the given labels.
 *
 * This should return adUnits that are active for the given labels, modified to have their `mediaTypes`
 * conform to size mapping configuration. If different bids for the same adUnit should use different `mediaTypes`,
 * they should be exposed under `adUnit.bids[].mediaTypes`.
 */
const setupAdUnitMediaTypes = (0,_hook_js__WEBPACK_IMPORTED_MODULE_7__.hook)('sync', (adUnits, labels) => {
  return adUnits;
}, 'setupAdUnitMediaTypes');

/**
 * @param {{}|Array<{}>} s2sConfigs
 * @returns {Set<String>} a set of all the bidder codes that should be routed through the S2S adapter(s)
 *                        as defined in `s2sConfigs`
 */
function getS2SBidderSet(s2sConfigs) {
  if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.isArray)(s2sConfigs)) s2sConfigs = [s2sConfigs];
  // `null` represents the "no bid bidder" - when an ad unit is meant only for S2S adapters, like stored impressions
  const serverBidders = new Set([null]);
  s2sConfigs.filter(s2s => s2s && s2s.enabled).flatMap(s2s => s2s.bidders).forEach(bidder => serverBidders.add(bidder));
  return serverBidders;
}

/**
 * @param {Array} adUnits - The ad units to be processed.
 * @param {Object} s2sConfigs - The server-to-server configurations.
 * @returns {Object} - An object containing arrays of bidder codes for client and server.
 * @returns {Object} return.client - Array of bidder codes that should be routed to client adapters.
 * @returns {Object} return.server - Array of bidder codes that should be routed to server adapters.
 */
function _partitionBidders(adUnits, s2sConfigs) {
  let {
    getS2SBidders = getS2SBidderSet
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const serverBidders = getS2SBidders(s2sConfigs);
  return (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.getBidderCodes)(adUnits).reduce((memo, bidder) => {
    const partition = serverBidders.has(bidder) ? PARTITIONS.SERVER : PARTITIONS.CLIENT;
    memo[partition].push(bidder);
    return memo;
  }, {
    [PARTITIONS.CLIENT]: [],
    [PARTITIONS.SERVER]: []
  });
}
const partitionBidders = (0,_hook_js__WEBPACK_IMPORTED_MODULE_7__.hook)('sync', _partitionBidders, 'partitionBidders');
adapterManager.makeBidRequests = (0,_hook_js__WEBPACK_IMPORTED_MODULE_7__.hook)('sync', function (adUnits, auctionStart, auctionId, cbTimeout, labels) {
  let ortb2Fragments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
  let auctionMetrics = arguments.length > 6 ? arguments[6] : undefined;
  auctionMetrics = (0,_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_8__.useMetrics)(auctionMetrics);
  /**
   * emit and pass adunits for external modification
   * @see {@link https://github.com/prebid/Prebid.js/issues/4149|Issue}
   */
  _events_js__WEBPACK_IMPORTED_MODULE_9__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_10__.EVENTS.BEFORE_REQUEST_BIDS, adUnits);
  if (true) {
    (0,_native_js__WEBPACK_IMPORTED_MODULE_11__.decorateAdUnitsWithNativeParams)(adUnits);
  }
  adUnits.map(adUnit => adUnit.code).filter(_utils_js__WEBPACK_IMPORTED_MODULE_3__.uniques).forEach(_adUnits_js__WEBPACK_IMPORTED_MODULE_6__.incrementAuctionsCounter);
  adUnits.forEach(au => {
    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(au.mediaTypes)) {
      au.mediaTypes = {};
    }
    // filter out bidders that cannot participate in the auction
    au.bids = au.bids.filter(bid => !bid.bidder || dep.isAllowed(_activities_activities_js__WEBPACK_IMPORTED_MODULE_12__.ACTIVITY_FETCH_BIDS, activityParams(_activities_modules_js__WEBPACK_IMPORTED_MODULE_5__.MODULE_TYPE_BIDDER, bid.bidder)));
    (0,_adUnits_js__WEBPACK_IMPORTED_MODULE_6__.incrementRequestsCounter)(au.code);
  });
  adUnits = setupAdUnitMediaTypes(adUnits, labels);
  let {
    [PARTITIONS.CLIENT]: clientBidders,
    [PARTITIONS.SERVER]: serverBidders
  } = partitionBidders(adUnits, _s2sConfigs);
  if (_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('bidderSequence') === _config_js__WEBPACK_IMPORTED_MODULE_2__.RANDOM) {
    clientBidders = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.shuffle)(clientBidders);
  }
  const refererInfo = (0,_refererDetection_js__WEBPACK_IMPORTED_MODULE_13__.getRefererInfo)();
  let bidRequests = [];
  const ortb2 = ortb2Fragments.global || {};
  const bidderOrtb2 = ortb2Fragments.bidder || {};
  function moveUserEidsToExt(o) {
    const eids = o.user?.eids;
    if (Array.isArray(eids) && eids.length) {
      o.user.ext = o.user.ext || {};
      o.user.ext.eids = [...(o.user.ext.eids || []), ...eids];
      delete o.user.eids;
    }
  }
  function addOrtb2(bidderRequest, s2sActivityParams) {
    const redact = dep.redact(s2sActivityParams != null ? s2sActivityParams : activityParams(_activities_modules_js__WEBPACK_IMPORTED_MODULE_5__.MODULE_TYPE_BIDDER, bidderRequest.bidderCode));
    const merged = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.mergeDeep)({
      source: {
        tid: auctionId
      }
    }, ortb2, bidderOrtb2[bidderRequest.bidderCode]);
    moveUserEidsToExt(merged);
    const fpd = Object.freeze(redact.ortb2(merged));
    bidderRequest.ortb2 = fpd;
    bidderRequest.bids = bidderRequest.bids.map(bid => {
      bid.ortb2 = fpd;
      return redact.bidRequest(bid);
    });
    return bidderRequest;
  }
  _s2sConfigs.forEach(s2sConfig => {
    const s2sParams = s2sActivityParams(s2sConfig);
    if (s2sConfig && s2sConfig.enabled && dep.isAllowed(_activities_activities_js__WEBPACK_IMPORTED_MODULE_12__.ACTIVITY_FETCH_BIDS, s2sParams)) {
      let {
        adUnits: adUnitsS2SCopy,
        hasModuleBids
      } = getAdUnitCopyForPrebidServer(adUnits, s2sConfig);

      // uniquePbsTid is so we know which server to send which bids to during the callBids function
      let uniquePbsTid = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.generateUUID)();
      (serverBidders.length === 0 && hasModuleBids ? [null] : serverBidders).forEach(bidderCode => {
        const bidderRequestId = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.getUniqueIdentifierStr)();
        const metrics = auctionMetrics.fork();
        const bidderRequest = addOrtb2({
          bidderCode,
          auctionId,
          bidderRequestId,
          uniquePbsTid,
          bids: hookedGetBids({
            bidderCode,
            auctionId,
            bidderRequestId,
            'adUnits': (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.deepClone)(adUnitsS2SCopy),
            src: _constants_js__WEBPACK_IMPORTED_MODULE_10__.S2S.SRC,
            metrics
          }),
          auctionStart: auctionStart,
          timeout: s2sConfig.timeout,
          src: _constants_js__WEBPACK_IMPORTED_MODULE_10__.S2S.SRC,
          refererInfo,
          metrics
        }, s2sParams);
        if (bidderRequest.bids.length !== 0) {
          bidRequests.push(bidderRequest);
        }
      });

      // update the s2sAdUnits object and remove all bids that didn't pass sizeConfig/label checks from getBids()
      // this is to keep consistency and only allow bids/adunits that passed the checks to go to pbs
      adUnitsS2SCopy.forEach(adUnitCopy => {
        let validBids = adUnitCopy.bids.filter(adUnitBid => bidRequests.find(request => request.bids.find(reqBid => reqBid.bidId === adUnitBid.bid_id)));
        adUnitCopy.bids = validBids;
      });
      bidRequests.forEach(request => {
        if (request.adUnitsS2SCopy === undefined) {
          request.adUnitsS2SCopy = adUnitsS2SCopy.filter(au => au.bids.length > 0 || au.s2sBid != null);
        }
      });
    }
  });

  // client adapters
  let adUnitsClientCopy = getAdUnitCopyForClientAdapters(adUnits);
  clientBidders.forEach(bidderCode => {
    const bidderRequestId = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.getUniqueIdentifierStr)();
    const metrics = auctionMetrics.fork();
    const bidderRequest = addOrtb2({
      bidderCode,
      auctionId,
      bidderRequestId,
      bids: hookedGetBids({
        bidderCode,
        auctionId,
        bidderRequestId,
        'adUnits': (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.deepClone)(adUnitsClientCopy),
        labels,
        src: 'client',
        metrics
      }),
      auctionStart: auctionStart,
      timeout: cbTimeout,
      refererInfo,
      metrics
    });
    const adapter = _bidderRegistry[bidderCode];
    if (!adapter) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`Trying to make a request for bidder that does not exist: ${bidderCode}`);
    }
    if (adapter && bidderRequest.bids && bidderRequest.bids.length !== 0) {
      bidRequests.push(bidderRequest);
    }
  });
  bidRequests.forEach(bidRequest => {
    if (_consentHandler_js__WEBPACK_IMPORTED_MODULE_14__.gdprDataHandler.getConsentData()) {
      bidRequest['gdprConsent'] = _consentHandler_js__WEBPACK_IMPORTED_MODULE_14__.gdprDataHandler.getConsentData();
    }
    if (_consentHandler_js__WEBPACK_IMPORTED_MODULE_14__.uspDataHandler.getConsentData()) {
      bidRequest['uspConsent'] = _consentHandler_js__WEBPACK_IMPORTED_MODULE_14__.uspDataHandler.getConsentData();
    }
    if (_consentHandler_js__WEBPACK_IMPORTED_MODULE_14__.gppDataHandler.getConsentData()) {
      bidRequest['gppConsent'] = _consentHandler_js__WEBPACK_IMPORTED_MODULE_14__.gppDataHandler.getConsentData();
    }
  });
  return bidRequests;
}, 'makeBidRequests');
adapterManager.callBids = function (adUnits, bidRequests, addBidResponse, doneCb, requestCallbacks, requestBidsTimeout, onTimelyResponse) {
  let ortb2Fragments = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
  if (!bidRequests.length) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)('callBids executed with no bidRequests.  Were they filtered by labels or sizing?');
    return;
  }
  let [clientBidderRequests, serverBidderRequests] = bidRequests.reduce((partitions, bidRequest) => {
    partitions[Number(typeof bidRequest.src !== 'undefined' && bidRequest.src === _constants_js__WEBPACK_IMPORTED_MODULE_10__.S2S.SRC)].push(bidRequest);
    return partitions;
  }, [[], []]);
  var uniqueServerBidRequests = [];
  serverBidderRequests.forEach(serverBidRequest => {
    var index = -1;
    for (var i = 0; i < uniqueServerBidRequests.length; ++i) {
      if (serverBidRequest.uniquePbsTid === uniqueServerBidRequests[i].uniquePbsTid) {
        index = i;
        break;
      }
    }
    if (index <= -1) {
      uniqueServerBidRequests.push(serverBidRequest);
    }
  });
  let counter = 0;
  _s2sConfigs.forEach(s2sConfig => {
    if (s2sConfig && uniqueServerBidRequests[counter] && getS2SBidderSet(s2sConfig).has(uniqueServerBidRequests[counter].bidderCode)) {
      // s2s should get the same client side timeout as other client side requests.
      const s2sAjax = (0,_ajax_js__WEBPACK_IMPORTED_MODULE_15__.ajaxBuilder)(requestBidsTimeout, requestCallbacks ? {
        request: requestCallbacks.request.bind(null, 's2s'),
        done: requestCallbacks.done
      } : undefined);
      let adaptersServerSide = s2sConfig.bidders;
      const s2sAdapter = _bidderRegistry[s2sConfig.adapter];
      let uniquePbsTid = uniqueServerBidRequests[counter].uniquePbsTid;
      let adUnitsS2SCopy = uniqueServerBidRequests[counter].adUnitsS2SCopy;
      let uniqueServerRequests = serverBidderRequests.filter(serverBidRequest => serverBidRequest.uniquePbsTid === uniquePbsTid);
      if (s2sAdapter) {
        let s2sBidRequest = {
          'ad_units': adUnitsS2SCopy,
          s2sConfig,
          ortb2Fragments,
          requestBidsTimeout
        };
        if (s2sBidRequest.ad_units.length) {
          let doneCbs = uniqueServerRequests.map(bidRequest => {
            bidRequest.start = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.timestamp)();
            return function (timedOut) {
              if (!timedOut) {
                onTimelyResponse(bidRequest.bidderRequestId);
              }
              doneCb.apply(bidRequest, arguments);
            };
          });
          const bidders = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.getBidderCodes)(s2sBidRequest.ad_units).filter(bidder => adaptersServerSide.includes(bidder));
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logMessage)(`CALLING S2S HEADER BIDDERS ==== ${bidders.length > 0 ? bidders.join(', ') : 'No bidder specified, using "ortb2Imp" definition(s) only'}`);

          // fire BID_REQUESTED event for each s2s bidRequest
          uniqueServerRequests.forEach(bidRequest => {
            // add the new sourceTid
            _events_js__WEBPACK_IMPORTED_MODULE_9__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_10__.EVENTS.BID_REQUESTED, {
              ...bidRequest,
              tid: bidRequest.auctionId
            });
          });

          // make bid requests
          s2sAdapter.callBids(s2sBidRequest, serverBidderRequests, addBidResponse, timedOut => doneCbs.forEach(done => done(timedOut)), s2sAjax);
        }
      } else {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)('missing ' + s2sConfig.adapter);
      }
      counter++;
    }
  });

  // handle client adapter requests
  clientBidderRequests.forEach(bidderRequest => {
    bidderRequest.start = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.timestamp)();
    // TODO : Do we check for bid in pool from here and skip calling adapter again ?
    const adapter = _bidderRegistry[bidderRequest.bidderCode];
    _config_js__WEBPACK_IMPORTED_MODULE_2__.config.runWithBidder(bidderRequest.bidderCode, () => {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logMessage)(`CALLING BIDDER`);
      _events_js__WEBPACK_IMPORTED_MODULE_9__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_10__.EVENTS.BID_REQUESTED, bidderRequest);
    });
    let ajax = (0,_ajax_js__WEBPACK_IMPORTED_MODULE_15__.ajaxBuilder)(requestBidsTimeout, requestCallbacks ? {
      request: requestCallbacks.request.bind(null, bidderRequest.bidderCode),
      done: requestCallbacks.done
    } : undefined);
    const adapterDone = doneCb.bind(bidderRequest);
    try {
      _config_js__WEBPACK_IMPORTED_MODULE_2__.config.runWithBidder(bidderRequest.bidderCode, adapter.callBids.bind(adapter, bidderRequest, addBidResponse, adapterDone, ajax, () => onTimelyResponse(bidderRequest.bidderRequestId), _config_js__WEBPACK_IMPORTED_MODULE_2__.config.callbackWithBidder(bidderRequest.bidderCode)));
    } catch (e) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`${bidderRequest.bidderCode} Bid Adapter emitted an uncaught error when parsing their bidRequest`, {
        e,
        bidRequest: bidderRequest
      });
      adapterDone();
    }
  });
};
function getSupportedMediaTypes(bidderCode) {
  let supportedMediaTypes = [];
  if ( true && adapterManager.videoAdapters.includes(bidderCode)) supportedMediaTypes.push('video');
  if ( true && _native_js__WEBPACK_IMPORTED_MODULE_11__.nativeAdapters.includes(bidderCode)) supportedMediaTypes.push('native');
  return supportedMediaTypes;
}
adapterManager.videoAdapters = []; // added by adapterLoader for now

adapterManager.registerBidAdapter = function (bidAdapter, bidderCode) {
  let {
    supportedMediaTypes = []
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (bidAdapter && bidderCode) {
    if (typeof bidAdapter.callBids === 'function') {
      _bidderRegistry[bidderCode] = bidAdapter;
      _consentHandler_js__WEBPACK_IMPORTED_MODULE_14__.GDPR_GVLIDS.register(_activities_modules_js__WEBPACK_IMPORTED_MODULE_5__.MODULE_TYPE_BIDDER, bidderCode, bidAdapter.getSpec?.().gvlid);
      if ( true && supportedMediaTypes.includes('video')) {
        adapterManager.videoAdapters.push(bidderCode);
      }
      if ( true && supportedMediaTypes.includes('native')) {
        _native_js__WEBPACK_IMPORTED_MODULE_11__.nativeAdapters.push(bidderCode);
      }
    } else {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)('Bidder adaptor error for bidder code: ' + bidderCode + 'bidder must implement a callBids() function');
    }
  } else {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)('bidAdapter or bidderCode not specified');
  }
};
adapterManager.aliasBidAdapter = function (bidderCode, alias, options) {
  let existingAlias = _bidderRegistry[alias];
  if (typeof existingAlias === 'undefined') {
    let bidAdapter = _bidderRegistry[bidderCode];
    if (typeof bidAdapter === 'undefined') {
      // check if alias is part of s2sConfig and allow them to register if so (as base bidder may be s2s-only)
      const nonS2SAlias = [];
      _s2sConfigs.forEach(s2sConfig => {
        if (s2sConfig.bidders && s2sConfig.bidders.length) {
          const s2sBidders = s2sConfig && s2sConfig.bidders;
          if (!(s2sConfig && s2sBidders.includes(alias))) {
            nonS2SAlias.push(bidderCode);
          } else {
            _aliasRegistry[alias] = bidderCode;
          }
        }
      });
      nonS2SAlias.forEach(bidderCode => {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)('bidderCode "' + bidderCode + '" is not an existing bidder.', 'adapterManager.aliasBidAdapter');
      });
    } else {
      try {
        let newAdapter;
        let supportedMediaTypes = getSupportedMediaTypes(bidderCode);
        // Have kept old code to support backward compatibilitiy.
        // Remove this if loop when all adapters are supporting bidderFactory. i.e When Prebid.js is 1.0
        if (bidAdapter.constructor.prototype != Object.prototype) {
          newAdapter = new bidAdapter.constructor();
          newAdapter.setBidderCode(alias);
        } else {
          const {
            useBaseGvlid = false
          } = options || {};
          let spec = bidAdapter.getSpec();
          const gvlid = useBaseGvlid ? spec.gvlid : options?.gvlid;
          if (gvlid == null && spec.gvlid != null) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(`Alias '${alias}' will NOT re-use the GVL ID of the original adapter ('${spec.code}', gvlid: ${spec.gvlid}). Functionality that requires TCF consent may not work as expected.`);
          }
          let skipPbsAliasing = options && options.skipPbsAliasing;
          newAdapter = (0,_adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_16__.newBidder)(Object.assign({}, spec, {
            code: alias,
            gvlid,
            skipPbsAliasing
          }));
          _aliasRegistry[alias] = bidderCode;
        }
        adapterManager.registerBidAdapter(newAdapter, alias, {
          supportedMediaTypes
        });
      } catch (e) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(bidderCode + ' bidder does not currently support aliasing.', 'adapterManager.aliasBidAdapter');
      }
    }
  } else {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logMessage)('alias name "' + alias + '" has been already specified.');
  }
};
adapterManager.resolveAlias = function (alias) {
  let code = alias;
  let visited;
  while (_aliasRegistry[code] && (!visited || !visited.has(code))) {
    code = _aliasRegistry[code];
    (visited = visited || new Set()).add(code);
  }
  return code;
};
adapterManager.registerAnalyticsAdapter = function (_ref2) {
  let {
    adapter,
    code,
    gvlid
  } = _ref2;
  if (adapter && code) {
    if (typeof adapter.enableAnalytics === 'function') {
      adapter.code = code;
      _analyticsRegistry[code] = {
        adapter,
        gvlid
      };
      _consentHandler_js__WEBPACK_IMPORTED_MODULE_14__.GDPR_GVLIDS.register(_activities_modules_js__WEBPACK_IMPORTED_MODULE_5__.MODULE_TYPE_ANALYTICS, code, gvlid);
    } else {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`Prebid Error: Analytics adaptor error for analytics "${code}"
        analytics adapter must implement an enableAnalytics() function`);
    }
  } else {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)('Prebid Error: analyticsAdapter or analyticsCode not specified');
  }
};
adapterManager.enableAnalytics = function (config) {
  if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.isArray)(config)) {
    config = [config];
  }
  config.forEach(adapterConfig => {
    const entry = _analyticsRegistry[adapterConfig.provider];
    if (entry && entry.adapter) {
      if (dep.isAllowed(_activities_activities_js__WEBPACK_IMPORTED_MODULE_12__.ACTIVITY_REPORT_ANALYTICS, activityParams(_activities_modules_js__WEBPACK_IMPORTED_MODULE_5__.MODULE_TYPE_ANALYTICS, adapterConfig.provider, {
        [_activities_params_js__WEBPACK_IMPORTED_MODULE_4__.ACTIVITY_PARAM_ANL_CONFIG]: adapterConfig
      }))) {
        entry.adapter.enableAnalytics(adapterConfig);
      }
    } else {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`Prebid Error: no analytics adapter found in registry for '${adapterConfig.provider}'.`);
    }
  });
};
adapterManager.getBidAdapter = function (bidder) {
  return _bidderRegistry[bidder];
};
adapterManager.getAnalyticsAdapter = function (code) {
  return _analyticsRegistry[code];
};
function getBidderMethod(bidder, method) {
  const adapter = _bidderRegistry[bidder];
  const spec = adapter?.getSpec && adapter.getSpec();
  if (spec && spec[method] && typeof spec[method] === 'function') {
    return [spec, spec[method]];
  }
}
function invokeBidderMethod(bidder, method, spec, fn) {
  try {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logInfo)(`Invoking ${bidder}.${method}`);
    for (var _len = arguments.length, params = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
      params[_key - 4] = arguments[_key];
    }
    _config_js__WEBPACK_IMPORTED_MODULE_2__.config.runWithBidder(bidder, fn.bind(spec, ...params));
  } catch (e) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(`Error calling ${method} of ${bidder}`);
  }
}
function tryCallBidderMethod(bidder, method, param) {
  if (param?.source !== _constants_js__WEBPACK_IMPORTED_MODULE_10__.S2S.SRC) {
    const target = getBidderMethod(bidder, method);
    if (target != null) {
      invokeBidderMethod(bidder, method, ...target, param);
    }
  }
}
adapterManager.callTimedOutBidders = function (adUnits, timedOutBidders, cbTimeout) {
  timedOutBidders = timedOutBidders.map(timedOutBidder => {
    // Adding user configured params & timeout to timeout event data
    timedOutBidder.params = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.getUserConfiguredParams)(adUnits, timedOutBidder.adUnitCode, timedOutBidder.bidder);
    timedOutBidder.timeout = cbTimeout;
    return timedOutBidder;
  });
  timedOutBidders = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.groupBy)(timedOutBidders, 'bidder');
  Object.keys(timedOutBidders).forEach(bidder => {
    tryCallBidderMethod(bidder, 'onTimeout', timedOutBidders[bidder]);
  });
};
adapterManager.callBidWonBidder = function (bidder, bid, adUnits) {
  // Adding user configured params to bidWon event data
  bid.params = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.getUserConfiguredParams)(adUnits, bid.adUnitCode, bid.bidder);
  (0,_adUnits_js__WEBPACK_IMPORTED_MODULE_6__.incrementBidderWinsCounter)(bid.adUnitCode, bid.bidder);
  tryCallBidderMethod(bidder, 'onBidWon', bid);
};
adapterManager.triggerBilling = (() => {
  const BILLED = new WeakSet();
  return bid => {
    if (!BILLED.has(bid)) {
      BILLED.add(bid);
      ((0,_eventTrackers_js__WEBPACK_IMPORTED_MODULE_17__.parseEventTrackers)(bid.eventtrackers)[_eventTrackers_js__WEBPACK_IMPORTED_MODULE_17__.EVENT_TYPE_IMPRESSION]?.[_eventTrackers_js__WEBPACK_IMPORTED_MODULE_17__.TRACKER_METHOD_IMG] || []).forEach(url => _utils_js__WEBPACK_IMPORTED_MODULE_3__.internal.triggerPixel(url));
      tryCallBidderMethod(bid.bidder, 'onBidBillable', bid);
    }
  };
})();
adapterManager.callSetTargetingBidder = function (bidder, bid) {
  tryCallBidderMethod(bidder, 'onSetTargeting', bid);
};
adapterManager.callBidViewableBidder = function (bidder, bid) {
  tryCallBidderMethod(bidder, 'onBidViewable', bid);
};
adapterManager.callBidderError = function (bidder, error, bidderRequest) {
  const param = {
    error,
    bidderRequest
  };
  tryCallBidderMethod(bidder, 'onBidderError', param);
};
adapterManager.callAdRenderSucceededBidder = function (bidder, bid) {
  tryCallBidderMethod(bidder, 'onAdRenderSucceeded', bid);
};
function resolveAlias(alias) {
  const seen = new Set();
  while (_aliasRegistry.hasOwnProperty(alias) && !seen.has(alias)) {
    seen.add(alias);
    alias = _aliasRegistry[alias];
  }
  return alias;
}
/**
 * Ask every adapter to delete PII.
 * See https://github.com/prebid/Prebid.js/issues/9081
 */
adapterManager.callDataDeletionRequest = (0,_hook_js__WEBPACK_IMPORTED_MODULE_7__.hook)('sync', function () {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  const method = 'onDataDeletionRequest';
  Object.keys(_bidderRegistry).filter(bidder => !_aliasRegistry.hasOwnProperty(bidder)).forEach(bidder => {
    const target = getBidderMethod(bidder, method);
    if (target != null) {
      const bidderRequests = _auctionManager_js__WEBPACK_IMPORTED_MODULE_18__.auctionManager.getBidsRequested().filter(br => resolveAlias(br.bidderCode) === bidder);
      invokeBidderMethod(bidder, method, ...target, bidderRequests, ...args);
    }
  });
  Object.entries(_analyticsRegistry).forEach(_ref3 => {
    let [name, entry] = _ref3;
    const fn = entry?.adapter?.[method];
    if (typeof fn === 'function') {
      try {
        fn.apply(entry.adapter, args);
      } catch (e) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`error calling ${method} of ${name}`, e);
      }
    }
  });
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (adapterManager);

/***/ }),

/***/ "./src/adapters/bidderFactory.js":
/*!***************************************!*\
  !*** ./src/adapters/bidderFactory.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   adapterMetrics: () => (/* binding */ adapterMetrics),
/* harmony export */   addPaapiConfig: () => (/* binding */ addPaapiConfig),
/* harmony export */   guardTids: () => (/* binding */ guardTids),
/* harmony export */   isValid: () => (/* binding */ isValid),
/* harmony export */   newBidder: () => (/* binding */ newBidder),
/* harmony export */   registerBidder: () => (/* binding */ registerBidder)
/* harmony export */ });
/* unused harmony exports processBidderRequests, registerSyncInner */
/* harmony import */ var _adapter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../adapter.js */ "./src/adapter.js");
/* harmony import */ var _adapterManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../adapterManager.js */ "./src/adapterManager.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../config.js */ "./src/config.js");
/* harmony import */ var _bidfactory_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../bidfactory.js */ "./src/bidfactory.js");
/* harmony import */ var _userSync_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../userSync.js */ "./src/userSync.js");
/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../native.js */ "./src/native.js");
/* harmony import */ var _video_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../video.js */ "./src/video.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../constants.js */ "./src/constants.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../events.js */ "./src/events.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./src/utils.js");
/* harmony import */ var _hook_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../hook.js */ "./src/hook.js");
/* harmony import */ var _auctionManager_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../auctionManager.js */ "./src/auctionManager.js");
/* harmony import */ var _bidderSettings_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../bidderSettings.js */ "./src/bidderSettings.js");
/* harmony import */ var _utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/perfMetrics.js */ "./src/utils/perfMetrics.js");
/* harmony import */ var _activities_rules_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../activities/rules.js */ "./src/activities/rules.js");
/* harmony import */ var _activities_activityParams_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../activities/activityParams.js */ "./src/activities/activityParams.js");
/* harmony import */ var _activities_modules_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../activities/modules.js */ "./src/activities/modules.js");
/* harmony import */ var _activities_activities_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../activities/activities.js */ "./src/activities/activities.js");



















/**
 * @typedef {import('../mediaTypes.js').MediaType} MediaType
 * @typedef {import('../Renderer.js').Renderer} Renderer
 */

/**
 * This file aims to support Adapters during the Prebid 0.x -> 1.x transition.
 *
 * Prebid 1.x and Prebid 0.x will be in separate branches--perhaps for a long time.
 * This function defines an API for adapter construction which is compatible with both versions.
 * Adapters which use it can maintain their code in master, and only this file will need to change
 * in the 1.x branch.
 *
 * Typical usage looks something like:
 *
 * const adapter = registerBidder({
 *   code: 'myBidderCode',
 *   aliases: ['alias1', 'alias2'],
 *   supportedMediaTypes: ['video', 'native'],
 *   isBidRequestValid: function(paramsObject) { return true/false },
 *   buildRequests: function(bidRequests, bidderRequest) { return some ServerRequest(s) },
 *   interpretResponse: function(oneServerResponse) { return some Bids, or throw an error. }
 * });
 *
 * @see BidderSpec for the full API and more thorough descriptions.
 *
 */

/**
 * @typedef {object} BidderSpec An object containing the adapter-specific functions needed to
 * make a Bidder.
 *
 * @property {string} code A code which will be used to uniquely identify this bidder. This should be the same
 *   one as is used in the call to registerBidAdapter
 * @property {string[]} [aliases] A list of aliases which should also resolve to this bidder.
 * @property {MediaType[]} [supportedMediaTypes] A list of Media Types which the adapter supports.
 * @property {function(object): boolean} isBidRequestValid Determines whether or not the given bid has all the params
 *   needed to make a valid request.
 * @property {function(BidRequest[], bidderRequest): ServerRequest|ServerRequest[]} buildRequests Build the request to the Server
 *   which requests Bids for the given array of Requests. Each BidRequest in the argument array is guaranteed to have
 *   passed the isBidRequestValid() test.
 * @property {function(ServerResponse, BidRequest): Bid[]} interpretResponse Given a successful response from the Server,
 *   interpret it and return the Bid objects. This function will be run inside a try/catch.
 *   If it throws any errors, your bids will be discarded.
 * @property {function(SyncOptions, ServerResponse[]): UserSync[]} [getUserSyncs] Given an array of all the responses
 *   from the server, determine which user syncs should occur. The argument array will contain every element
 *   which has been sent through to interpretResponse. The order of syncs in this array matters. The most
 *   important ones should come first, since publishers may limit how many are dropped on their page.
 * @property {function(object): object} transformBidParams Updates bid params before creating bid request
 }}
 */

/**
 * @typedef {object} BidRequest
 *
 * @property {string} bidId A string which uniquely identifies this BidRequest in the current Auction.
 * @property {object} params Any bidder-specific params which the publisher used in their bid request.
 */

/**
 * @typedef {object} BidderAuctionResponse An object encapsulating an adapter response for current Auction
 *
 * @property {Array<Bid>} bids? Contextual bids returned by this adapter, if any
 * @property {Array<{bidId: String, config: {}}>} paapiAuctionConfigs? Array of paapi auction configs, each scoped to a particular bidId
 */

/**
 * @typedef {object} ServerRequest
 *
 * @property {('GET'|'POST')} method The type of request which this is.
 * @property {string} url The endpoint for the request. For example, "//bids.example.com".
 * @property {string|object} data Data to be sent in the request.
 * @property {object} options Content-Type set in the header of the bid request, overrides default 'text/plain'.
 *   If this is a GET request, they'll become query params. If it's a POST request, they'll be added to the body.
 *   Strings will be added as-is. Objects will be unpacked into query params based on key/value mappings, or
 *   JSON-serialized into the Request body.
 */

/**
 * @typedef {object} ServerResponse
 *
 * @property {*} body The response body. If this is legal JSON, then it will be parsed. Otherwise it'll be a
 *   string with the body's content.
 * @property {{get: function(string): string}} headers The response headers.
 *   Call this like `ServerResponse.headers.get("Content-Type")`
 */

/**
 * @typedef {object} Bid
 *
 * @property {string} requestId The specific BidRequest which this bid is aimed at.
 *   This should match the BidRequest.bidId which this Bid targets.
 * @property {string} ad A URL which can be used to load this ad, if it's chosen by the publisher.
 * @property {string} currency The currency code for the cpm value
 * @property {number} cpm The bid price, in US cents per thousand impressions.
 * @property {number} ttl Time-to-live - how long (in seconds) Prebid can use this bid.
 * @property {boolean} netRevenue Boolean defining whether the bid is Net or Gross.  The default is true (Net).
 * @property {number} height The height of the ad, in pixels.
 * @property {number} width The width of the ad, in pixels.
 *
 * @property {object} [native] Object for storing native creative assets
 * @property {object} [video] Object for storing video response data
 * @property {object} [meta] Object for storing bid meta data
 * @property {string} [meta.primaryCatId] The IAB primary category ID
 * @property {Renderer} renderer A Renderer which can be used as a default for this bid,
 *   if the publisher doesn't override it. This is only relevant for Outstream Video bids.
 */

/**
 * @typedef {Object} SyncOptions
 *
 * An object containing information about usersyncs which the adapter should obey.
 *
 * @property {boolean} iframeEnabled True if iframe usersyncs are allowed, and false otherwise
 * @property {boolean} pixelEnabled True if image usersyncs are allowed, and false otherwise
 */

/**
 * TODO: Move this to the UserSync module after that PR is merged.
 *
 * @typedef {object} UserSync
 *
 * @property {('image'|'iframe')} type The type of user sync to be done.
 * @property {string} url The URL which makes the sync happen.
 */

// common params for all mediaTypes
const COMMON_BID_RESPONSE_KEYS = ['cpm', 'ttl', 'creativeId', 'netRevenue', 'currency'];
const TIDS = ['auctionId', 'transactionId'];

/**
 * Register a bidder with prebid, using the given spec.
 *
 * If possible, Adapter modules should use this function instead of adapterManager.registerBidAdapter().
 *
 * @param {BidderSpec} spec An object containing the bare-bones functions we need to make a Bidder.
 */
function registerBidder(spec) {
  const mediaTypes = Array.isArray(spec.supportedMediaTypes) ? {
    supportedMediaTypes: spec.supportedMediaTypes
  } : undefined;
  function putBidder(spec) {
    const bidder = newBidder(spec);
    _adapterManager_js__WEBPACK_IMPORTED_MODULE_0__["default"].registerBidAdapter(bidder, spec.code, mediaTypes);
  }
  putBidder(spec);
  if (Array.isArray(spec.aliases)) {
    spec.aliases.forEach(alias => {
      let aliasCode = alias;
      let gvlid;
      let skipPbsAliasing;
      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(alias)) {
        aliasCode = alias.code;
        gvlid = alias.gvlid;
        skipPbsAliasing = alias.skipPbsAliasing;
      }
      _adapterManager_js__WEBPACK_IMPORTED_MODULE_0__["default"].aliasRegistry[aliasCode] = spec.code;
      putBidder(Object.assign({}, spec, {
        code: aliasCode,
        gvlid,
        skipPbsAliasing
      }));
    });
  }
}
const guardTids = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.memoize)(_ref => {
  let {
    bidderCode
  } = _ref;
  if ((0,_activities_rules_js__WEBPACK_IMPORTED_MODULE_2__.isActivityAllowed)(_activities_activities_js__WEBPACK_IMPORTED_MODULE_3__.ACTIVITY_TRANSMIT_TID, (0,_activities_activityParams_js__WEBPACK_IMPORTED_MODULE_4__.activityParams)(_activities_modules_js__WEBPACK_IMPORTED_MODULE_5__.MODULE_TYPE_BIDDER, bidderCode))) {
    return {
      bidRequest: br => br,
      bidderRequest: br => br
    };
  }
  function get(target, prop, receiver) {
    if (TIDS.includes(prop)) {
      return null;
    }
    return Reflect.get(target, prop, receiver);
  }
  function privateAccessProxy(target, handler) {
    const proxy = new Proxy(target, handler);
    // always allow methods (such as getFloor) private access to TIDs
    Object.entries(target).filter(_ref2 => {
      let [_, v] = _ref2;
      return typeof v === 'function';
    }).forEach(_ref3 => {
      let [prop, fn] = _ref3;
      return proxy[prop] = fn.bind(target);
    });
    return proxy;
  }
  const bidRequest = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.memoize)(br => privateAccessProxy(br, {
    get
  }), arg => arg.bidId);
  /**
   * Return a view on bidd(er) requests where auctionId/transactionId are nulled if the bidder is not allowed `transmitTid`.
   *
   * Because both auctionId and transactionId are used for Prebid's own internal bookkeeping, we cannot simply erase them
   * from request objects; and because request objects are quite complex and not easily cloneable, we hide the IDs
   * with a proxy instead. This should be used only around the adapter logic.
   */
  return {
    bidRequest,
    bidderRequest: br => privateAccessProxy(br, {
      get(target, prop, receiver) {
        if (prop === 'bids') return br.bids.map(bidRequest);
        return get(target, prop, receiver);
      }
    })
  };
});

/**
 * Make a new bidder from the given spec. This is exported mainly for testing.
 * Adapters will probably find it more convenient to use registerBidder instead.
 *
 * @param {BidderSpec} spec
 */
function newBidder(spec) {
  return Object.assign(new _adapter_js__WEBPACK_IMPORTED_MODULE_6__["default"](spec.code), {
    getSpec: function () {
      return Object.freeze(Object.assign({}, spec));
    },
    registerSyncs,
    callBids: function (bidderRequest, addBidResponse, done, ajax, onTimelyResponse, configEnabledCallback) {
      if (!Array.isArray(bidderRequest.bids)) {
        return;
      }
      const tidGuard = guardTids(bidderRequest);
      const adUnitCodesHandled = {};
      function addBidWithCode(adUnitCode, bid) {
        const metrics = (0,_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_7__.useMetrics)(bid.metrics);
        metrics.checkpoint('addBidResponse');
        adUnitCodesHandled[adUnitCode] = true;
        if (metrics.measureTime('addBidResponse.validate', () => isValid(adUnitCode, bid))) {
          addBidResponse(adUnitCode, bid);
        } else {
          addBidResponse.reject(adUnitCode, bid, _constants_js__WEBPACK_IMPORTED_MODULE_8__.REJECTION_REASON.INVALID);
        }
      }

      // After all the responses have come back, call done() and
      // register any required usersync pixels.
      const responses = [];
      function afterAllResponses() {
        done();
        _config_js__WEBPACK_IMPORTED_MODULE_9__.config.runWithBidder(spec.code, () => {
          _events_js__WEBPACK_IMPORTED_MODULE_10__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_8__.EVENTS.BIDDER_DONE, bidderRequest);
          registerSyncs(responses, bidderRequest.gdprConsent, bidderRequest.uspConsent, bidderRequest.gppConsent);
        });
      }
      const validBidRequests = adapterMetrics(bidderRequest).measureTime('validate', () => bidderRequest.bids.filter(br => filterAndWarn(tidGuard.bidRequest(br))));
      if (validBidRequests.length === 0) {
        afterAllResponses();
        return;
      }
      const bidRequestMap = {};
      validBidRequests.forEach(bid => {
        bidRequestMap[bid.bidId] = bid;
        // Delete this once we are 1.0
        if (!bid.adUnitCode) {
          bid.adUnitCode = bid.placementCode;
        }
      });
      processBidderRequests(spec, validBidRequests, bidderRequest, ajax, configEnabledCallback, {
        onRequest: requestObject => _events_js__WEBPACK_IMPORTED_MODULE_10__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_8__.EVENTS.BEFORE_BIDDER_HTTP, bidderRequest, requestObject),
        onResponse: resp => {
          onTimelyResponse(spec.code);
          responses.push(resp);
        },
        onPaapi: paapiConfig => {
          const bidRequest = bidRequestMap[paapiConfig.bidId];
          if (bidRequest) {
            addPaapiConfig(bidRequest, paapiConfig);
          } else {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)('Received fledge auction configuration for an unknown bidId', paapiConfig);
          }
        },
        // If the server responds with an error, there's not much we can do beside logging.
        onError: (errorMessage, error) => {
          if (!error.timedOut) {
            onTimelyResponse(spec.code);
          }
          _adapterManager_js__WEBPACK_IMPORTED_MODULE_0__["default"].callBidderError(spec.code, error, bidderRequest);
          _events_js__WEBPACK_IMPORTED_MODULE_10__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_8__.EVENTS.BIDDER_ERROR, {
            error,
            bidderRequest
          });
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`Server call for ${spec.code} failed: ${errorMessage} ${error.status}. Continuing without bids.`, {
            bidRequests: validBidRequests
          });
        },
        onBid: bid => {
          const bidRequest = bidRequestMap[bid.requestId];
          if (bidRequest) {
            bid.adapterCode = bidRequest.bidder;
            if (isInvalidAlternateBidder(bid.bidderCode, bidRequest.bidder)) {
              (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`${bid.bidderCode} is not a registered partner or known bidder of ${bidRequest.bidder}, hence continuing without bid. If you wish to support this bidder, please mark allowAlternateBidderCodes as true in bidderSettings.`);
              addBidResponse.reject(bidRequest.adUnitCode, bid, _constants_js__WEBPACK_IMPORTED_MODULE_8__.REJECTION_REASON.BIDDER_DISALLOWED);
              return;
            }
            // creating a copy of original values as cpm and currency are modified later
            bid.originalCpm = bid.cpm;
            bid.originalCurrency = bid.currency;
            bid.meta = bid.meta || Object.assign({}, bid[bidRequest.bidder]);
            bid.deferBilling = bidRequest.deferBilling;
            bid.deferRendering = bid.deferBilling && (bid.deferRendering ?? typeof spec.onBidBillable !== 'function');
            const prebidBid = Object.assign((0,_bidfactory_js__WEBPACK_IMPORTED_MODULE_11__.createBid)(_constants_js__WEBPACK_IMPORTED_MODULE_8__.STATUS.GOOD, bidRequest), bid, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.pick)(bidRequest, TIDS));
            addBidWithCode(bidRequest.adUnitCode, prebidBid);
          } else {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Bidder ${spec.code} made bid for unknown request ID: ${bid.requestId}. Ignoring.`);
            addBidResponse.reject(null, bid, _constants_js__WEBPACK_IMPORTED_MODULE_8__.REJECTION_REASON.INVALID_REQUEST_ID);
          }
        },
        onCompletion: afterAllResponses
      });
    }
  });
  function isInvalidAlternateBidder(responseBidder, requestBidder) {
    let allowAlternateBidderCodes = _bidderSettings_js__WEBPACK_IMPORTED_MODULE_12__.bidderSettings.get(requestBidder, 'allowAlternateBidderCodes') || false;
    let alternateBiddersList = _bidderSettings_js__WEBPACK_IMPORTED_MODULE_12__.bidderSettings.get(requestBidder, 'allowedAlternateBidderCodes');
    if (!!responseBidder && !!requestBidder && requestBidder !== responseBidder) {
      alternateBiddersList = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(alternateBiddersList) ? alternateBiddersList.map(val => val.trim().toLowerCase()).filter(val => !!val).filter(_utils_js__WEBPACK_IMPORTED_MODULE_1__.uniques) : alternateBiddersList;
      if (!allowAlternateBidderCodes || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(alternateBiddersList) && alternateBiddersList[0] !== '*' && !alternateBiddersList.includes(responseBidder)) {
        return true;
      }
    }
    return false;
  }
  function registerSyncs(responses, gdprConsent, uspConsent, gppConsent) {
    registerSyncInner(spec, responses, gdprConsent, uspConsent, gppConsent);
  }
  function filterAndWarn(bid) {
    if (!spec.isBidRequestValid(bid)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Invalid bid sent to bidder ${spec.code}: ${JSON.stringify(bid)}`);
      return false;
    }
    return true;
  }
}
const RESPONSE_PROPS = ['bids', 'paapi'];

/**
 * Run a set of bid requests - that entails converting them to HTTP requests, sending
 * them over the network, and parsing the responses.
 *
 * @param spec bid adapter spec
 * @param bids bid requests to run
 * @param bidderRequest the bid request object that `bids` is connected to
 * @param ajax ajax method to use
 * @param wrapCallback {function(callback)} a function used to wrap every callback (for the purpose of `config.currentBidder`)
 * @param onRequest {function({})} invoked once for each HTTP request built by the adapter - with the raw request
 * @param onResponse {function({})} invoked once on each successful HTTP response - with the raw response
 * @param onError {function(String, {})} invoked once for each HTTP error - with status code and response
 * @param onBid {function({})} invoked once for each bid in the response - with the bid as returned by interpretResponse
 * @param onCompletion {function()} invoked once when all bid requests have been processed
 */
const processBidderRequests = (0,_hook_js__WEBPACK_IMPORTED_MODULE_13__.hook)('async', function (spec, bids, bidderRequest, ajax, wrapCallback, _ref4) {
  let {
    onRequest,
    onResponse,
    onPaapi,
    onError,
    onBid,
    onCompletion
  } = _ref4;
  const metrics = adapterMetrics(bidderRequest);
  onCompletion = metrics.startTiming('total').stopBefore(onCompletion);
  const tidGuard = guardTids(bidderRequest);
  let requests = metrics.measureTime('buildRequests', () => spec.buildRequests(bids.map(tidGuard.bidRequest), tidGuard.bidderRequest(bidderRequest)));
  if (!requests || requests.length === 0) {
    onCompletion();
    return;
  }
  if (!Array.isArray(requests)) {
    requests = [requests];
  }
  const requestDone = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.delayExecution)(onCompletion, requests.length);
  requests.forEach(request => {
    const requestMetrics = metrics.fork();
    function addBid(bid) {
      if (bid != null) bid.metrics = requestMetrics.fork().renameWith();
      onBid(bid);
    }
    // If the server responds successfully, use the adapter code to unpack the Bids from it.
    // If the adapter code fails, no bids should be added. After all the bids have been added,
    // make sure to call the `requestDone` function so that we're one step closer to calling onCompletion().
    const onSuccess = wrapCallback(function (response, responseObj) {
      networkDone();
      try {
        response = JSON.parse(response);
      } catch (e) {/* response might not be JSON... that's ok. */}

      // Make response headers available for #1742. These are lazy-loaded because most adapters won't need them.
      response = {
        body: response,
        headers: headerParser(responseObj)
      };
      onResponse(response);
      try {
        response = requestMetrics.measureTime('interpretResponse', () => spec.interpretResponse(response, request));
      } catch (err) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`Bidder ${spec.code} failed to interpret the server's response. Continuing without bids`, null, err);
        requestDone();
        return;
      }

      // adapters can reply with:
      // a single bid
      // an array of bids
      // a BidderAuctionResponse object

      let bids, paapiConfigs;
      if (response && !Object.keys(response).some(key => !RESPONSE_PROPS.includes(key))) {
        bids = response.bids;
        paapiConfigs = response.paapi;
      } else {
        bids = response;
      }
      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(paapiConfigs)) {
        paapiConfigs.forEach(onPaapi);
      }
      if (bids) {
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(bids)) {
          bids.forEach(addBid);
        } else {
          addBid(bids);
        }
      }
      requestDone();
      function headerParser(xmlHttpResponse) {
        return {
          get: responseObj.getResponseHeader.bind(responseObj)
        };
      }
    });
    const onFailure = wrapCallback(function (errorMessage, error) {
      networkDone();
      onError(errorMessage, error);
      requestDone();
    });
    onRequest(request);
    const networkDone = requestMetrics.startTiming('net');
    function getOptions(defaults) {
      const ro = request.options;
      return Object.assign(defaults, ro, {
        browsingTopics: ro?.hasOwnProperty('browsingTopics') && !ro.browsingTopics ? false : (_bidderSettings_js__WEBPACK_IMPORTED_MODULE_12__.bidderSettings.get(spec.code, 'topicsHeader') ?? true) && (0,_activities_rules_js__WEBPACK_IMPORTED_MODULE_2__.isActivityAllowed)(_activities_activities_js__WEBPACK_IMPORTED_MODULE_3__.ACTIVITY_TRANSMIT_UFPD, (0,_activities_activityParams_js__WEBPACK_IMPORTED_MODULE_4__.activityParams)(_activities_modules_js__WEBPACK_IMPORTED_MODULE_5__.MODULE_TYPE_BIDDER, spec.code))
      });
    }
    switch (request.method) {
      case 'GET':
        ajax(`${request.url}${formatGetParameters(request.data)}`, {
          success: onSuccess,
          error: onFailure
        }, undefined, getOptions({
          method: 'GET',
          withCredentials: true
        }));
        break;
      case 'POST':
        const enableGZipCompression = request.options?.endpointCompression;
        const debugMode = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getParameterByName)(_constants_js__WEBPACK_IMPORTED_MODULE_8__.DEBUG_MODE).toUpperCase() === 'TRUE' || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.debugTurnedOn)();
        const callAjax = _ref5 => {
          let {
            url,
            payload
          } = _ref5;
          ajax(url, {
            success: onSuccess,
            error: onFailure
          }, payload, getOptions({
            method: 'POST',
            contentType: 'text/plain',
            withCredentials: true
          }));
        };
        if (enableGZipCompression && debugMode) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Skipping GZIP compression for ${spec.code} as debug mode is enabled`);
        }
        if (enableGZipCompression && !debugMode && (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isGzipCompressionSupported)()) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.compressDataWithGZip)(request.data).then(compressedPayload => {
            const url = new URL(request.url, window.location.origin);
            if (!url.searchParams.has('gzip')) {
              url.searchParams.set('gzip', '1');
            }
            callAjax({
              url: url.href,
              payload: compressedPayload
            });
          });
        } else {
          callAjax({
            url: request.url,
            payload: typeof request.data === 'string' ? request.data : JSON.stringify(request.data)
          });
        }
        break;
      default:
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Skipping invalid request from ${spec.code}. Request type ${request.type} must be GET or POST`);
        requestDone();
    }
    function formatGetParameters(data) {
      if (data) {
        return `?${typeof data === 'object' ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.parseQueryStringParameters)(data) : data}`;
      }
      return '';
    }
  });
}, 'processBidderRequests');
const registerSyncInner = (0,_hook_js__WEBPACK_IMPORTED_MODULE_13__.hook)('async', function (spec, responses, gdprConsent, uspConsent, gppConsent) {
  const aliasSyncEnabled = _config_js__WEBPACK_IMPORTED_MODULE_9__.config.getConfig('userSync.aliasSyncEnabled');
  if (spec.getUserSyncs && (aliasSyncEnabled || !_adapterManager_js__WEBPACK_IMPORTED_MODULE_0__["default"].aliasRegistry[spec.code])) {
    let syncs = spec.getUserSyncs({
      iframeEnabled: _userSync_js__WEBPACK_IMPORTED_MODULE_14__.userSync.canBidderRegisterSync('iframe', spec.code),
      pixelEnabled: _userSync_js__WEBPACK_IMPORTED_MODULE_14__.userSync.canBidderRegisterSync('image', spec.code)
    }, responses, gdprConsent, uspConsent, gppConsent);
    if (syncs) {
      if (!Array.isArray(syncs)) {
        syncs = [syncs];
      }
      syncs.forEach(sync => {
        _userSync_js__WEBPACK_IMPORTED_MODULE_14__.userSync.registerSync(sync.type, spec.code, sync.url);
      });
      _userSync_js__WEBPACK_IMPORTED_MODULE_14__.userSync.bidderDone(spec.code);
    }
  }
}, 'registerSyncs');
const addPaapiConfig = (0,_hook_js__WEBPACK_IMPORTED_MODULE_13__.hook)('sync', (request, paapiConfig) => {}, 'addPaapiConfig');

// check that the bid has a width and height set
function validBidSize(adUnitCode, bid) {
  let {
    index = _auctionManager_js__WEBPACK_IMPORTED_MODULE_15__.auctionManager.index
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if ((bid.width || parseInt(bid.width, 10) === 0) && (bid.height || parseInt(bid.height, 10) === 0)) {
    bid.width = parseInt(bid.width, 10);
    bid.height = parseInt(bid.height, 10);
    return true;
  }
  if (bid.wratio != null && bid.hratio != null) {
    bid.wratio = parseInt(bid.wratio, 10);
    bid.hratio = parseInt(bid.hratio, 10);
    return true;
  }
  const bidRequest = index.getBidRequest(bid);
  const mediaTypes = index.getMediaTypes(bid);
  const sizes = bidRequest && bidRequest.sizes || mediaTypes && mediaTypes.banner && mediaTypes.banner.sizes;
  const parsedSizes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.parseSizesInput)(sizes);

  // if a banner impression has one valid size, we assign that size to any bid
  // response that does not explicitly set width or height
  if (parsedSizes.length === 1) {
    const [width, height] = parsedSizes[0].split('x');
    bid.width = parseInt(width, 10);
    bid.height = parseInt(height, 10);
    return true;
  }
  return false;
}

// Validate the arguments sent to us by the adapter. If this returns false, the bid should be totally ignored.
function isValid(adUnitCode, bid) {
  let {
    index = _auctionManager_js__WEBPACK_IMPORTED_MODULE_15__.auctionManager.index
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  function hasValidKeys() {
    let bidKeys = Object.keys(bid);
    return COMMON_BID_RESPONSE_KEYS.every(key => bidKeys.includes(key) && ![undefined, null].includes(bid[key]));
  }
  function errorMessage(msg) {
    return `Invalid bid from ${bid.bidderCode}. Ignoring bid: ${msg}`;
  }
  if (!adUnitCode) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)('No adUnitCode was supplied to addBidResponse.');
    return false;
  }
  if (!bid) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Some adapter tried to add an undefined bid for ${adUnitCode}.`);
    return false;
  }
  if (!hasValidKeys()) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(errorMessage(`Bidder ${bid.bidderCode} is missing required params. Check http://prebid.org/dev-docs/bidder-adapter-1.html for list of params.`));
    return false;
  }
  if ( true && bid.mediaType === 'native' && !(0,_native_js__WEBPACK_IMPORTED_MODULE_16__.nativeBidIsValid)(bid, {
    index
  })) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(errorMessage('Native bid missing some required properties.'));
    return false;
  }
  if ( true && bid.mediaType === 'video' && !(0,_video_js__WEBPACK_IMPORTED_MODULE_17__.isValidVideoBid)(bid, {
    index
  })) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(errorMessage(`Video bid does not have required vastUrl or renderer property`));
    return false;
  }
  if (bid.mediaType === 'banner' && !validBidSize(adUnitCode, bid, {
    index
  })) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(errorMessage(`Banner bids require a width and height`));
    return false;
  }
  return true;
}
function adapterMetrics(bidderRequest) {
  return (0,_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_7__.useMetrics)(bidderRequest.metrics).renameWith(n => [`adapter.client.${n}`, `adapters.client.${bidderRequest.bidderCode}.${n}`]);
}

/***/ }),

/***/ "./src/adloader.js":
/*!*************************!*\
  !*** ./src/adloader.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadExternalScript: () => (/* binding */ loadExternalScript)
/* harmony export */ });
/* harmony import */ var _activities_activities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./activities/activities.js */ "./src/activities/activities.js");
/* harmony import */ var _activities_activityParams_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./activities/activityParams.js */ "./src/activities/activityParams.js");
/* harmony import */ var _activities_rules_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activities/rules.js */ "./src/activities/rules.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");




const _requestCache = new WeakMap();
// The below list contains modules or vendors whom Prebid allows to load external JS.
const _approvedLoadExternalJSList = [
// Prebid maintained modules:
'debugging', 'outstream',
// RTD modules:
'aaxBlockmeter', 'adagio', 'adloox', 'akamaidap', 'arcspan', 'airgrid', 'browsi', 'brandmetrics', 'clean.io', 'humansecurity', 'confiant', 'contxtful', 'hadron', 'mediafilter', 'medianet', 'azerionedge', 'a1Media', 'geoedge', 'qortex', 'dynamicAdBoost', '51Degrees', 'symitridap', 'wurfl', 'nodalsAi', 'anonymised', 'optable',
// UserId Submodules
'justtag', 'tncId', 'ftrackId', 'id5'];

/**
 * Loads external javascript. Can only be used if external JS is approved by Prebid. See https://github.com/prebid/prebid-js-external-js-template#policy
 * Each unique URL will be loaded at most 1 time.
 * @param {string} url the url to load
 * @param {string} moduleType moduleType of the module requesting this resource
 * @param {string} moduleCode bidderCode or module code of the module requesting this resource
 * @param {function} [callback] callback function to be called after the script is loaded
 * @param {Document} [doc] the context document, in which the script will be loaded, defaults to loaded document
 * @param {object} attributes an object of attributes to be added to the script with setAttribute by [key] and [value]; Only the attributes passed in the first request of a url will be added.
 */
function loadExternalScript(url, moduleType, moduleCode, callback, doc, attributes) {
  if (!(0,_activities_rules_js__WEBPACK_IMPORTED_MODULE_0__.isActivityAllowed)(_activities_activities_js__WEBPACK_IMPORTED_MODULE_1__.LOAD_EXTERNAL_SCRIPT, (0,_activities_activityParams_js__WEBPACK_IMPORTED_MODULE_2__.activityParams)(moduleType, moduleCode))) {
    return;
  }
  if (!moduleCode || !url) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)('cannot load external script without url and moduleCode');
    return;
  }
  if (!_approvedLoadExternalJSList.includes(moduleCode)) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`${moduleCode} not whitelisted for loading external JavaScript`);
    return;
  }
  if (!doc) {
    doc = document; // provide a "valid" key for the WeakMap
  }
  // only load each asset once
  const storedCachedObject = getCacheObject(doc, url);
  if (storedCachedObject) {
    if (callback && typeof callback === 'function') {
      if (storedCachedObject.loaded) {
        // invokeCallbacks immediately
        callback();
      } else {
        // queue the callback
        storedCachedObject.callbacks.push(callback);
      }
    }
    return storedCachedObject.tag;
  }
  const cachedDocObj = _requestCache.get(doc) || {};
  const cacheObject = {
    loaded: false,
    tag: null,
    callbacks: []
  };
  cachedDocObj[url] = cacheObject;
  _requestCache.set(doc, cachedDocObj);
  if (callback && typeof callback === 'function') {
    cacheObject.callbacks.push(callback);
  }
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(`module ${moduleCode} is loading external JavaScript`);
  return requestResource(url, function () {
    cacheObject.loaded = true;
    try {
      for (let i = 0; i < cacheObject.callbacks.length; i++) {
        cacheObject.callbacks[i]();
      }
    } catch (e) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)('Error executing callback', 'adloader.js:loadExternalScript', e);
    }
  }, doc, attributes);
  function requestResource(tagSrc, callback, doc, attributes) {
    if (!doc) {
      doc = document;
    }
    var jptScript = doc.createElement('script');
    jptScript.type = 'text/javascript';
    jptScript.async = true;
    const cacheObject = getCacheObject(doc, url);
    if (cacheObject) {
      cacheObject.tag = jptScript;
    }
    if (jptScript.readyState) {
      jptScript.onreadystatechange = function () {
        if (jptScript.readyState === 'loaded' || jptScript.readyState === 'complete') {
          jptScript.onreadystatechange = null;
          callback();
        }
      };
    } else {
      jptScript.onload = function () {
        callback();
      };
    }
    jptScript.src = tagSrc;
    if (attributes) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.setScriptAttributes)(jptScript, attributes);
    }

    // add the new script tag to the page
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.insertElement)(jptScript, doc);
    return jptScript;
  }
  function getCacheObject(doc, url) {
    const cachedDocObj = _requestCache.get(doc);
    if (cachedDocObj && cachedDocObj[url]) {
      return cachedDocObj[url];
    }
    return null; // return new cache object?
  }
}
;

/***/ }),

/***/ "./src/adserver.js":
/*!*************************!*\
  !*** ./src/adserver.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPPID: () => (/* binding */ getPPID)
/* harmony export */ });
/* harmony import */ var _hook_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hook.js */ "./src/hook.js");


/**
 * return the GAM PPID, if available (eid for the userID configured with `userSync.ppidSource`)
 */
const getPPID = (0,_hook_js__WEBPACK_IMPORTED_MODULE_0__.hook)('sync', () => undefined);

/***/ }),

/***/ "./src/ajax.js":
/*!*********************!*\
  !*** ./src/ajax.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ajax: () => (/* binding */ ajax),
/* harmony export */   ajaxBuilder: () => (/* binding */ ajaxBuilder),
/* harmony export */   fetch: () => (/* binding */ fetch)
/* harmony export */ });
/* unused harmony exports dep, toFetchRequest, fetcherFactory, attachCallbacks, sendBeacon */
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config.js */ "./src/config.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");


const dep = {
  fetch: window.fetch.bind(window),
  makeRequest: (r, o) => new Request(r, o),
  timeout(timeout, resource) {
    const ctl = new AbortController();
    let cancelTimer = setTimeout(() => {
      ctl.abort();
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError)(`Request timeout after ${timeout}ms`, resource);
      cancelTimer = null;
    }, timeout);
    return {
      signal: ctl.signal,
      done() {
        cancelTimer && clearTimeout(cancelTimer);
      }
    };
  }
};
const GET = 'GET';
const POST = 'POST';
const CTYPE = 'Content-Type';

/**
 * transform legacy `ajax` parameters into a fetch request.
 * @returns {Request}
 */
function toFetchRequest(url, data) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const method = options.method || (data ? POST : GET);
  if (method === GET && data) {
    const urlInfo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseUrl)(url, options);
    Object.assign(urlInfo.search, data);
    url = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.buildUrl)(urlInfo);
  }
  const headers = new Headers(options.customHeaders);
  headers.set(CTYPE, options.contentType || 'text/plain');
  const rqOpts = {
    method,
    headers
  };
  if (method !== GET && data) {
    rqOpts.body = data;
  }
  if (options.withCredentials) {
    rqOpts.credentials = 'include';
  }
  if (isSecureContext) {
    ['browsingTopics', 'adAuctionHeaders'].forEach(opt => {
      // the Request constructor will throw an exception if the browser supports topics/fledge
      // but we're not in a secure context
      if (options[opt]) {
        rqOpts[opt] = true;
      }
    });
  }
  if (options.keepalive) {
    rqOpts.keepalive = true;
  }
  return dep.makeRequest(url, rqOpts);
}

/**
 * Return a version of `fetch` that automatically cancels requests after `timeout` milliseconds.
 *
 * If provided, `request` and `done` should be functions accepting a single argument.
 * `request` is invoked at the beginning of each request, and `done` at the end; both are passed its origin.
 *
 * @returns {function(*, {}?): Promise<Response>}
 */
function fetcherFactory() {
  let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3000;
  let {
    request,
    done
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let fetcher = (resource, options) => {
    let to;
    if (timeout != null && options?.signal == null && !_config_js__WEBPACK_IMPORTED_MODULE_1__.config.getConfig('disableAjaxTimeout')) {
      to = dep.timeout(timeout, resource);
      options = Object.assign({
        signal: to.signal
      }, options);
    }
    let pm = dep.fetch(resource, options);
    if (to?.done != null) pm = pm.finally(to.done);
    return pm;
  };
  if (request != null || done != null) {
    fetcher = (fetch => function (resource, options) {
      const origin = new URL(resource?.url == null ? resource : resource.url, document.location).origin;
      let req = fetch(resource, options);
      request && request(origin);
      if (done) req = req.finally(() => done(origin));
      return req;
    })(fetcher);
  }
  return fetcher;
}
function toXHR(_ref, responseText) {
  let {
    status,
    statusText = '',
    headers,
    url
  } = _ref;
  let xml = 0;
  function getXML(onError) {
    if (xml === 0) {
      try {
        xml = new DOMParser().parseFromString(responseText, headers?.get(CTYPE)?.split(';')?.[0]);
      } catch (e) {
        xml = null;
        onError && onError(e);
      }
    }
    return xml;
  }
  return {
    // eslint-disable-next-line no-restricted-globals
    readyState: XMLHttpRequest.DONE,
    status,
    statusText,
    responseText,
    response: responseText,
    responseType: '',
    responseURL: url,
    get responseXML() {
      return getXML(_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError);
    },
    getResponseHeader: header => headers?.has(header) ? headers.get(header) : null,
    toJSON() {
      return Object.assign({
        responseXML: getXML()
      }, this);
    },
    timedOut: false
  };
}

/**
 * attach legacy `ajax` callbacks to a fetch promise.
 */
function attachCallbacks(fetchPm, callback) {
  const {
    success,
    error
  } = typeof callback === 'object' && callback != null ? callback : {
    success: typeof callback === 'function' ? callback : () => null,
    error: (e, x) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError)('Network error', e, x)
  };
  return fetchPm.then(response => response.text().then(responseText => [response, responseText])).then(_ref2 => {
    let [response, responseText] = _ref2;
    const xhr = toXHR(response, responseText);
    response.ok || response.status === 304 ? success(responseText, xhr) : error(response.statusText, xhr);
  }, reason => error('', Object.assign(toXHR({
    status: 0
  }, ''), {
    reason,
    timedOut: reason?.name === 'AbortError'
  })));
}
function ajaxBuilder() {
  let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3000;
  let {
    request,
    done
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const fetcher = fetcherFactory(timeout, {
    request,
    done
  });
  return function (url, callback, data) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    attachCallbacks(fetcher(toFetchRequest(url, data, options)), callback);
  };
}

/**
 * simple wrapper around sendBeacon such that invocations of navigator.sendBeacon can be centrally maintained.
 * verifies that the navigator and sendBeacon are defined for maximum compatibility
 * @param {string} url The URL that will receive the data. Can be relative or absolute.
 * @param {*} data An ArrayBuffer, a TypedArray, a DataView, a Blob, a string literal or object, a FormData or a URLSearchParams object containing the data to send.
 * @returns {boolean} true if the user agent successfully queued the data for transfer. Otherwise, it returns false.
 */
function sendBeacon(url, data) {
  if (!window.navigator || !window.navigator.sendBeacon) {
    return false;
  }
  return window.navigator.sendBeacon(url, data);
}
const ajax = ajaxBuilder();
const fetch = fetcherFactory();

/***/ }),

/***/ "./src/auction.js":
/*!************************!*\
  !*** ./src/auction.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AUCTION_COMPLETED: () => (/* binding */ AUCTION_COMPLETED),
/* harmony export */   AUCTION_IN_PROGRESS: () => (/* binding */ AUCTION_IN_PROGRESS),
/* harmony export */   addBidToAuction: () => (/* binding */ addBidToAuction),
/* harmony export */   getPriceByGranularity: () => (/* binding */ getPriceByGranularity),
/* harmony export */   getPriceGranularity: () => (/* binding */ getPriceGranularity),
/* harmony export */   getStandardBidderSettings: () => (/* binding */ getStandardBidderSettings),
/* harmony export */   newAuction: () => (/* binding */ newAuction)
/* harmony export */ });
/* unused harmony exports AUCTION_STARTED, resetAuctionState, addBidResponse, responsesReady, addBidderRequests, bidsBackCallback, auctionCallbacks, callPrebidCache, getMediaTypeGranularity, getCreativeId, getAdvertiserDomain, getDSP, getPrimaryCatId, getKeyValueTargetingPairs, adjustBids */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _cpmBucketManager_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cpmBucketManager.js */ "./src/cpmBucketManager.js");
/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./native.js */ "./src/native.js");
/* harmony import */ var _videoCache_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./videoCache.js */ "./src/videoCache.js");
/* harmony import */ var _Renderer_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Renderer.js */ "./src/Renderer.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./config.js */ "./src/config.js");
/* harmony import */ var _userSync_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./userSync.js */ "./src/userSync.js");
/* harmony import */ var _hook_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./hook.js */ "./src/hook.js");
/* harmony import */ var _video_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./video.js */ "./src/video.js");
/* harmony import */ var _mediaTypes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./mediaTypes.js */ "./src/mediaTypes.js");
/* harmony import */ var _auctionManager_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./auctionManager.js */ "./src/auctionManager.js");
/* harmony import */ var _bidderSettings_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./bidderSettings.js */ "./src/bidderSettings.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./src/events.js");
/* harmony import */ var _adapterManager_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./adapterManager.js */ "./src/adapterManager.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ "./src/constants.js");
/* harmony import */ var _utils_promise_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/perfMetrics.js */ "./src/utils/perfMetrics.js");
/* harmony import */ var _utils_cpm_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utils/cpm.js */ "./src/utils/cpm.js");
/* harmony import */ var _prebidGlobal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _utils_ttlCollection_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/ttlCollection.js */ "./src/utils/ttlCollection.js");
/* harmony import */ var _bidTTL_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./bidTTL.js */ "./src/bidTTL.js");
/**
 * Module for auction instances.
 *
 * In Prebid 0.x, $$PREBID_GLOBAL$$ had _bidsRequested and _bidsReceived as public properties.
 * Starting 1.0, Prebid will support concurrent auctions. Each auction instance will store private properties, bidsRequested and bidsReceived.
 *
 * AuctionManager will create an instance of auction and will store all the auctions.
 *
 */

/**
 * @typedef {import('../src/adapters/bidderFactory.js').BidRequest} BidRequest
 * @typedef {import('../src/adapters/bidderFactory.js').Bid} Bid
 * @typedef {import('../src/config.js').MediaTypePriceGranularity} MediaTypePriceGranularity
 * @typedef {import('../src/mediaTypes.js').MediaType} MediaType
 */

/**
 * @typedef {Object} AdUnit An object containing the adUnit configuration.
 *
 * @property {string} code A code which will be used to uniquely identify this bidder. This should be the same
 *   one as is used in the call to registerBidAdapter
 * @property {Array.<size>} sizes A list of size for adUnit.
 * @property {object} params Any bidder-specific params which the publisher used in their bid request.
 *   This is guaranteed to have passed the spec.areParamsValid() test.
 */

/**
 * @typedef {Array.<number>} size
 */

/**
 * @typedef {Array.<string>} AdUnitCode
 */

/**
 * @typedef {Object} BidderRequest
 *
 * @property {string} bidderCode - adUnit bidder
 * @property {number} auctionId - random UUID
 * @property {string} bidderRequestId - random string, unique key set on all bidRequest.bids[]
 * @property {Array.<Bid>} bids
 * @property {number} auctionStart - Date.now() at auction start
 * @property {number} timeout - callback timeout
 * @property {refererInfo} refererInfo - referer info object
 * @property {string} [tid] - random UUID (used for s2s)
 * @property {string} [src] - s2s or client (used for s2s)
 * @property {import('./types/ortb2.js').Ortb2.BidRequest} [ortb2] Global (not specific to any adUnit) first party data to use for all requests in this auction.
 */

/**
 * @typedef {Object} BidReceived
 * //TODO add all properties
 */

/**
 * @typedef {Object} Auction
 *
 * @property {function(): string} getAuctionStatus - returns the auction status which can be any one of 'started', 'in progress' or 'completed'
 * @property {function(): AdUnit[]} getAdUnits - return the adUnits for this auction instance
 * @property {function(): AdUnitCode[]} getAdUnitCodes - return the adUnitCodes for this auction instance
 * @property {function(): BidRequest[]} getBidRequests - get all bid requests for this auction instance
 * @property {function(): BidReceived[]} getBidsReceived - get all bid received for this auction instance
 * @property {function(): void} startAuctionTimer - sets the bidsBackHandler callback and starts the timer for auction
 * @property {function(): void} callBids - sends requests to all adapters for bids
 */






















const {
  syncUsers
} = _userSync_js__WEBPACK_IMPORTED_MODULE_0__.userSync;
const AUCTION_STARTED = 'started';
const AUCTION_IN_PROGRESS = 'inProgress';
const AUCTION_COMPLETED = 'completed';

// register event for bid adjustment
_events_js__WEBPACK_IMPORTED_MODULE_1__.on(_constants_js__WEBPACK_IMPORTED_MODULE_2__.EVENTS.BID_ADJUSTMENT, function (bid) {
  adjustBids(bid);
});
const MAX_REQUESTS_PER_ORIGIN = 4;
const outstandingRequests = {};
const sourceInfo = {};
const queuedCalls = [];
const pbjsInstance = (0,_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_3__.getGlobal)();

/**
 * Clear global state for tests
 */
function resetAuctionState() {
  queuedCalls.length = 0;
  [outstandingRequests, sourceInfo].forEach(ob => Object.keys(ob).forEach(k => {
    delete ob[k];
  }));
}

/**
 * Creates new auction instance
 *
 * @param {Object} requestConfig
 * @param {AdUnit} requestConfig.adUnits
 * @param {AdUnitCode} requestConfig.adUnitCodes
 * @param {function():void} requestConfig.callback
 * @param {number} requestConfig.cbTimeout
 * @param {Array.<string>} requestConfig.labels
 * @param {string} requestConfig.auctionId
 * @param {{global: {}, bidder: {}}} requestConfig.ortb2Fragments first party data, separated into global
 *    (from getConfig('ortb2') + requestBids({ortb2})) and bidder (a map from bidderCode to ortb2)
 * @param {Object} requestConfig.metrics
 * @returns {Auction} auction instance
 */
function newAuction(_ref) {
  let {
    adUnits,
    adUnitCodes,
    callback,
    cbTimeout,
    labels,
    auctionId,
    ortb2Fragments,
    metrics
  } = _ref;
  metrics = (0,_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_4__.useMetrics)(metrics);
  const _adUnits = adUnits;
  const _labels = labels;
  const _adUnitCodes = adUnitCodes;
  const _auctionId = auctionId || (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.generateUUID)();
  const _timeout = cbTimeout;
  const _timelyRequests = new Set();
  const done = (0,_utils_promise_js__WEBPACK_IMPORTED_MODULE_6__.defer)();
  const requestsDone = (0,_utils_promise_js__WEBPACK_IMPORTED_MODULE_6__.defer)();
  let _bidsRejected = [];
  let _callback = callback;
  let _bidderRequests = [];
  let _bidsReceived = (0,_utils_ttlCollection_js__WEBPACK_IMPORTED_MODULE_7__.ttlCollection)({
    startTime: bid => bid.responseTimestamp,
    ttl: bid => (0,_bidTTL_js__WEBPACK_IMPORTED_MODULE_8__.getMinBidCacheTTL)() == null ? null : Math.max((0,_bidTTL_js__WEBPACK_IMPORTED_MODULE_8__.getMinBidCacheTTL)(), bid.ttl) * 1000
  });
  let _noBids = [];
  let _winningBids = [];
  let _auctionStart;
  let _auctionEnd;
  let _timeoutTimer;
  let _auctionStatus;
  let _nonBids = [];
  (0,_bidTTL_js__WEBPACK_IMPORTED_MODULE_8__.onMinBidCacheTTLChange)(() => _bidsReceived.refresh());
  function addBidRequests(bidderRequests) {
    _bidderRequests = _bidderRequests.concat(bidderRequests);
  }
  function addBidReceived(bid) {
    _bidsReceived.add(bid);
  }
  function addBidRejected(bidsRejected) {
    _bidsRejected = _bidsRejected.concat(bidsRejected);
  }
  function addNoBid(noBid) {
    _noBids = _noBids.concat(noBid);
  }
  function addNonBids(seatnonbids) {
    _nonBids = _nonBids.concat(seatnonbids);
  }
  function getProperties() {
    return {
      auctionId: _auctionId,
      timestamp: _auctionStart,
      auctionEnd: _auctionEnd,
      auctionStatus: _auctionStatus,
      adUnits: _adUnits,
      adUnitCodes: _adUnitCodes,
      labels: _labels,
      bidderRequests: _bidderRequests,
      noBids: _noBids,
      bidsReceived: _bidsReceived.toArray(),
      bidsRejected: _bidsRejected,
      winningBids: _winningBids,
      timeout: _timeout,
      metrics: metrics,
      seatNonBids: _nonBids
    };
  }
  function startAuctionTimer() {
    _timeoutTimer = setTimeout(() => executeCallback(true), _timeout);
  }
  function executeCallback(timedOut) {
    if (!timedOut) {
      clearTimeout(_timeoutTimer);
    } else {
      _events_js__WEBPACK_IMPORTED_MODULE_1__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_2__.EVENTS.AUCTION_TIMEOUT, getProperties());
    }
    if (_auctionEnd === undefined) {
      let timedOutRequests = [];
      if (timedOut) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logMessage)(`Auction ${_auctionId} timedOut`);
        timedOutRequests = _bidderRequests.filter(rq => !_timelyRequests.has(rq.bidderRequestId)).flatMap(br => br.bids);
        if (timedOutRequests.length) {
          _events_js__WEBPACK_IMPORTED_MODULE_1__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_2__.EVENTS.BID_TIMEOUT, timedOutRequests);
        }
      }
      _auctionStatus = AUCTION_COMPLETED;
      _auctionEnd = Date.now();
      metrics.checkpoint('auctionEnd');
      metrics.timeBetween('requestBids', 'auctionEnd', 'requestBids.total');
      metrics.timeBetween('callBids', 'auctionEnd', 'requestBids.callBids');
      done.resolve();
      _events_js__WEBPACK_IMPORTED_MODULE_1__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_2__.EVENTS.AUCTION_END, getProperties());
      bidsBackCallback(_adUnits, function () {
        try {
          if (_callback != null) {
            const bids = _bidsReceived.toArray().filter(bid => _adUnitCodes.includes(bid.adUnitCode)).reduce(groupByPlacement, {});
            _callback.apply(pbjsInstance, [bids, timedOut, _auctionId]);
            _callback = null;
          }
        } catch (e) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logError)('Error executing bidsBackHandler', null, e);
        } finally {
          // Calling timed out bidders
          if (timedOutRequests.length) {
            _adapterManager_js__WEBPACK_IMPORTED_MODULE_9__["default"].callTimedOutBidders(adUnits, timedOutRequests, _timeout);
          }
          // Only automatically sync if the publisher has not chosen to "enableOverride"
          let userSyncConfig = _config_js__WEBPACK_IMPORTED_MODULE_10__.config.getConfig('userSync') || {};
          if (!userSyncConfig.enableOverride) {
            // Delay the auto sync by the config delay
            syncUsers(userSyncConfig.syncDelay);
          }
        }
      });
    }
  }
  function auctionDone() {
    _config_js__WEBPACK_IMPORTED_MODULE_10__.config.resetBidder();
    // when all bidders have called done callback atleast once it means auction is complete
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logInfo)(`Bids Received for Auction with id: ${_auctionId}`, _bidsReceived.toArray());
    _auctionStatus = AUCTION_COMPLETED;
    executeCallback(false);
  }
  function onTimelyResponse(bidderRequestId) {
    _timelyRequests.add(bidderRequestId);
  }
  function callBids() {
    _auctionStatus = AUCTION_STARTED;
    _auctionStart = Date.now();
    let bidRequests = metrics.measureTime('requestBids.makeRequests', () => _adapterManager_js__WEBPACK_IMPORTED_MODULE_9__["default"].makeBidRequests(_adUnits, _auctionStart, _auctionId, _timeout, _labels, ortb2Fragments, metrics));
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logInfo)(`Bids Requested for Auction with id: ${_auctionId}`, bidRequests);
    metrics.checkpoint('callBids');
    if (bidRequests.length < 1) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logWarn)('No valid bid requests returned for auction');
      auctionDone();
    } else {
      addBidderRequests.call({
        dispatch: addBidderRequestsCallback,
        context: this
      }, bidRequests);
    }
  }

  /**
   * callback executed after addBidderRequests completes
   * @param {BidRequest[]} bidRequests
   */
  function addBidderRequestsCallback(bidRequests) {
    bidRequests.forEach(bidRequest => {
      addBidRequests(bidRequest);
    });
    let requests = {};
    let call = {
      bidRequests,
      run: () => {
        startAuctionTimer();
        _auctionStatus = AUCTION_IN_PROGRESS;
        _events_js__WEBPACK_IMPORTED_MODULE_1__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_2__.EVENTS.AUCTION_INIT, getProperties());
        let callbacks = auctionCallbacks(auctionDone, this);
        _adapterManager_js__WEBPACK_IMPORTED_MODULE_9__["default"].callBids(_adUnits, bidRequests, callbacks.addBidResponse, callbacks.adapterDone, {
          request(source, origin) {
            increment(outstandingRequests, origin);
            increment(requests, source);
            if (!sourceInfo[source]) {
              sourceInfo[source] = {
                SRA: true,
                origin
              };
            }
            if (requests[source] > 1) {
              sourceInfo[source].SRA = false;
            }
          },
          done(origin) {
            outstandingRequests[origin]--;
            if (queuedCalls[0]) {
              if (runIfOriginHasCapacity(queuedCalls[0])) {
                queuedCalls.shift();
              }
            }
          }
        }, _timeout, onTimelyResponse, ortb2Fragments);
        requestsDone.resolve();
      }
    };
    if (!runIfOriginHasCapacity(call)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logWarn)('queueing auction due to limited endpoint capacity');
      queuedCalls.push(call);
    }
    function runIfOriginHasCapacity(call) {
      let hasCapacity = true;
      let maxRequests = _config_js__WEBPACK_IMPORTED_MODULE_10__.config.getConfig('maxRequestsPerOrigin') || MAX_REQUESTS_PER_ORIGIN;
      call.bidRequests.some(bidRequest => {
        let requests = 1;
        let source = typeof bidRequest.src !== 'undefined' && bidRequest.src === _constants_js__WEBPACK_IMPORTED_MODULE_2__.S2S.SRC ? 's2s' : bidRequest.bidderCode;
        // if we have no previous info on this source just let them through
        if (sourceInfo[source]) {
          if (sourceInfo[source].SRA === false) {
            // some bidders might use more than the MAX_REQUESTS_PER_ORIGIN in a single auction.  In those cases
            // set their request count to MAX_REQUESTS_PER_ORIGIN so the auction isn't permanently queued waiting
            // for capacity for that bidder
            requests = Math.min(bidRequest.bids.length, maxRequests);
          }
          if (outstandingRequests[sourceInfo[source].origin] + requests > maxRequests) {
            hasCapacity = false;
          }
        }
        // return only used for terminating this .some() iteration early if it is determined we don't have capacity
        return !hasCapacity;
      });
      if (hasCapacity) {
        call.run();
      }
      return hasCapacity;
    }
    function increment(obj, prop) {
      if (typeof obj[prop] === 'undefined') {
        obj[prop] = 1;
      } else {
        obj[prop]++;
      }
    }
  }
  function addWinningBid(winningBid) {
    _winningBids = _winningBids.concat(winningBid);
    _adapterManager_js__WEBPACK_IMPORTED_MODULE_9__["default"].callBidWonBidder(winningBid.adapterCode || winningBid.bidder, winningBid, adUnits);
    if (!winningBid.deferBilling) {
      _adapterManager_js__WEBPACK_IMPORTED_MODULE_9__["default"].triggerBilling(winningBid);
    }
  }
  function setBidTargeting(bid) {
    _adapterManager_js__WEBPACK_IMPORTED_MODULE_9__["default"].callSetTargetingBidder(bid.adapterCode || bid.bidder, bid);
  }
  _events_js__WEBPACK_IMPORTED_MODULE_1__.on(_constants_js__WEBPACK_IMPORTED_MODULE_2__.EVENTS.SEAT_NON_BID, event => {
    if (event.auctionId === _auctionId) {
      addNonBids(event.seatnonbid);
    }
  });
  return {
    addBidReceived,
    addBidRejected,
    addNoBid,
    callBids,
    addWinningBid,
    setBidTargeting,
    getWinningBids: () => _winningBids,
    getAuctionStart: () => _auctionStart,
    getAuctionEnd: () => _auctionEnd,
    getTimeout: () => _timeout,
    getAuctionId: () => _auctionId,
    getAuctionStatus: () => _auctionStatus,
    getAdUnits: () => _adUnits,
    getAdUnitCodes: () => _adUnitCodes,
    getBidRequests: () => _bidderRequests,
    getBidsReceived: () => _bidsReceived.toArray(),
    getNoBids: () => _noBids,
    getNonBids: () => _nonBids,
    getFPD: () => ortb2Fragments,
    getMetrics: () => metrics,
    end: done.promise,
    requestsDone: requestsDone.promise,
    getProperties
  };
}

/**
 * Hook into this to intercept bids before they are added to an auction.
 *
 * @type {Function}
 * @param adUnitCode
 * @param bid
 * @param {function(String): void} reject a function that, when called, rejects `bid` with the given reason.
 */
const addBidResponse = (0,_hook_js__WEBPACK_IMPORTED_MODULE_11__.ignoreCallbackArg)((0,_hook_js__WEBPACK_IMPORTED_MODULE_11__.hook)('async', function (adUnitCode, bid, reject) {
  if (!isValidPrice(bid)) {
    reject(_constants_js__WEBPACK_IMPORTED_MODULE_2__.REJECTION_REASON.PRICE_TOO_HIGH);
  } else {
    this.dispatch.call(null, adUnitCode, bid);
  }
}, 'addBidResponse'));

/**
 * Delay hook for adapter responses.
 *
 * `ready` is a promise; auctions wait for it to resolve before closing. Modules can hook into this
 * to delay the end of auctions while they perform initialization that does not need to delay their start.
 */
const responsesReady = (0,_hook_js__WEBPACK_IMPORTED_MODULE_11__.hook)('sync', ready => ready, 'responsesReady');
const addBidderRequests = (0,_hook_js__WEBPACK_IMPORTED_MODULE_11__.hook)('sync', function (bidderRequests) {
  this.dispatch.call(this.context, bidderRequests);
}, 'addBidderRequests');
const bidsBackCallback = (0,_hook_js__WEBPACK_IMPORTED_MODULE_11__.hook)('async', function (adUnits, callback) {
  if (callback) {
    callback();
  }
}, 'bidsBackCallback');
function auctionCallbacks(auctionDone, auctionInstance) {
  let {
    index = _auctionManager_js__WEBPACK_IMPORTED_MODULE_12__.auctionManager.index
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let outstandingBidsAdded = 0;
  let allAdapterCalledDone = false;
  let bidderRequestsDone = new Set();
  let bidResponseMap = {};
  function afterBidAdded() {
    outstandingBidsAdded--;
    if (allAdapterCalledDone && outstandingBidsAdded === 0) {
      auctionDone();
    }
  }
  function handleBidResponse(adUnitCode, bid, handler) {
    bidResponseMap[bid.requestId] = true;
    addCommonResponseProperties(bid, adUnitCode);
    outstandingBidsAdded++;
    return handler(afterBidAdded);
  }
  function acceptBidResponse(adUnitCode, bid) {
    handleBidResponse(adUnitCode, bid, done => {
      let bidResponse = getPreparedBidForAuction(bid);
      _events_js__WEBPACK_IMPORTED_MODULE_1__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_2__.EVENTS.BID_ACCEPTED, bidResponse);
      if ( true && bidResponse.mediaType === _mediaTypes_js__WEBPACK_IMPORTED_MODULE_13__.VIDEO) {
        tryAddVideoBid(auctionInstance, bidResponse, done);
      } else {
        if ( true && (0,_native_js__WEBPACK_IMPORTED_MODULE_14__.isNativeResponse)(bidResponse)) {
          (0,_native_js__WEBPACK_IMPORTED_MODULE_14__.setNativeResponseProperties)(bidResponse, index.getAdUnit(bidResponse));
        }
        addBidToAuction(auctionInstance, bidResponse);
        done();
      }
    });
  }
  function rejectBidResponse(adUnitCode, bid, reason) {
    return handleBidResponse(adUnitCode, bid, done => {
      bid.rejectionReason = reason;
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logWarn)(`Bid from ${bid.bidder || 'unknown bidder'} was rejected: ${reason}`, bid);
      _events_js__WEBPACK_IMPORTED_MODULE_1__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_2__.EVENTS.BID_REJECTED, bid);
      auctionInstance.addBidRejected(bid);
      done();
    });
  }
  function adapterDone() {
    let bidderRequest = this;
    let bidderRequests = auctionInstance.getBidRequests();
    const auctionOptionsConfig = _config_js__WEBPACK_IMPORTED_MODULE_10__.config.getConfig('auctionOptions');
    bidderRequestsDone.add(bidderRequest);
    if (auctionOptionsConfig && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isEmpty)(auctionOptionsConfig)) {
      const secondaryBidders = auctionOptionsConfig.secondaryBidders;
      if (secondaryBidders && !bidderRequests.every(bidder => secondaryBidders.includes(bidder.bidderCode))) {
        bidderRequests = bidderRequests.filter(request => !secondaryBidders.includes(request.bidderCode));
      }
    }
    allAdapterCalledDone = bidderRequests.every(bidderRequest => bidderRequestsDone.has(bidderRequest));
    bidderRequest.bids.forEach(bid => {
      if (!bidResponseMap[bid.bidId]) {
        auctionInstance.addNoBid(bid);
        _events_js__WEBPACK_IMPORTED_MODULE_1__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_2__.EVENTS.NO_BID, bid);
      }
    });
    if (allAdapterCalledDone && outstandingBidsAdded === 0) {
      auctionDone();
    }
  }
  return {
    addBidResponse: function () {
      function addBid(adUnitCode, bid) {
        addBidResponse.call({
          dispatch: acceptBidResponse
        }, adUnitCode, bid, (() => {
          let rejected = false;
          return reason => {
            if (!rejected) {
              rejectBidResponse(adUnitCode, bid, reason);
              rejected = true;
            }
          };
        })());
      }
      addBid.reject = rejectBidResponse;
      return addBid;
    }(),
    adapterDone: function () {
      responsesReady(_utils_promise_js__WEBPACK_IMPORTED_MODULE_6__.PbPromise.resolve()).finally(() => adapterDone.call(this));
    }
  };
}

// Add a bid to the auction.
function addBidToAuction(auctionInstance, bidResponse) {
  setupBidTargeting(bidResponse);
  (0,_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_4__.useMetrics)(bidResponse.metrics).timeSince('addBidResponse', 'addBidResponse.total');
  auctionInstance.addBidReceived(bidResponse);
  _events_js__WEBPACK_IMPORTED_MODULE_1__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_2__.EVENTS.BID_RESPONSE, bidResponse);
}

// Video bids may fail if the cache is down, or there's trouble on the network.
function tryAddVideoBid(auctionInstance, bidResponse, afterBidAdded) {
  let {
    index = _auctionManager_js__WEBPACK_IMPORTED_MODULE_12__.auctionManager.index
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  let addBid = true;
  const videoMediaType = index.getMediaTypes({
    requestId: bidResponse.originalRequestId || bidResponse.requestId,
    adUnitId: bidResponse.adUnitId
  })?.video;
  const context = videoMediaType && videoMediaType?.context;
  const useCacheKey = videoMediaType && videoMediaType?.useCacheKey;
  const {
    useLocal,
    url: cacheUrl,
    ignoreBidderCacheKey
  } = _config_js__WEBPACK_IMPORTED_MODULE_10__.config.getConfig('cache') || {};
  if (useLocal) {
    // stores video bid vast as local blob in the browser
    (0,_videoCache_js__WEBPACK_IMPORTED_MODULE_15__.storeLocally)(bidResponse);
  } else if (cacheUrl && (useCacheKey || context !== _video_js__WEBPACK_IMPORTED_MODULE_16__.OUTSTREAM)) {
    if (!bidResponse.videoCacheKey || ignoreBidderCacheKey) {
      addBid = false;
      callPrebidCache(auctionInstance, bidResponse, afterBidAdded, videoMediaType);
    } else if (!bidResponse.vastUrl) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logError)('videoCacheKey specified but not required vastUrl for video bid');
      addBid = false;
    }
  }
  if (addBid) {
    addBidToAuction(auctionInstance, bidResponse);
    afterBidAdded();
  }
}
const callPrebidCache = (0,_hook_js__WEBPACK_IMPORTED_MODULE_11__.hook)('async', function (auctionInstance, bidResponse, afterBidAdded, videoMediaType) {
  if (true) {
    (0,_videoCache_js__WEBPACK_IMPORTED_MODULE_15__.batchAndStore)(auctionInstance, bidResponse, afterBidAdded);
  }
}, 'callPrebidCache');

/**
 * Augment `bidResponse` with properties that are common across all bids - including rejected bids.
 *
 */
function addCommonResponseProperties(bidResponse, adUnitCode) {
  let {
    index = _auctionManager_js__WEBPACK_IMPORTED_MODULE_12__.auctionManager.index
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const bidderRequest = index.getBidderRequest(bidResponse);
  const adUnit = index.getAdUnit(bidResponse);
  const start = bidderRequest && bidderRequest.start || bidResponse.requestTimestamp;
  Object.assign(bidResponse, {
    responseTimestamp: bidResponse.responseTimestamp || (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.timestamp)(),
    requestTimestamp: bidResponse.requestTimestamp || start,
    cpm: parseFloat(bidResponse.cpm) || 0,
    bidder: bidResponse.bidder || bidResponse.bidderCode,
    adUnitCode
  });
  if (adUnit?.ttlBuffer != null) {
    bidResponse.ttlBuffer = adUnit.ttlBuffer;
  }
  bidResponse.timeToRespond = bidResponse.responseTimestamp - bidResponse.requestTimestamp;
}

/**
 * Add additional bid response properties that are universal for all _accepted_ bids.
 */
function getPreparedBidForAuction(bid) {
  let {
    index = _auctionManager_js__WEBPACK_IMPORTED_MODULE_12__.auctionManager.index
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // Let listeners know that now is the time to adjust the bid, if they want to.
  //
  // CAREFUL: Publishers rely on certain bid properties to be available (like cpm),
  // but others to not be set yet (like priceStrings). See #1372 and #1389.
  _events_js__WEBPACK_IMPORTED_MODULE_1__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_2__.EVENTS.BID_ADJUSTMENT, bid);
  const adUnit = index.getAdUnit(bid);
  bid.instl = adUnit?.ortb2Imp?.instl === 1;

  // a publisher-defined renderer can be used to render bids
  const bidRenderer = index.getBidRequest(bid)?.renderer || adUnit.renderer;

  // a publisher can also define a renderer for a mediaType
  const bidObjectMediaType = bid.mediaType;
  const mediaTypes = index.getMediaTypes(bid);
  const bidMediaType = mediaTypes && mediaTypes[bidObjectMediaType];
  var mediaTypeRenderer = bidMediaType && bidMediaType.renderer;
  var renderer = null;

  // the renderer for the mediaType takes precendence
  if (mediaTypeRenderer && mediaTypeRenderer.render && !(mediaTypeRenderer.backupOnly === true && bid.renderer)) {
    renderer = mediaTypeRenderer;
  } else if (bidRenderer && bidRenderer.render && !(bidRenderer.backupOnly === true && bid.renderer)) {
    renderer = bidRenderer;
  }
  if (renderer) {
    // be aware, an adapter could already have installed the bidder, in which case this overwrite's the existing adapter
    bid.renderer = _Renderer_js__WEBPACK_IMPORTED_MODULE_17__.Renderer.install({
      url: renderer.url,
      config: renderer.options,
      renderNow: renderer.url == null
    }); // rename options to config, to make it consistent?
    bid.renderer.setRender(renderer.render);
  }

  // Use the config value 'mediaTypeGranularity' if it has been defined for mediaType, else use 'customPriceBucket'
  const mediaTypeGranularity = getMediaTypeGranularity(bid.mediaType, mediaTypes, _config_js__WEBPACK_IMPORTED_MODULE_10__.config.getConfig('mediaTypePriceGranularity'));
  const priceStringsObj = (0,_cpmBucketManager_js__WEBPACK_IMPORTED_MODULE_18__.getPriceBucketString)(bid.cpm, typeof mediaTypeGranularity === 'object' ? mediaTypeGranularity : _config_js__WEBPACK_IMPORTED_MODULE_10__.config.getConfig('customPriceBucket'), _config_js__WEBPACK_IMPORTED_MODULE_10__.config.getConfig('currency.granularityMultiplier'));
  bid.pbLg = priceStringsObj.low;
  bid.pbMg = priceStringsObj.med;
  bid.pbHg = priceStringsObj.high;
  bid.pbAg = priceStringsObj.auto;
  bid.pbDg = priceStringsObj.dense;
  bid.pbCg = priceStringsObj.custom;
  return bid;
}
function setupBidTargeting(bidObject) {
  let keyValues;
  const cpmCheck = _bidderSettings_js__WEBPACK_IMPORTED_MODULE_19__.bidderSettings.get(bidObject.bidderCode, 'allowZeroCpmBids') === true ? bidObject.cpm >= 0 : bidObject.cpm > 0;
  if (bidObject.bidderCode && (cpmCheck || bidObject.dealId)) {
    keyValues = getKeyValueTargetingPairs(bidObject.bidderCode, bidObject);
  }

  // use any targeting provided as defaults, otherwise just set from getKeyValueTargetingPairs
  bidObject.adserverTargeting = Object.assign(bidObject.adserverTargeting || {}, keyValues);
}

/**
 * @param {MediaType} mediaType
 * @param mediaTypes media types map from adUnit
 * @param {MediaTypePriceGranularity} [mediaTypePriceGranularity]
 * @returns {(Object|string|undefined)}
 */
function getMediaTypeGranularity(mediaType, mediaTypes, mediaTypePriceGranularity) {
  if (mediaType && mediaTypePriceGranularity) {
    if ( true && mediaType === _mediaTypes_js__WEBPACK_IMPORTED_MODULE_13__.VIDEO) {
      const context = mediaTypes?.[_mediaTypes_js__WEBPACK_IMPORTED_MODULE_13__.VIDEO]?.context ?? 'instream';
      if (mediaTypePriceGranularity[`${_mediaTypes_js__WEBPACK_IMPORTED_MODULE_13__.VIDEO}-${context}`]) {
        return mediaTypePriceGranularity[`${_mediaTypes_js__WEBPACK_IMPORTED_MODULE_13__.VIDEO}-${context}`];
      }
    }
    return mediaTypePriceGranularity[mediaType];
  }
}

/**
 * This function returns the price granularity defined. It can be either publisher defined or default value
 * @param {Bid} bid bid response object
 * @param {object} obj
 * @param {object} obj.index
 * @returns {string} granularity
 */
const getPriceGranularity = function (bid) {
  let {
    index = _auctionManager_js__WEBPACK_IMPORTED_MODULE_12__.auctionManager.index
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // Use the config value 'mediaTypeGranularity' if it has been set for mediaType, else use 'priceGranularity'
  const mediaTypeGranularity = getMediaTypeGranularity(bid.mediaType, index.getMediaTypes(bid), _config_js__WEBPACK_IMPORTED_MODULE_10__.config.getConfig('mediaTypePriceGranularity'));
  const granularity = typeof bid.mediaType === 'string' && mediaTypeGranularity ? typeof mediaTypeGranularity === 'string' ? mediaTypeGranularity : 'custom' : _config_js__WEBPACK_IMPORTED_MODULE_10__.config.getConfig('priceGranularity');
  return granularity;
};

/**
 * This function returns a function to get bid price by price granularity
 * @param {string} granularity
 * @returns {function}
 */
const getPriceByGranularity = granularity => {
  return bid => {
    const bidGranularity = granularity || getPriceGranularity(bid);
    if (bidGranularity === _constants_js__WEBPACK_IMPORTED_MODULE_2__.GRANULARITY_OPTIONS.AUTO) {
      return bid.pbAg;
    } else if (bidGranularity === _constants_js__WEBPACK_IMPORTED_MODULE_2__.GRANULARITY_OPTIONS.DENSE) {
      return bid.pbDg;
    } else if (bidGranularity === _constants_js__WEBPACK_IMPORTED_MODULE_2__.GRANULARITY_OPTIONS.LOW) {
      return bid.pbLg;
    } else if (bidGranularity === _constants_js__WEBPACK_IMPORTED_MODULE_2__.GRANULARITY_OPTIONS.MEDIUM) {
      return bid.pbMg;
    } else if (bidGranularity === _constants_js__WEBPACK_IMPORTED_MODULE_2__.GRANULARITY_OPTIONS.HIGH) {
      return bid.pbHg;
    } else if (bidGranularity === _constants_js__WEBPACK_IMPORTED_MODULE_2__.GRANULARITY_OPTIONS.CUSTOM) {
      return bid.pbCg;
    }
  };
};

/**
 * This function returns a function to get crid from bid response
 * @returns {function}
 */
const getCreativeId = () => {
  return bid => {
    return bid.creativeId ? bid.creativeId : '';
  };
};

/**
 * This function returns a function to get first advertiser domain from bid response meta
 * @returns {function}
 */
const getAdvertiserDomain = () => {
  return bid => {
    return bid.meta && bid.meta.advertiserDomains && bid.meta.advertiserDomains.length > 0 ? [bid.meta.advertiserDomains].flat()[0] : '';
  };
};

/**
 * This function returns a function to get dsp name or id from bid response meta
 * @returns {function}
 */
const getDSP = () => {
  return bid => {
    return bid.meta && (bid.meta.networkId || bid.meta.networkName) ? bid?.meta?.networkName || bid?.meta?.networkId : '';
  };
};

/**
 * This function returns a function to get the primary category id from bid response meta
 * @returns {function}
 */
const getPrimaryCatId = () => {
  return bid => {
    const catId = bid?.meta?.primaryCatId;
    if (Array.isArray(catId)) {
      return catId[0] || '';
    }
    return catId || '';
  };
};

// factory for key value objs
function createKeyVal(key, value) {
  return {
    key,
    val: typeof value === 'function' ? function (bidResponse, bidReq) {
      return value(bidResponse, bidReq);
    } : function (bidResponse) {
      return bidResponse[value];
    }
  };
}
function defaultAdserverTargeting() {
  return [createKeyVal(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.BIDDER, 'bidderCode'), createKeyVal(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.AD_ID, 'adId'), createKeyVal(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.PRICE_BUCKET, getPriceByGranularity()), createKeyVal(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.SIZE, 'size'), createKeyVal(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.DEAL, 'dealId'), createKeyVal(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.SOURCE, 'source'), createKeyVal(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.FORMAT, 'mediaType'), createKeyVal(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.ADOMAIN, getAdvertiserDomain()), createKeyVal(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.ACAT, getPrimaryCatId()), createKeyVal(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.DSP, getDSP()), createKeyVal(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.CRID, getCreativeId())];
}

/**
 * @param {string} mediaType
 * @param {string} bidderCode
 * @returns {*}
 */
function getStandardBidderSettings(mediaType, bidderCode) {
  const standardSettings = Object.assign({}, _bidderSettings_js__WEBPACK_IMPORTED_MODULE_19__.bidderSettings.settingsFor(null));
  if (!standardSettings[_constants_js__WEBPACK_IMPORTED_MODULE_2__.JSON_MAPPING.ADSERVER_TARGETING]) {
    standardSettings[_constants_js__WEBPACK_IMPORTED_MODULE_2__.JSON_MAPPING.ADSERVER_TARGETING] = defaultAdserverTargeting();
  }
  if ( true && mediaType === 'video') {
    const adserverTargeting = standardSettings[_constants_js__WEBPACK_IMPORTED_MODULE_2__.JSON_MAPPING.ADSERVER_TARGETING].slice();
    standardSettings[_constants_js__WEBPACK_IMPORTED_MODULE_2__.JSON_MAPPING.ADSERVER_TARGETING] = adserverTargeting;

    // Adding hb_uuid + hb_cache_id
    [_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.UUID, _constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.CACHE_ID].forEach(targetingKeyVal => {
      if (typeof adserverTargeting.find(kvPair => kvPair.key === targetingKeyVal) === 'undefined') {
        adserverTargeting.push(createKeyVal(targetingKeyVal, 'videoCacheKey'));
      }
    });

    // Adding hb_cache_host
    if (_config_js__WEBPACK_IMPORTED_MODULE_10__.config.getConfig('cache.url') && (!bidderCode || _bidderSettings_js__WEBPACK_IMPORTED_MODULE_19__.bidderSettings.get(bidderCode, 'sendStandardTargeting') !== false)) {
      const urlInfo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.parseUrl)(_config_js__WEBPACK_IMPORTED_MODULE_10__.config.getConfig('cache.url'));
      if (typeof adserverTargeting.find(targetingKeyVal => targetingKeyVal.key === _constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.CACHE_HOST) === 'undefined') {
        adserverTargeting.push(createKeyVal(_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.CACHE_HOST, function (bidResponse) {
          return bidResponse?.adserverTargeting?.[_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.CACHE_HOST] || urlInfo.hostname;
        }));
      }
    }
  }
  return standardSettings;
}
function getKeyValueTargetingPairs(bidderCode, custBidObj) {
  let {
    index = _auctionManager_js__WEBPACK_IMPORTED_MODULE_12__.auctionManager.index
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (!custBidObj) {
    return {};
  }
  const bidRequest = index.getBidRequest(custBidObj);
  var keyValues = {};

  // 1) set the keys from "standard" setting or from prebid defaults
  // initialize default if not set
  const standardSettings = getStandardBidderSettings(custBidObj.mediaType, bidderCode);
  setKeys(keyValues, standardSettings, custBidObj, bidRequest);

  // 2) set keys from specific bidder setting override if they exist
  if (bidderCode && _bidderSettings_js__WEBPACK_IMPORTED_MODULE_19__.bidderSettings.getOwn(bidderCode, _constants_js__WEBPACK_IMPORTED_MODULE_2__.JSON_MAPPING.ADSERVER_TARGETING)) {
    setKeys(keyValues, _bidderSettings_js__WEBPACK_IMPORTED_MODULE_19__.bidderSettings.ownSettingsFor(bidderCode), custBidObj, bidRequest);
    custBidObj.sendStandardTargeting = _bidderSettings_js__WEBPACK_IMPORTED_MODULE_19__.bidderSettings.get(bidderCode, 'sendStandardTargeting');
  }

  // set native key value targeting
  if ( true && custBidObj['native']) {
    keyValues = Object.assign({}, keyValues, (0,_native_js__WEBPACK_IMPORTED_MODULE_14__.getNativeTargeting)(custBidObj));
  }
  return keyValues;
}
function setKeys(keyValues, bidderSettings, custBidObj, bidReq) {
  var targeting = bidderSettings[_constants_js__WEBPACK_IMPORTED_MODULE_2__.JSON_MAPPING.ADSERVER_TARGETING];
  custBidObj.size = custBidObj.getSize();
  (targeting || []).forEach(function (kvPair) {
    var key = kvPair.key;
    var value = kvPair.val;
    if (keyValues[key]) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logWarn)('The key: ' + key + ' is being overwritten');
    }
    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isFn)(value)) {
      try {
        value = value(custBidObj, bidReq);
      } catch (e) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logError)('bidmanager', 'ERROR', e);
      }
    }
    if ((typeof bidderSettings.suppressEmptyKeys !== 'undefined' && bidderSettings.suppressEmptyKeys === true || key === _constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.DEAL || key === _constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.ACAT || key === _constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.DSP || key === _constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.CRID) && (
    // hb_deal & hb_acat are suppressed automatically if not set

    (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isEmptyStr)(value) || value === null || value === undefined)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.logInfo)("suppressing empty key '" + key + "' from adserver targeting");
    } else {
      keyValues[key] = value;
    }
  });
  return keyValues;
}
function adjustBids(bid) {
  let bidPriceAdjusted = (0,_utils_cpm_js__WEBPACK_IMPORTED_MODULE_20__.adjustCpm)(bid.cpm, bid);
  if (bidPriceAdjusted >= 0) {
    bid.cpm = bidPriceAdjusted;
  }
}

/**
 * groupByPlacement is a reduce function that converts an array of Bid objects
 * to an object with placement codes as keys, with each key representing an object
 * with an array of `Bid` objects for that placement
 * @returns {*} as { [adUnitCode]: { bids: [Bid, Bid, Bid] } }
 */
function groupByPlacement(bidsByPlacement, bid) {
  if (!bidsByPlacement[bid.adUnitCode]) {
    bidsByPlacement[bid.adUnitCode] = {
      bids: []
    };
  }
  bidsByPlacement[bid.adUnitCode].bids.push(bid);
  return bidsByPlacement;
}

/**
 * isValidPrice is price validation function
 * which checks if price from bid response
 * is not higher than top limit set in config
 * @type {Function}
 * @param bid
 * @returns {boolean}
 */
function isValidPrice(bid) {
  const maxBidValue = _config_js__WEBPACK_IMPORTED_MODULE_10__.config.getConfig('maxBid');
  if (!maxBidValue || !bid.cpm) return true;
  return maxBidValue >= Number(bid.cpm);
}

/***/ }),

/***/ "./src/auctionIndex.js":
/*!*****************************!*\
  !*** ./src/auctionIndex.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuctionIndex: () => (/* binding */ AuctionIndex)
/* harmony export */ });
/**
 * @typedef {Object} AuctionIndex
 *
 * @property {function({ auctionId: * }): *} getAuction Returns auction instance for `auctionId`
 * @property {function({ adUnitId: * }): *} getAdUnit Returns `adUnit` object for `transactionId`.
 * You should prefer `getMediaTypes` for looking up bid media types.
 * @property {function({ adUnitId: *, requestId: * }): *} getMediaTypes Returns mediaTypes object from bidRequest (through `requestId`) falling back to the adUnit (through `transactionId`).
 * The bidRequest is given precedence because its mediaTypes can differ from the adUnit's (if bidder-specific labels are in use).
 * Bids that have no associated request do not have labels either, and use the adUnit's mediaTypes.
 * @property {function({ requestId: *, bidderRequestId: * }): *} getBidderRequest Returns bidderRequest that matches both requestId and bidderRequestId (if either or both are provided).
 * Bid responses are not guaranteed to have a corresponding request.
 * @property {function({ requestId: * }): *} getBidRequest Returns bidRequest object for requestId.
 * Bid responses are not guaranteed to have a corresponding request.
 */

/**
 * Retrieves request-related bid data.
 * All methods are designed to work with Bid (response) objects returned by bid adapters.
 */
function AuctionIndex(getAuctions) {
  Object.assign(this, {
    getAuction(_ref) {
      let {
        auctionId
      } = _ref;
      if (auctionId != null) {
        return getAuctions().find(auction => auction.getAuctionId() === auctionId);
      }
    },
    getAdUnit(_ref2) {
      let {
        adUnitId
      } = _ref2;
      if (adUnitId != null) {
        return getAuctions().flatMap(a => a.getAdUnits()).find(au => au.adUnitId === adUnitId);
      }
    },
    getMediaTypes(_ref3) {
      let {
        adUnitId,
        requestId
      } = _ref3;
      if (requestId != null) {
        const req = this.getBidRequest({
          requestId
        });
        if (req != null && (adUnitId == null || req.adUnitId === adUnitId)) {
          return req.mediaTypes;
        }
      } else if (adUnitId != null) {
        const au = this.getAdUnit({
          adUnitId
        });
        if (au != null) {
          return au.mediaTypes;
        }
      }
    },
    getBidderRequest(_ref4) {
      let {
        requestId,
        bidderRequestId
      } = _ref4;
      if (requestId != null || bidderRequestId != null) {
        let bers = getAuctions().flatMap(a => a.getBidRequests());
        if (bidderRequestId != null) {
          bers = bers.filter(ber => ber.bidderRequestId === bidderRequestId);
        }
        if (requestId == null) {
          return bers[0];
        } else {
          return bers.find(ber => ber.bids && ber.bids.find(br => br.bidId === requestId) != null);
        }
      }
    },
    getBidRequest(_ref5) {
      let {
        requestId
      } = _ref5;
      if (requestId != null) {
        return getAuctions().flatMap(a => a.getBidRequests()).flatMap(ber => ber.bids).find(br => br && br.bidId === requestId);
      }
    },
    getOrtb2(bid) {
      return this.getBidderRequest(bid)?.ortb2 || this.getAuction(bid)?.getFPD()?.global?.ortb2;
    }
  });
}

/***/ }),

/***/ "./src/auctionManager.js":
/*!*******************************!*\
  !*** ./src/auctionManager.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   auctionManager: () => (/* binding */ auctionManager)
/* harmony export */ });
/* unused harmony export newAuctionManager */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _auction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./auction.js */ "./src/auction.js");
/* harmony import */ var _auctionIndex_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./auctionIndex.js */ "./src/auctionIndex.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants.js */ "./src/constants.js");
/* harmony import */ var _utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/perfMetrics.js */ "./src/utils/perfMetrics.js");
/* harmony import */ var _utils_ttlCollection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/ttlCollection.js */ "./src/utils/ttlCollection.js");
/* harmony import */ var _bidTTL_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bidTTL.js */ "./src/bidTTL.js");
/**
 * AuctionManager modules is responsible for creating auction instances.
 * This module is the gateway for Prebid core to access auctions.
 * It stores all created instances of auction and can be used to get consolidated values from auction.
 */

/**
 * @typedef {Object} AuctionManager
 *
 * @property {function(): Array} getBidsRequested - returns consolidated bid requests
 * @property {function(): Array} getBidsReceived - returns consolidated bid received
 * @property {function(): Array} getAllBidsForAdUnitCode - returns consolidated bid received for a given adUnit
 * @property {function(): Array} getAdUnits - returns consolidated adUnits
 * @property {function(): Array} getAdUnitCodes - returns consolidated adUnitCodes
 * @property {function(): Object} createAuction - creates auction instance and stores it for future reference
 * @property {function(): Object} findBidByAdId - find bid received by adId. This function will be called by $$PREBID_GLOBAL$$.renderAd
 * @property {function(): Object} getStandardBidderAdServerTargeting - returns standard bidder targeting for all the adapters. Refer http://prebid.org/dev-docs/publisher-api-reference.html#module_pbjs.bidderSettings for more details
 * @property {function(Object): void} addWinningBid - add a winning bid to an auction based on auctionId
 * @property {function(): void} clearAllAuctions - clear all auctions for testing
 * @property {AuctionIndex} index
 */









/**
 * Creates new instance of auctionManager. There will only be one instance of auctionManager but
 * a factory is created to assist in testing.
 *
 * @returns {AuctionManager} auctionManagerInstance
 */
function newAuctionManager() {
  const _auctions = (0,_utils_ttlCollection_js__WEBPACK_IMPORTED_MODULE_0__.ttlCollection)({
    startTime: au => au.end.then(() => au.getAuctionEnd()),
    ttl: au => (0,_bidTTL_js__WEBPACK_IMPORTED_MODULE_1__.getMinBidCacheTTL)() == null ? null : au.end.then(() => {
      return Math.max((0,_bidTTL_js__WEBPACK_IMPORTED_MODULE_1__.getMinBidCacheTTL)(), ...au.getBidsReceived().map(bid => bid.ttl)) * 1000;
    })
  });
  (0,_bidTTL_js__WEBPACK_IMPORTED_MODULE_1__.onMinBidCacheTTLChange)(() => _auctions.refresh());
  const auctionManager = {
    onExpiry: _auctions.onExpiry
  };
  function getAuction(auctionId) {
    for (const auction of _auctions) {
      if (auction.getAuctionId() === auctionId) return auction;
    }
  }
  auctionManager.addWinningBid = function (bid) {
    const metrics = (0,_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_2__.useMetrics)(bid.metrics);
    metrics.checkpoint('bidWon');
    metrics.timeBetween('auctionEnd', 'bidWon', 'adserver.pending');
    metrics.timeBetween('requestBids', 'bidWon', 'adserver.e2e');
    const auction = getAuction(bid.auctionId);
    if (auction) {
      auction.addWinningBid(bid);
    } else {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(`Auction not found when adding winning bid`);
    }
  };
  Object.entries({
    getAllWinningBids: {
      name: 'getWinningBids'
    },
    getBidsRequested: {
      name: 'getBidRequests'
    },
    getNoBids: {},
    getAdUnits: {},
    getBidsReceived: {
      pre(auction) {
        return auction.getAuctionStatus() === _auction_js__WEBPACK_IMPORTED_MODULE_4__.AUCTION_COMPLETED;
      }
    },
    getAdUnitCodes: {
      post: _utils_js__WEBPACK_IMPORTED_MODULE_3__.uniques
    }
  }).forEach(_ref => {
    let [mgrMethod, {
      name = mgrMethod,
      pre,
      post
    }] = _ref;
    const mapper = pre == null ? auction => auction[name]() : auction => pre(auction) ? auction[name]() : [];
    const filter = post == null ? items => items : items => items.filter(post);
    auctionManager[mgrMethod] = () => {
      return filter(_auctions.toArray().flatMap(mapper));
    };
  });
  function allBidsReceived() {
    return _auctions.toArray().flatMap(au => au.getBidsReceived());
  }
  auctionManager.getAllBidsForAdUnitCode = function (adUnitCode) {
    return allBidsReceived().filter(bid => bid && bid.adUnitCode === adUnitCode);
  };
  auctionManager.createAuction = function (opts) {
    const auction = (0,_auction_js__WEBPACK_IMPORTED_MODULE_4__.newAuction)(opts);
    _addAuction(auction);
    return auction;
  };
  auctionManager.findBidByAdId = function (adId) {
    return allBidsReceived().find(bid => bid.adId === adId);
  };
  auctionManager.getStandardBidderAdServerTargeting = function () {
    return (0,_auction_js__WEBPACK_IMPORTED_MODULE_4__.getStandardBidderSettings)()[_constants_js__WEBPACK_IMPORTED_MODULE_5__.JSON_MAPPING.ADSERVER_TARGETING];
  };
  auctionManager.setStatusForBids = function (adId, status) {
    let bid = auctionManager.findBidByAdId(adId);
    if (bid) bid.status = status;
    if (bid && status === _constants_js__WEBPACK_IMPORTED_MODULE_5__.BID_STATUS.BID_TARGETING_SET) {
      const auction = getAuction(bid.auctionId);
      if (auction) auction.setBidTargeting(bid);
    }
  };
  auctionManager.getLastAuctionId = function () {
    const auctions = _auctions.toArray();
    return auctions.length && auctions[auctions.length - 1].getAuctionId();
  };
  auctionManager.clearAllAuctions = function () {
    _auctions.clear();
  };
  function _addAuction(auction) {
    _auctions.add(auction);
  }
  auctionManager.index = new _auctionIndex_js__WEBPACK_IMPORTED_MODULE_6__.AuctionIndex(() => _auctions.toArray());
  return auctionManager;
}
const auctionManager = newAuctionManager();

/***/ }),

/***/ "./src/banner.js":
/*!***********************!*\
  !*** ./src/banner.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ORTB_BANNER_PARAMS: () => (/* binding */ ORTB_BANNER_PARAMS)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");


/**
 * List of OpenRTB 2.x banner object properties with simple validators.
 * Not included: `ext`
 * reference: https://github.com/InteractiveAdvertisingBureau/openrtb2.x/blob/main/2.6.md
 */
const ORTB_BANNER_PARAMS = new Map([['format', value => Array.isArray(value) && value.length > 0 && value.every(v => typeof v === 'object')], ['w', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['h', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['btype', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isArrayOfNums], ['battr', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isArrayOfNums], ['pos', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['mimes', value => Array.isArray(value) && value.length > 0 && value.every(v => typeof v === 'string')], ['topframe', value => [1, 0].includes(value)], ['expdir', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isArrayOfNums], ['api', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isArrayOfNums], ['id', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr], ['vcm', value => [1, 0].includes(value)]]);

/***/ }),

/***/ "./src/bidTTL.js":
/*!***********************!*\
  !*** ./src/bidTTL.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getBufferedTTL: () => (/* binding */ getBufferedTTL),
/* harmony export */   getMinBidCacheTTL: () => (/* binding */ getMinBidCacheTTL),
/* harmony export */   onMinBidCacheTTLChange: () => (/* binding */ onMinBidCacheTTLChange)
/* harmony export */ });
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ "./src/config.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");


const CACHE_TTL_SETTING = 'minBidCacheTTL';
let TTL_BUFFER = 1;
let minCacheTTL = null;
const listeners = [];
_config_js__WEBPACK_IMPORTED_MODULE_0__.config.getConfig('ttlBuffer', cfg => {
  if (typeof cfg.ttlBuffer === 'number') {
    TTL_BUFFER = cfg.ttlBuffer;
  } else {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)('Invalid value for ttlBuffer', cfg.ttlBuffer);
  }
});
function getBufferedTTL(bid) {
  return bid.ttl - (bid.hasOwnProperty('ttlBuffer') ? bid.ttlBuffer : TTL_BUFFER);
}
function getMinBidCacheTTL() {
  return minCacheTTL;
}
_config_js__WEBPACK_IMPORTED_MODULE_0__.config.getConfig(CACHE_TTL_SETTING, cfg => {
  const prev = minCacheTTL;
  minCacheTTL = cfg?.[CACHE_TTL_SETTING];
  minCacheTTL = typeof minCacheTTL === 'number' ? minCacheTTL : null;
  if (prev !== minCacheTTL) {
    listeners.forEach(l => l(minCacheTTL));
  }
});
function onMinBidCacheTTLChange(listener) {
  listeners.push(listener);
}

/***/ }),

/***/ "./src/bidderSettings.js":
/*!*******************************!*\
  !*** ./src/bidderSettings.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bidderSettings: () => (/* binding */ bidderSettings)
/* harmony export */ });
/* unused harmony export ScopedSettings */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _prebidGlobal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ "./src/constants.js");



class ScopedSettings {
  constructor(getSettings, defaultScope) {
    this.getSettings = getSettings;
    this.defaultScope = defaultScope;
  }

  /**
   * Get setting value at `path` under the given scope, falling back to the default scope if needed.
   * If `scope` is `null`, get the setting's default value.
   * @param scope {String|null}
   * @param path {String}
   * @returns {*}
   */
  get(scope, path) {
    let value = this.getOwn(scope, path);
    if (typeof value === 'undefined') {
      value = this.getOwn(null, path);
    }
    return value;
  }

  /**
   * Get the setting value at `path` *without* falling back to the default value.
   * @param scope {String}
   * @param path {String}
   * @returns {*}
   */
  getOwn(scope, path) {
    scope = this.#resolveScope(scope);
    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this.getSettings(), `${scope}.${path}`);
  }

  /**
   * @returns {string[]} all existing scopes except the default one.
   */
  getScopes() {
    return Object.keys(this.getSettings()).filter(scope => scope !== this.defaultScope);
  }

  /**
   * @returns all settings in the given scope, merged with the settings for the default scope.
   */
  settingsFor(scope) {
    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeep)({}, this.ownSettingsFor(null), this.ownSettingsFor(scope));
  }

  /**
   * @returns all settings in the given scope, *without* any of the default settings.
   */
  ownSettingsFor(scope) {
    scope = this.#resolveScope(scope);
    return this.getSettings()[scope] || {};
  }
  #resolveScope(scope) {
    if (scope == null) {
      return this.defaultScope;
    } else {
      return scope;
    }
  }
}
const bidderSettings = new ScopedSettings(() => (0,_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_2__.getGlobal)().bidderSettings || {}, _constants_js__WEBPACK_IMPORTED_MODULE_3__.JSON_MAPPING.BD_SETTING_STANDARD);

/***/ }),

/***/ "./src/bidfactory.js":
/*!***************************!*\
  !*** ./src/bidfactory.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createBid: () => (/* binding */ createBid)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");


/**
 Required paramaters
 bidderCode,
 height,
 width,
 statusCode
 Optional paramaters
 adId,
 cpm,
 ad,
 adUrl,
 dealId,
 priceKeyString;
 */
function Bid(statusCode) {
  let {
    src = 'client',
    bidder = '',
    bidId,
    transactionId,
    adUnitId,
    auctionId
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _bidSrc = src;
  var _statusCode = statusCode || 0;
  Object.assign(this, {
    bidderCode: bidder,
    width: 0,
    height: 0,
    statusMessage: _getStatus(),
    adId: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getUniqueIdentifierStr)(),
    requestId: bidId,
    transactionId,
    adUnitId,
    auctionId,
    mediaType: 'banner',
    source: _bidSrc
  });
  function _getStatus() {
    switch (_statusCode) {
      case 0:
        return 'Pending';
      case 1:
        return 'Bid available';
      case 2:
        return 'Bid returned empty or error response';
      case 3:
        return 'Bid timed out';
    }
  }
  this.getStatusCode = function () {
    return _statusCode;
  };

  // returns the size of the bid creative. Concatenation of width and height by ‘x’.
  this.getSize = function () {
    return this.width + 'x' + this.height;
  };
  this.getIdentifiers = function () {
    return {
      src: this.source,
      bidder: this.bidderCode,
      bidId: this.requestId,
      transactionId: this.transactionId,
      adUnitId: this.adUnitId,
      auctionId: this.auctionId
    };
  };
}

// Bid factory function.
function createBid(statusCode, identifiers) {
  return new Bid(statusCode, identifiers);
}

/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RANDOM: () => (/* binding */ RANDOM),
/* harmony export */   config: () => (/* binding */ config)
/* harmony export */ });
/* unused harmony export newConfig */
/* harmony import */ var _cpmBucketManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cpmBucketManager.js */ "./src/cpmBucketManager.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ "./src/constants.js");
/*
 * Module for getting and setting Prebid configuration.
*/

/**
 * @typedef {Object} MediaTypePriceGranularity
 *
 * @property {(string|Object)} [banner]
 * @property {(string|Object)} [native]
 * @property {(string|Object)} [video]
 * @property {(string|Object)} [video-instream]
 * @property {(string|Object)} [video-outstream]
 */




const DEFAULT_DEBUG = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getParameterByName)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_MODE).toUpperCase() === 'TRUE';
const DEFAULT_BIDDER_TIMEOUT = 3000;
const DEFAULT_ENABLE_SEND_ALL_BIDS = true;
const DEFAULT_DISABLE_AJAX_TIMEOUT = false;
const DEFAULT_BID_CACHE = false;
const DEFAULT_DEVICE_ACCESS = true;
const DEFAULT_MAX_NESTED_IFRAMES = 10;
const DEFAULT_MAXBID_VALUE = 5000;
const DEFAULT_IFRAMES_CONFIG = {};
const RANDOM = 'random';
const FIXED = 'fixed';
const VALID_ORDERS = {};
VALID_ORDERS[RANDOM] = true;
VALID_ORDERS[FIXED] = true;
const DEFAULT_BIDDER_SEQUENCE = RANDOM;
const GRANULARITY_OPTIONS = {
  LOW: 'low',
  MEDIUM: 'medium',
  HIGH: 'high',
  AUTO: 'auto',
  DENSE: 'dense',
  CUSTOM: 'custom'
};
const ALL_TOPICS = '*';
function attachProperties(config) {
  let useDefaultValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  const values = useDefaultValues ? {
    priceGranularity: GRANULARITY_OPTIONS.MEDIUM,
    customPriceBucket: {},
    mediaTypePriceGranularity: {},
    bidderSequence: DEFAULT_BIDDER_SEQUENCE,
    auctionOptions: {}
  } : {};
  function getProp(name) {
    return values[name];
  }
  function setProp(name, val) {
    if (!values.hasOwnProperty(name)) {
      Object.defineProperty(config, name, {
        enumerable: true
      });
    }
    values[name] = val;
  }
  const props = {
    publisherDomain: {
      set(val) {
        if (val != null) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)('publisherDomain is deprecated and has no effect since v7 - use pageUrl instead');
        }
        setProp('publisherDomain', val);
      }
    },
    priceGranularity: {
      set(val) {
        if (validatePriceGranularity(val)) {
          if (typeof val === 'string') {
            setProp('priceGranularity', hasGranularity(val) ? val : GRANULARITY_OPTIONS.MEDIUM);
          } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val)) {
            setProp('customPriceBucket', val);
            setProp('priceGranularity', GRANULARITY_OPTIONS.CUSTOM);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logMessage)('Using custom price granularity');
          }
        }
      }
    },
    customPriceBucket: {},
    mediaTypePriceGranularity: {
      set(val) {
        val != null && setProp('mediaTypePriceGranularity', Object.keys(val).reduce((aggregate, item) => {
          if (validatePriceGranularity(val[item])) {
            if (typeof val === 'string') {
              aggregate[item] = hasGranularity(val[item]) ? val[item] : getProp('priceGranularity');
            } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val)) {
              aggregate[item] = val[item];
              (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logMessage)(`Using custom price granularity for ${item}`);
            }
          } else {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)(`Invalid price granularity for media type: ${item}`);
          }
          return aggregate;
        }, {}));
      }
    },
    bidderSequence: {
      set(val) {
        if (VALID_ORDERS[val]) {
          setProp('bidderSequence', val);
        } else {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)(`Invalid order: ${val}. Bidder Sequence was not set.`);
        }
      }
    },
    auctionOptions: {
      set(val) {
        if (validateauctionOptions(val)) {
          setProp('auctionOptions', val);
        }
      }
    }
  };
  Object.defineProperties(config, Object.fromEntries(Object.entries(props).map(_ref => {
    let [k, def] = _ref;
    return [k, Object.assign({
      get: getProp.bind(null, k),
      set: setProp.bind(null, k),
      enumerable: values.hasOwnProperty(k),
      configurable: !values.hasOwnProperty(k)
    }, def)];
  })));
  return config;
  function hasGranularity(val) {
    return Object.keys(GRANULARITY_OPTIONS).find(option => val === GRANULARITY_OPTIONS[option]);
  }
  function validatePriceGranularity(val) {
    if (!val) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError)('Prebid Error: no value passed to `setPriceGranularity()`');
      return false;
    }
    if (typeof val === 'string') {
      if (!hasGranularity(val)) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)('Prebid Warning: setPriceGranularity was called with invalid setting, using `medium` as default.');
      }
    } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val)) {
      if (!(0,_cpmBucketManager_js__WEBPACK_IMPORTED_MODULE_2__.isValidPriceConfig)(val)) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError)('Invalid custom price value passed to `setPriceGranularity()`');
        return false;
      }
    }
    return true;
  }
  function validateauctionOptions(val) {
    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)('Auction Options must be an object');
      return false;
    }
    for (let k of Object.keys(val)) {
      if (k !== 'secondaryBidders' && k !== 'suppressStaleRender' && k !== 'suppressExpiredRender') {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)(`Auction Options given an incorrect param: ${k}`);
        return false;
      }
      if (k === 'secondaryBidders') {
        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(val[k])) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)(`Auction Options ${k} must be of type Array`);
          return false;
        } else if (!val[k].every(_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr)) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)(`Auction Options ${k} must be only string`);
          return false;
        }
      } else if (k === 'suppressStaleRender' || k === 'suppressExpiredRender') {
        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(val[k])) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)(`Auction Options ${k} must be of type boolean`);
          return false;
        }
      }
    }
    return true;
  }
}
function newConfig() {
  let listeners = [];
  let defaults;
  let config;
  let bidderConfig;
  let currBidder = null;
  function resetConfig() {
    defaults = {};
    let newConfig = attachProperties({
      // `debug` is equivalent to legacy `pbjs.logging` property
      debug: DEFAULT_DEBUG,
      bidderTimeout: DEFAULT_BIDDER_TIMEOUT,
      enableSendAllBids: DEFAULT_ENABLE_SEND_ALL_BIDS,
      useBidCache: DEFAULT_BID_CACHE,
      /**
       * deviceAccess set to false will disable setCookie, getCookie, hasLocalStorage
       * @type {boolean}
       */
      deviceAccess: DEFAULT_DEVICE_ACCESS,
      disableAjaxTimeout: DEFAULT_DISABLE_AJAX_TIMEOUT,
      // default max nested iframes for referer detection
      maxNestedIframes: DEFAULT_MAX_NESTED_IFRAMES,
      // default max bid
      maxBid: DEFAULT_MAXBID_VALUE,
      userSync: {
        topics: DEFAULT_IFRAMES_CONFIG
      }
    });
    if (config) {
      callSubscribers(Object.keys(config).reduce((memo, topic) => {
        if (config[topic] !== newConfig[topic]) {
          memo[topic] = newConfig[topic] || {};
        }
        return memo;
      }, {}));
    }
    config = newConfig;
    bidderConfig = {};
  }

  /**
   * Returns base config with bidder overrides (if there is currently a bidder)
   * @private
   */
  function _getConfig() {
    if (currBidder && bidderConfig && (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(bidderConfig[currBidder])) {
      const curr = bidderConfig[currBidder];
      const topics = new Set([...Object.keys(config), ...Object.keys(curr)]);
      const merged = {};
      for (const topic of topics) {
        const base = config[topic];
        const override = curr[topic];
        merged[topic] = override === undefined ? base : base === undefined ? override : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(override) ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mergeDeep)({}, base, override) : override;
      }
      return merged;
    }
    return {
      ...config
    };
  }
  function _getRestrictedConfig() {
    // This causes reading 'ortb2' to throw an error; with prebid 7, that will almost
    // always be the incorrect way to access FPD configuration (https://github.com/prebid/Prebid.js/issues/7651)
    // code that needs the ortb2 config should explicitly use `getAnyConfig`
    // TODO: this is meant as a temporary tripwire to catch inadvertent use of `getConfig('ortb')` as we transition.
    // It should be removed once the risk of that happening is low enough.
    const conf = _getConfig();
    Object.defineProperty(conf, 'ortb2', {
      get: function () {
        throw new Error('invalid access to \'orbt2\' config - use request parameters instead');
      }
    });
    return conf;
  }
  const [getAnyConfig, getConfig] = [_getConfig, _getRestrictedConfig].map(accessor => {
    /*
     * Returns configuration object if called without parameters,
     * or single configuration property if given a string matching a configuration
     * property name.  Allows deep access e.g. getConfig('currency.adServerCurrency')
     *
     * If called with callback parameter, or a string and a callback parameter,
     * subscribes to configuration updates. See `subscribe` function for usage.
     */
    return function getConfig() {
      if (arguments.length <= 1 && typeof (arguments.length <= 0 ? undefined : arguments[0]) !== 'function') {
        const option = arguments.length <= 0 ? undefined : arguments[0];
        return option ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(accessor(), option) : _getConfig();
      }
      return subscribe(...arguments);
    };
  });
  const [readConfig, readAnyConfig] = [getConfig, getAnyConfig].map(wrapee => {
    /*
     * Like getConfig, except that it returns a deepClone of the result.
     */
    return function readConfig() {
      let res = wrapee(...arguments);
      if (res && typeof res === 'object') {
        res = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepClone)(res);
      }
      return res;
    };
  });

  /**
   * Internal API for modules (such as prebid-server) that might need access to all bidder config
   */
  function getBidderConfig() {
    return bidderConfig;
  }

  /*
   * Sets configuration given an object containing key-value pairs and calls
   * listeners that were added by the `subscribe` function
   */
  function setConfig(options) {
    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(options)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError)('setConfig options must be an object');
      return;
    }
    let topics = Object.keys(options);
    let topicalConfig = {};
    topics.forEach(topic => {
      let option = options[topic];
      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(defaults[topic]) && (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(option)) {
        option = Object.assign({}, defaults[topic], option);
      }
      try {
        topicalConfig[topic] = config[topic] = option;
      } catch (e) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)(`Cannot set config for property ${topic} : `, e);
      }
    });
    callSubscribers(topicalConfig);
  }

  /**
   * Sets configuration defaults which setConfig values can be applied on top of
   * @param {object} options
   */
  function setDefaults(options) {
    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(defaults)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError)('defaults must be an object');
      return;
    }
    Object.assign(defaults, options);
    // Add default values to config as well
    Object.assign(config, options);
  }

  /*
   * Adds a function to a set of listeners that are invoked whenever `setConfig`
   * is called. The subscribed function will be passed the options object that
   * was used in the `setConfig` call. Topics can be subscribed to to only get
   * updates when specific properties are updated by passing a topic string as
   * the first parameter.
   *
   * If `options.init` is true, the listener will be immediately called with the current options.
   *
   * Returns an `unsubscribe` function for removing the subscriber from the
   * set of listeners
   *
   * Example use:
   * // subscribe to all configuration changes
   * subscribe((config) => console.log('config set:', config));
   *
   * // subscribe to only 'logging' changes
   * subscribe('logging', (config) => console.log('logging set:', config));
   *
   * // unsubscribe
   * const unsubscribe = subscribe(...);
   * unsubscribe(); // no longer listening
   *
   */
  function subscribe(topic, listener) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    let callback = listener;
    if (typeof topic !== 'string') {
      // first param should be callback function in this case,
      // meaning it gets called for any config change
      callback = topic;
      topic = ALL_TOPICS;
      options = listener || {};
    }
    if (typeof callback !== 'function') {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError)('listener must be a function');
      return;
    }
    const nl = {
      topic,
      callback
    };
    listeners.push(nl);
    if (options.init) {
      if (topic === ALL_TOPICS) {
        callback(getConfig());
      } else {
        callback({
          [topic]: getConfig(topic)
        });
      }
    }

    // save and call this function to remove the listener
    return function unsubscribe() {
      listeners.splice(listeners.indexOf(nl), 1);
    };
  }

  /*
   * Calls listeners that were added by the `subscribe` function
   */
  function callSubscribers(options) {
    const TOPICS = Object.keys(options);

    // call subscribers of a specific topic, passing only that configuration
    listeners.filter(listener => TOPICS.includes(listener.topic)).forEach(listener => {
      listener.callback({
        [listener.topic]: options[listener.topic]
      });
    });

    // call subscribers that didn't give a topic, passing everything that was set
    listeners.filter(listener => listener.topic === ALL_TOPICS).forEach(listener => listener.callback(options));
  }
  function setBidderConfig(config) {
    let mergeFlag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    try {
      check(config);
      config.bidders.forEach(bidder => {
        if (!bidderConfig[bidder]) {
          bidderConfig[bidder] = attachProperties({}, false);
        }
        Object.keys(config.config).forEach(topic => {
          let option = config.config[topic];
          const currentConfig = bidderConfig[bidder][topic];
          if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(option) && (currentConfig == null || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(currentConfig))) {
            const func = mergeFlag ? _utils_js__WEBPACK_IMPORTED_MODULE_0__.mergeDeep : Object.assign;
            bidderConfig[bidder][topic] = func({}, currentConfig || {}, option);
          } else {
            bidderConfig[bidder][topic] = option;
          }
        });
      });
    } catch (e) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError)(e);
    }
    function check(obj) {
      if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(obj)) {
        throw 'setBidderConfig bidder options must be an object';
      }
      if (!(Array.isArray(obj.bidders) && obj.bidders.length)) {
        throw 'setBidderConfig bidder options must contain a bidders list with at least 1 bidder';
      }
      if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(obj.config)) {
        throw 'setBidderConfig bidder options must contain a config object';
      }
    }
  }
  function mergeConfig(obj) {
    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(obj)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError)('mergeConfig input must be an object');
      return;
    }
    const mergedConfig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mergeDeep)(_getConfig(), obj);
    setConfig({
      ...mergedConfig
    });
    return mergedConfig;
  }
  function mergeBidderConfig(obj) {
    return setBidderConfig(obj, true);
  }

  /**
   * Internal functions for core to execute some synchronous code while having an active bidder set.
   */
  function runWithBidder(bidder, fn) {
    currBidder = bidder;
    try {
      return fn();
    } finally {
      resetBidder();
    }
  }
  function callbackWithBidder(bidder) {
    return function (cb) {
      return function () {
        if (typeof cb === 'function') {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return runWithBidder(bidder, cb.bind(this, ...args));
        } else {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)('config.callbackWithBidder callback is not a function');
        }
      };
    };
  }
  function getCurrentBidder() {
    return currBidder;
  }
  function resetBidder() {
    currBidder = null;
  }
  resetConfig();
  return {
    getCurrentBidder,
    resetBidder,
    getConfig,
    getAnyConfig,
    readConfig,
    readAnyConfig,
    setConfig,
    mergeConfig,
    setDefaults,
    resetConfig,
    runWithBidder,
    callbackWithBidder,
    setBidderConfig,
    getBidderConfig,
    mergeBidderConfig
  };
}

/**
 * Set a `cache.url` if we should use prebid-cache to store video bids before adding bids to the auction.
 * This must be set if you want to use the dfpAdServerVideo module.
 */
const config = newConfig();

/***/ }),

/***/ "./src/consentHandler.js":
/*!*******************************!*\
  !*** ./src/consentHandler.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GDPR_GVLIDS: () => (/* binding */ GDPR_GVLIDS),
/* harmony export */   VENDORLESS_GVLID: () => (/* binding */ VENDORLESS_GVLID),
/* harmony export */   allConsent: () => (/* binding */ allConsent),
/* harmony export */   gdprDataHandler: () => (/* binding */ gdprDataHandler),
/* harmony export */   gppDataHandler: () => (/* binding */ gppDataHandler),
/* harmony export */   uspDataHandler: () => (/* binding */ uspDataHandler)
/* harmony export */ });
/* unused harmony exports ConsentHandler, gvlidRegistry, coppaDataHandler, multiHandler */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _utils_promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config.js */ "./src/config.js");




/**
 * Placeholder gvlid for when vendor consent is not required. When this value is used as gvlid, the gdpr
 * enforcement module will take it to mean "vendor consent was given".
 *
 * see https://github.com/prebid/Prebid.js/issues/8161
 */
const VENDORLESS_GVLID = Object.freeze({});
class ConsentHandler {
  #enabled;
  #data;
  #defer;
  #ready;
  #dirty = true;
  #hash;
  generatedTime;
  hashFields;
  constructor() {
    this.reset();
  }
  #resolve(data) {
    this.#ready = true;
    this.#data = data;
    this.#defer.resolve(data);
  }

  /**
   * reset this handler (mainly for tests)
   */
  reset() {
    this.#defer = (0,_utils_promise_js__WEBPACK_IMPORTED_MODULE_0__.defer)();
    this.#enabled = false;
    this.#data = null;
    this.#ready = false;
    this.generatedTime = null;
  }

  /**
   * Enable this consent handler. This should be called by the relevant consent management module
   * on initialization.
   */
  enable() {
    this.#enabled = true;
  }

  /**
   * @returns {boolean} true if the related consent management module is enabled.
   */
  get enabled() {
    return this.#enabled;
  }

  /**
   * @returns {boolean} true if consent data has been resolved (it may be `null` if the resolution failed).
   */
  get ready() {
    return this.#ready;
  }

  /**
   * @returns a promise than resolves to the consent data, or null if no consent data is available
   */
  get promise() {
    if (this.#ready) {
      return _utils_promise_js__WEBPACK_IMPORTED_MODULE_0__.PbPromise.resolve(this.#data);
    }
    if (!this.#enabled) {
      this.#resolve(null);
    }
    return this.#defer.promise;
  }
  setConsentData(data) {
    let time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.timestamp)();
    this.generatedTime = time;
    this.#dirty = true;
    this.#resolve(data);
  }
  getConsentData() {
    return this.#data;
  }
  get hash() {
    if (this.#dirty) {
      this.#hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cyrb53Hash)(JSON.stringify(this.#data && this.hashFields ? this.hashFields.map(f => this.#data[f]) : this.#data));
      this.#dirty = false;
    }
    return this.#hash;
  }
}
class UspConsentHandler extends ConsentHandler {
  getConsentMeta() {
    const consentData = this.getConsentData();
    if (consentData && this.generatedTime) {
      return {
        generatedAt: this.generatedTime
      };
    }
  }
}
class GdprConsentHandler extends ConsentHandler {
  hashFields = ['gdprApplies', 'consentString'];
  getConsentMeta() {
    const consentData = this.getConsentData();
    if (consentData && consentData.vendorData && this.generatedTime) {
      return {
        gdprApplies: consentData.gdprApplies,
        consentStringSize: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isStr)(consentData.vendorData.tcString) ? consentData.vendorData.tcString.length : 0,
        generatedAt: this.generatedTime,
        apiVersion: consentData.apiVersion
      };
    }
  }
}
class GppConsentHandler extends ConsentHandler {
  hashFields = ['applicableSections', 'gppString'];
  getConsentMeta() {
    const consentData = this.getConsentData();
    if (consentData && this.generatedTime) {
      return {
        generatedAt: this.generatedTime
      };
    }
  }
}
function gvlidRegistry() {
  const registry = {};
  const flat = {};
  const none = {};
  return {
    /**
     * Register a module's GVL ID.
     * @param {string} moduleType defined in `activities/modules.js`
     * @param {string} moduleName
     * @param {number} gvlid
     */
    register(moduleType, moduleName, gvlid) {
      if (gvlid) {
        (registry[moduleName] = registry[moduleName] || {})[moduleType] = gvlid;
        if (flat.hasOwnProperty(moduleName)) {
          if (flat[moduleName] !== gvlid) flat[moduleName] = none;
        } else {
          flat[moduleName] = gvlid;
        }
      }
    },
    /**
     * @typedef {Object} GvlIdResult
     * @property {Object.<string, number>} modules - A map from module type to that module's GVL ID.
     * @property {number} [gvlid] - The single GVL ID for this family of modules (only defined if all modules with this name declared the same ID).
     */

    /**
     * Get a module's GVL ID(s).
     *
     * @param {string} moduleName - The name of the module.
     * @return {GvlIdResult} An object where:
     *   `modules` is a map from module type to that module's GVL ID;
     *   `gvlid` is the single GVL ID for this family of modules (only defined if all modules with this name declare the same ID).
     */
    get(moduleName) {
      const result = {
        modules: registry[moduleName] || {}
      };
      if (flat.hasOwnProperty(moduleName) && flat[moduleName] !== none) {
        result.gvlid = flat[moduleName];
      }
      return result;
    }
  };
}
const gdprDataHandler = new GdprConsentHandler();
const uspDataHandler = new UspConsentHandler();
const gppDataHandler = new GppConsentHandler();
const coppaDataHandler = (() => {
  function getCoppa() {
    return !!_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('coppa');
  }
  return {
    getCoppa,
    getConsentData: getCoppa,
    getConsentMeta: getCoppa,
    reset() {},
    get promise() {
      return _utils_promise_js__WEBPACK_IMPORTED_MODULE_0__.PbPromise.resolve(getCoppa());
    },
    get hash() {
      return getCoppa() ? '1' : '0';
    }
  };
})();
const GDPR_GVLIDS = gvlidRegistry();
const ALL_HANDLERS = {
  gdpr: gdprDataHandler,
  usp: uspDataHandler,
  gpp: gppDataHandler,
  coppa: coppaDataHandler
};
function multiHandler() {
  let handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ALL_HANDLERS;
  handlers = Object.entries(handlers);
  function collector(method) {
    return function () {
      return Object.fromEntries(handlers.map(_ref => {
        let [name, handler] = _ref;
        return [name, handler[method]()];
      }));
    };
  }
  return Object.assign({
    get promise() {
      return _utils_promise_js__WEBPACK_IMPORTED_MODULE_0__.PbPromise.all(handlers.map(_ref2 => {
        let [name, handler] = _ref2;
        return handler.promise.then(val => [name, val]);
      })).then(entries => Object.fromEntries(entries));
    },
    get hash() {
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.cyrb53Hash)(handlers.map(_ref3 => {
        let [_, handler] = _ref3;
        return handler.hash;
      }).join(':'));
    }
  }, Object.fromEntries(['getConsentData', 'getConsentMeta', 'reset'].map(n => [n, collector(n)])));
}
const allConsent = multiHandler();

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AD_RENDER_FAILED_REASON: () => (/* binding */ AD_RENDER_FAILED_REASON),
/* harmony export */   BID_STATUS: () => (/* binding */ BID_STATUS),
/* harmony export */   DEBUG_MODE: () => (/* binding */ DEBUG_MODE),
/* harmony export */   DEFAULT_TARGETING_KEYS: () => (/* binding */ DEFAULT_TARGETING_KEYS),
/* harmony export */   EVENTS: () => (/* binding */ EVENTS),
/* harmony export */   EVENT_ID_PATHS: () => (/* binding */ EVENT_ID_PATHS),
/* harmony export */   GRANULARITY_OPTIONS: () => (/* binding */ GRANULARITY_OPTIONS),
/* harmony export */   JSON_MAPPING: () => (/* binding */ JSON_MAPPING),
/* harmony export */   MESSAGES: () => (/* binding */ MESSAGES),
/* harmony export */   NATIVE_ASSET_TYPES: () => (/* binding */ NATIVE_ASSET_TYPES),
/* harmony export */   NATIVE_IMAGE_TYPES: () => (/* binding */ NATIVE_IMAGE_TYPES),
/* harmony export */   NATIVE_KEYS: () => (/* binding */ NATIVE_KEYS),
/* harmony export */   NATIVE_KEYS_THAT_ARE_NOT_ASSETS: () => (/* binding */ NATIVE_KEYS_THAT_ARE_NOT_ASSETS),
/* harmony export */   PB_LOCATOR: () => (/* binding */ PB_LOCATOR),
/* harmony export */   PREBID_NATIVE_DATA_KEYS_TO_ORTB: () => (/* binding */ PREBID_NATIVE_DATA_KEYS_TO_ORTB),
/* harmony export */   REJECTION_REASON: () => (/* binding */ REJECTION_REASON),
/* harmony export */   S2S: () => (/* binding */ S2S),
/* harmony export */   STATUS: () => (/* binding */ STATUS),
/* harmony export */   TARGETING_KEYS: () => (/* binding */ TARGETING_KEYS)
/* harmony export */ });
const JSON_MAPPING = {
  PL_CODE: 'code',
  PL_SIZE: 'sizes',
  PL_BIDS: 'bids',
  BD_BIDDER: 'bidder',
  BD_ID: 'paramsd',
  BD_PL_ID: 'placementId',
  ADSERVER_TARGETING: 'adserverTargeting',
  BD_SETTING_STANDARD: 'standard'
};
const DEBUG_MODE = 'pbjs_debug';
const STATUS = {
  GOOD: 1
};
const EVENTS = {
  AUCTION_INIT: 'auctionInit',
  AUCTION_TIMEOUT: 'auctionTimeout',
  AUCTION_END: 'auctionEnd',
  BID_ADJUSTMENT: 'bidAdjustment',
  BID_TIMEOUT: 'bidTimeout',
  BID_REQUESTED: 'bidRequested',
  BID_RESPONSE: 'bidResponse',
  BID_REJECTED: 'bidRejected',
  NO_BID: 'noBid',
  SEAT_NON_BID: 'seatNonBid',
  BID_WON: 'bidWon',
  BIDDER_DONE: 'bidderDone',
  BIDDER_ERROR: 'bidderError',
  SET_TARGETING: 'setTargeting',
  BEFORE_REQUEST_BIDS: 'beforeRequestBids',
  BEFORE_BIDDER_HTTP: 'beforeBidderHttp',
  REQUEST_BIDS: 'requestBids',
  ADD_AD_UNITS: 'addAdUnits',
  AD_RENDER_FAILED: 'adRenderFailed',
  AD_RENDER_SUCCEEDED: 'adRenderSucceeded',
  TCF2_ENFORCEMENT: 'tcf2Enforcement',
  AUCTION_DEBUG: 'auctionDebug',
  BID_VIEWABLE: 'bidViewable',
  STALE_RENDER: 'staleRender',
  EXPIRED_RENDER: 'expiredRender',
  BILLABLE_EVENT: 'billableEvent',
  BID_ACCEPTED: 'bidAccepted',
  RUN_PAAPI_AUCTION: 'paapiRunAuction',
  PBS_ANALYTICS: 'pbsAnalytics',
  PAAPI_BID: 'paapiBid',
  PAAPI_NO_BID: 'paapiNoBid',
  PAAPI_ERROR: 'paapiError',
  BEFORE_PBS_HTTP: 'beforePBSHttp',
  BROWSI_INIT: 'browsiInit',
  BROWSI_DATA: 'browsiData'
};
const AD_RENDER_FAILED_REASON = {
  PREVENT_WRITING_ON_MAIN_DOCUMENT: 'preventWritingOnMainDocument',
  NO_AD: 'noAd',
  EXCEPTION: 'exception',
  CANNOT_FIND_AD: 'cannotFindAd',
  MISSING_DOC_OR_ADID: 'missingDocOrAdid'
};
const EVENT_ID_PATHS = {
  bidWon: 'adUnitCode'
};
const GRANULARITY_OPTIONS = {
  LOW: 'low',
  MEDIUM: 'medium',
  HIGH: 'high',
  AUTO: 'auto',
  DENSE: 'dense',
  CUSTOM: 'custom'
};
const TARGETING_KEYS = {
  BIDDER: 'hb_bidder',
  AD_ID: 'hb_adid',
  PRICE_BUCKET: 'hb_pb',
  SIZE: 'hb_size',
  DEAL: 'hb_deal',
  SOURCE: 'hb_source',
  FORMAT: 'hb_format',
  UUID: 'hb_uuid',
  CACHE_ID: 'hb_cache_id',
  CACHE_HOST: 'hb_cache_host',
  ADOMAIN: 'hb_adomain',
  ACAT: 'hb_acat',
  CRID: 'hb_crid',
  DSP: 'hb_dsp'
};
const DEFAULT_TARGETING_KEYS = {
  BIDDER: 'hb_bidder',
  AD_ID: 'hb_adid',
  PRICE_BUCKET: 'hb_pb',
  SIZE: 'hb_size',
  DEAL: 'hb_deal',
  FORMAT: 'hb_format',
  UUID: 'hb_uuid',
  CACHE_HOST: 'hb_cache_host'
};
const NATIVE_KEYS = {
  title: 'hb_native_title',
  body: 'hb_native_body',
  body2: 'hb_native_body2',
  privacyLink: 'hb_native_privacy',
  privacyIcon: 'hb_native_privicon',
  sponsoredBy: 'hb_native_brand',
  image: 'hb_native_image',
  icon: 'hb_native_icon',
  clickUrl: 'hb_native_linkurl',
  displayUrl: 'hb_native_displayurl',
  cta: 'hb_native_cta',
  rating: 'hb_native_rating',
  address: 'hb_native_address',
  downloads: 'hb_native_downloads',
  likes: 'hb_native_likes',
  phone: 'hb_native_phone',
  price: 'hb_native_price',
  salePrice: 'hb_native_saleprice',
  rendererUrl: 'hb_renderer_url',
  adTemplate: 'hb_adTemplate'
};
const S2S = {
  SRC: 's2s',
  DEFAULT_ENDPOINT: 'https://prebid.adnxs.com/pbs/v1/openrtb2/auction',
  SYNCED_BIDDERS_KEY: 'pbjsSyncs'
};
const BID_STATUS = {
  BID_TARGETING_SET: 'targetingSet',
  RENDERED: 'rendered',
  BID_REJECTED: 'bidRejected'
};
const REJECTION_REASON = {
  INVALID: 'Bid has missing or invalid properties',
  INVALID_REQUEST_ID: 'Invalid request ID',
  BIDDER_DISALLOWED: 'Bidder code is not allowed by allowedAlternateBidderCodes / allowUnknownBidderCodes',
  FLOOR_NOT_MET: 'Bid does not meet price floor',
  CANNOT_CONVERT_CURRENCY: 'Unable to convert currency',
  DSA_REQUIRED: 'Bid does not provide required DSA transparency info',
  DSA_MISMATCH: 'Bid indicates inappropriate DSA rendering method',
  PRICE_TOO_HIGH: 'Bid price exceeds maximum value'
};
const PREBID_NATIVE_DATA_KEYS_TO_ORTB = {
  body: 'desc',
  body2: 'desc2',
  sponsoredBy: 'sponsored',
  cta: 'ctatext',
  rating: 'rating',
  address: 'address',
  downloads: 'downloads',
  likes: 'likes',
  phone: 'phone',
  price: 'price',
  salePrice: 'saleprice',
  displayUrl: 'displayurl'
};
const NATIVE_ASSET_TYPES = {
  sponsored: 1,
  desc: 2,
  rating: 3,
  likes: 4,
  downloads: 5,
  price: 6,
  saleprice: 7,
  phone: 8,
  address: 9,
  desc2: 10,
  displayurl: 11,
  ctatext: 12
};
const NATIVE_IMAGE_TYPES = {
  ICON: 1,
  MAIN: 3
};
const NATIVE_KEYS_THAT_ARE_NOT_ASSETS = ['privacyIcon', 'clickUrl', 'sendTargetingKeys', 'adTemplate', 'rendererUrl', 'type'];
const MESSAGES = {
  REQUEST: 'Prebid Request',
  RESPONSE: 'Prebid Response',
  NATIVE: 'Prebid Native',
  EVENT: 'Prebid Event'
};
const PB_LOCATOR = '__pb_locator__';

/***/ }),

/***/ "./src/cpmBucketManager.js":
/*!*********************************!*\
  !*** ./src/cpmBucketManager.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPriceBucketString: () => (/* binding */ getPriceBucketString),
/* harmony export */   isValidPriceConfig: () => (/* binding */ isValidPriceConfig)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config.js */ "./src/config.js");


const _defaultPrecision = 2;
const _lgPriceConfig = {
  'buckets': [{
    'max': 5,
    'increment': 0.5
  }]
};
const _mgPriceConfig = {
  'buckets': [{
    'max': 20,
    'increment': 0.1
  }]
};
const _hgPriceConfig = {
  'buckets': [{
    'max': 20,
    'increment': 0.01
  }]
};
const _densePriceConfig = {
  'buckets': [{
    'max': 3,
    'increment': 0.01
  }, {
    'max': 8,
    'increment': 0.05
  }, {
    'max': 20,
    'increment': 0.5
  }]
};
const _autoPriceConfig = {
  'buckets': [{
    'max': 5,
    'increment': 0.05
  }, {
    'max': 10,
    'increment': 0.1
  }, {
    'max': 20,
    'increment': 0.5
  }]
};
function getPriceBucketString(cpm, customConfig) {
  let granularityMultiplier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  let cpmFloat = parseFloat(cpm);
  if (isNaN(cpmFloat)) {
    cpmFloat = '';
  }
  return {
    low: cpmFloat === '' ? '' : getCpmStringValue(cpm, _lgPriceConfig, granularityMultiplier),
    med: cpmFloat === '' ? '' : getCpmStringValue(cpm, _mgPriceConfig, granularityMultiplier),
    high: cpmFloat === '' ? '' : getCpmStringValue(cpm, _hgPriceConfig, granularityMultiplier),
    auto: cpmFloat === '' ? '' : getCpmStringValue(cpm, _autoPriceConfig, granularityMultiplier),
    dense: cpmFloat === '' ? '' : getCpmStringValue(cpm, _densePriceConfig, granularityMultiplier),
    custom: cpmFloat === '' ? '' : getCpmStringValue(cpm, customConfig, granularityMultiplier)
  };
}
function getCpmStringValue(cpm, config, granularityMultiplier) {
  let cpmStr = '';
  if (!isValidPriceConfig(config)) {
    return cpmStr;
  }
  const cap = config.buckets.reduce((prev, curr) => {
    if (prev.max > curr.max) {
      return prev;
    }
    return curr;
  }, {
    'max': 0
  });
  let bucketFloor = 0;
  let bucket = config.buckets.find(bucket => {
    if (cpm > cap.max * granularityMultiplier) {
      // cpm exceeds cap, just return the cap.
      let precision = bucket.precision;
      if (typeof precision === 'undefined') {
        precision = _defaultPrecision;
      }
      cpmStr = (bucket.max * granularityMultiplier).toFixed(precision);
    } else if (cpm <= bucket.max * granularityMultiplier && cpm >= bucketFloor * granularityMultiplier) {
      bucket.min = bucketFloor;
      return bucket;
    } else {
      bucketFloor = bucket.max;
    }
  });
  if (bucket) {
    cpmStr = getCpmTarget(cpm, bucket, granularityMultiplier);
  }
  return cpmStr;
}
function isValidPriceConfig(config) {
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(config) || !config.buckets || !Array.isArray(config.buckets)) {
    return false;
  }
  let isValid = true;
  config.buckets.forEach(bucket => {
    if (!bucket.max || !bucket.increment) {
      isValid = false;
    }
  });
  return isValid;
}
function getCpmTarget(cpm, bucket, granularityMultiplier) {
  const precision = typeof bucket.precision !== 'undefined' ? bucket.precision : _defaultPrecision;
  const increment = bucket.increment * granularityMultiplier;
  const bucketMin = bucket.min * granularityMultiplier;
  let roundingFunction = Math.floor;
  let customRoundingFunction = _config_js__WEBPACK_IMPORTED_MODULE_1__.config.getConfig('cpmRoundingFunction');
  if (typeof customRoundingFunction === 'function') {
    roundingFunction = customRoundingFunction;
  }

  // start increments at the bucket min and then add bucket min back to arrive at the correct rounding
  // note - we're padding the values to avoid using decimals in the math prior to flooring
  // this is done as JS can return values slightly below the expected mark which would skew the price bucket target
  //   (eg 4.01 / 0.01 = 400.99999999999994)
  // min precison should be 2 to move decimal place over.
  let pow = Math.pow(10, precision + 2);
  let cpmToRound = (cpm * pow - bucketMin * pow) / (increment * pow);
  let cpmTarget;
  let invalidRounding;
  // It is likely that we will be passed {cpmRoundingFunction: roundingFunction()}
  // rather than the expected {cpmRoundingFunction: roundingFunction}. Default back to floor in that case
  try {
    cpmTarget = roundingFunction(cpmToRound) * increment + bucketMin;
  } catch (err) {
    invalidRounding = true;
  }
  if (invalidRounding || typeof cpmTarget !== 'number') {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)('Invalid rounding function passed in config');
    cpmTarget = Math.floor(cpmToRound) * increment + bucketMin;
  }
  // force to 10 decimal places to deal with imprecise decimal/binary conversions
  //    (for example 0.1 * 3 = 0.30000000000000004)

  cpmTarget = Number(cpmTarget.toFixed(10));
  return cpmTarget.toFixed(precision);
}


/***/ }),

/***/ "./src/creativeRenderers.js":
/*!**********************************!*\
  !*** ./src/creativeRenderers.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PUC_MIN_VERSION: () => (/* binding */ PUC_MIN_VERSION),
/* harmony export */   getCreativeRenderer: () => (/* binding */ getCreativeRenderer),
/* harmony export */   getCreativeRendererSource: () => (/* binding */ getCreativeRendererSource)
/* harmony export */ });
/* harmony import */ var _utils_promise_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _libraries_creative_renderer_display_renderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libraries/creative-renderer-display/renderer.js */ "./libraries/creative-renderer-display/renderer.js");
/* harmony import */ var _hook_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hook.js */ "./src/hook.js");





// the minimum rendererVersion that will be used by PUC
const PUC_MIN_VERSION = 3;
const getCreativeRendererSource = (0,_hook_js__WEBPACK_IMPORTED_MODULE_0__.hook)('sync', function (bidResponse) {
  return _libraries_creative_renderer_display_renderer_js__WEBPACK_IMPORTED_MODULE_1__.RENDERER;
});
const getCreativeRenderer = function () {
  const renderers = {};
  return function (bidResponse) {
    const src = getCreativeRendererSource(bidResponse);
    if (!renderers.hasOwnProperty(src)) {
      renderers[src] = new _utils_promise_js__WEBPACK_IMPORTED_MODULE_2__.PbPromise(resolve => {
        const iframe = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.createInvisibleIframe)();
        iframe.srcdoc = `<script>${src}</script>`;
        iframe.onload = () => resolve(iframe.contentWindow.render);
        document.body.appendChild(iframe);
      });
    }
    return renderers[src];
  };
}();

/***/ }),

/***/ "./src/debugging.js":
/*!**************************!*\
  !*** ./src/debugging.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEBUG_KEY: () => (/* binding */ DEBUG_KEY),
/* harmony export */   loadSession: () => (/* binding */ loadSession)
/* harmony export */ });
/* unused harmony exports debuggingModuleLoader, debuggingControls, reset */
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./config.js */ "./src/config.js");
/* harmony import */ var _hook_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hook.js */ "./src/hook.js");
/* harmony import */ var _prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _bidfactory_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bidfactory.js */ "./src/bidfactory.js");
/* harmony import */ var _adloader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./adloader.js */ "./src/adloader.js");
/* harmony import */ var _utils_promise_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _activities_modules_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./activities/modules.js */ "./src/activities/modules.js");








const DEBUG_KEY = "__pbjs_debugging__";
function isDebuggingInstalled() {
  return (0,_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__.getGlobal)().installedModules.includes('debugging');
}
function loadScript(url) {
  return new _utils_promise_js__WEBPACK_IMPORTED_MODULE_1__.PbPromise(resolve => {
    (0,_adloader_js__WEBPACK_IMPORTED_MODULE_2__.loadExternalScript)(url, _activities_modules_js__WEBPACK_IMPORTED_MODULE_3__.MODULE_TYPE_PREBID, 'debugging', resolve);
  });
}
function debuggingModuleLoader() {
  let {
    alreadyInstalled = isDebuggingInstalled,
    script = loadScript
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let loading = null;
  return function () {
    if (loading == null) {
      loading = new _utils_promise_js__WEBPACK_IMPORTED_MODULE_1__.PbPromise((resolve, reject) => {
        // run this in a 0-delay timeout to give installedModules time to be populated
        setTimeout(() => {
          if (alreadyInstalled()) {
            resolve();
          } else {
            const url = "/build/dev/debugging-standalone.js";
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logMessage)(`Debugging module not installed, loading it from "${url}"...`);
            (0,_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__.getGlobal)()._installDebugging = true;
            script(url).then(() => {
              (0,_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__.getGlobal)()._installDebugging({
                DEBUG_KEY,
                hook: _hook_js__WEBPACK_IMPORTED_MODULE_5__.hook,
                config: _config_js__WEBPACK_IMPORTED_MODULE_6__.config,
                createBid: _bidfactory_js__WEBPACK_IMPORTED_MODULE_7__.createBid,
                logger: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.prefixLog)('DEBUG:')
              });
            }).then(resolve, reject);
          }
        });
      });
    }
    return loading;
  };
}
function debuggingControls() {
  let {
    load = debuggingModuleLoader(),
    hook = (0,_hook_js__WEBPACK_IMPORTED_MODULE_5__.getHook)('requestBids')
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let promise = null;
  let enabled = false;
  function waitForDebugging(next) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return (promise || _utils_promise_js__WEBPACK_IMPORTED_MODULE_1__.PbPromise.resolve()).then(() => next.apply(this, args));
  }
  function enable() {
    if (!enabled) {
      promise = load();
      // set debugging to high priority so that it has the opportunity to mess with most things
      hook.before(waitForDebugging, 99);
      enabled = true;
    }
  }
  function disable() {
    hook.getHooks({
      hook: waitForDebugging
    }).remove();
    enabled = false;
  }
  function reset() {
    promise = null;
    disable();
  }
  return {
    enable,
    disable,
    reset
  };
}
const ctl = debuggingControls();
const reset = ctl.reset;
function loadSession() {
  let storage = null;
  try {
    // eslint-disable-next-line no-restricted-properties
    storage = window.sessionStorage;
  } catch (e) {}
  if (storage !== null) {
    let debugging = ctl;
    let config = null;
    try {
      config = storage.getItem(DEBUG_KEY);
    } catch (e) {}
    if (config !== null) {
      // just make sure the module runs; it will take care of parsing the config (and disabling itself if necessary)
      debugging.enable();
    }
  }
}
_config_js__WEBPACK_IMPORTED_MODULE_6__.config.getConfig('debugging', function (_ref) {
  let {
    debugging
  } = _ref;
  debugging?.enabled ? ctl.enable() : ctl.disable();
});

/***/ }),

/***/ "./src/eventTrackers.js":
/*!******************************!*\
  !*** ./src/eventTrackers.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EVENT_TYPE_IMPRESSION: () => (/* binding */ EVENT_TYPE_IMPRESSION),
/* harmony export */   EVENT_TYPE_WIN: () => (/* binding */ EVENT_TYPE_WIN),
/* harmony export */   TRACKER_METHOD_IMG: () => (/* binding */ TRACKER_METHOD_IMG),
/* harmony export */   TRACKER_METHOD_JS: () => (/* binding */ TRACKER_METHOD_JS),
/* harmony export */   parseEventTrackers: () => (/* binding */ parseEventTrackers)
/* harmony export */ });
const TRACKER_METHOD_IMG = 1;
const TRACKER_METHOD_JS = 2;
const EVENT_TYPE_IMPRESSION = 1;
const EVENT_TYPE_WIN = 500;

/**
 * Returns a map from event type (EVENT_TYPE_*)
 * to a map from tracker method (TRACKER_METHOD_*)
 * to an array of tracking URLs
 *
 * @param {{}[]} eventTrackers an array of "Event Tracker Response Object" as defined
 *  in the ORTB native 1.2 spec (https://www.iab.com/wp-content/uploads/2018/03/OpenRTB-Native-Ads-Specification-Final-1.2.pdf, section 5.8)
 * @returns {{[type: string]: {[method: string]: string[]}}}
 */
function parseEventTrackers(eventTrackers) {
  return (eventTrackers ?? []).reduce((tally, _ref) => {
    let {
      event,
      method,
      url
    } = _ref;
    const trackersForType = tally[event] = tally[event] ?? {};
    const trackersForMethod = trackersForType[method] = trackersForType[method] ?? [];
    trackersForMethod.push(url);
    return tally;
  }, {});
}

/***/ }),

/***/ "./src/events.js":
/*!***********************!*\
  !*** ./src/events.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   emit: () => (/* binding */ emit),
/* harmony export */   getEvents: () => (/* binding */ getEvents),
/* harmony export */   off: () => (/* binding */ off),
/* harmony export */   on: () => (/* binding */ on)
/* harmony export */ });
/* unused harmony exports get, addEvents, has, clearEvents */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ "./src/constants.js");
/* harmony import */ var _utils_ttlCollection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/ttlCollection.js */ "./src/utils/ttlCollection.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config.js */ "./src/config.js");
/**
 * events.js
 */




const TTL_CONFIG = 'eventHistoryTTL';
let eventTTL = null;

// keep a record of all events fired
const eventsFired = (0,_utils_ttlCollection_js__WEBPACK_IMPORTED_MODULE_0__.ttlCollection)({
  monotonic: true,
  ttl: () => eventTTL
});
_config_js__WEBPACK_IMPORTED_MODULE_1__.config.getConfig(TTL_CONFIG, val => {
  const previous = eventTTL;
  val = val?.[TTL_CONFIG];
  eventTTL = typeof val === 'number' ? val * 1000 : null;
  if (previous !== eventTTL) {
    eventsFired.refresh();
  }
});
let slice = Array.prototype.slice;
let push = Array.prototype.push;

// define entire events
let allEvents = Object.values(_constants_js__WEBPACK_IMPORTED_MODULE_2__.EVENTS);
const idPaths = _constants_js__WEBPACK_IMPORTED_MODULE_2__.EVENT_ID_PATHS;
const _public = function () {
  let _handlers = {};
  let _public = {};

  /**
   *
   * @param {String} eventString  The name of the event.
   * @param {Array} args  The payload emitted with the event.
   * @private
   */
  function _dispatch(eventString, args) {
    _utils_js__WEBPACK_IMPORTED_MODULE_3__.logMessage('Emitting event for: ' + eventString);
    let eventPayload = args[0] || {};
    let idPath = idPaths[eventString];
    let key = eventPayload[idPath];
    let event = _handlers[eventString] || {
      que: []
    };
    var eventKeys = Object.keys(event);
    let callbacks = [];

    // record the event:
    eventsFired.add({
      eventType: eventString,
      args: eventPayload,
      id: key,
      elapsedTime: _utils_js__WEBPACK_IMPORTED_MODULE_3__.getPerformanceNow()
    });

    /**
     * Push each specific callback to the `callbacks` array.
     * If the `event` map has a key that matches the value of the
     * event payload id path, e.g. `eventPayload[idPath]`, then apply
     * each function in the `que` array as an argument to push to the
     * `callbacks` array
     */
    if (key && eventKeys.includes(key)) {
      push.apply(callbacks, event[key].que);
    }

    /** Push each general callback to the `callbacks` array. */
    push.apply(callbacks, event.que);

    /** call each of the callbacks */
    (callbacks || []).forEach(function (fn) {
      if (!fn) return;
      try {
        fn.apply(null, args);
      } catch (e) {
        _utils_js__WEBPACK_IMPORTED_MODULE_3__.logError('Error executing handler:', 'events.js', e, eventString);
      }
    });
  }
  function _checkAvailableEvent(event) {
    return allEvents.includes(event);
  }
  _public.has = _checkAvailableEvent;
  _public.on = function (eventString, handler, id) {
    // check whether available event or not
    if (_checkAvailableEvent(eventString)) {
      let event = _handlers[eventString] || {
        que: []
      };
      if (id) {
        event[id] = event[id] || {
          que: []
        };
        event[id].que.push(handler);
      } else {
        event.que.push(handler);
      }
      _handlers[eventString] = event;
    } else {
      _utils_js__WEBPACK_IMPORTED_MODULE_3__.logError('Wrong event name : ' + eventString + ' Valid event names :' + allEvents);
    }
  };
  _public.emit = function (event) {
    let args = slice.call(arguments, 1);
    _dispatch(event, args);
  };
  _public.off = function (eventString, handler, id) {
    let event = _handlers[eventString];
    if (_utils_js__WEBPACK_IMPORTED_MODULE_3__.isEmpty(event) || _utils_js__WEBPACK_IMPORTED_MODULE_3__.isEmpty(event.que) && _utils_js__WEBPACK_IMPORTED_MODULE_3__.isEmpty(event[id])) {
      return;
    }
    if (id && (_utils_js__WEBPACK_IMPORTED_MODULE_3__.isEmpty(event[id]) || _utils_js__WEBPACK_IMPORTED_MODULE_3__.isEmpty(event[id].que))) {
      return;
    }
    if (id) {
      (event[id].que || []).forEach(function (_handler) {
        let que = event[id].que;
        if (_handler === handler) {
          que.splice(que.indexOf(_handler), 1);
        }
      });
    } else {
      (event.que || []).forEach(function (_handler) {
        let que = event.que;
        if (_handler === handler) {
          que.splice(que.indexOf(_handler), 1);
        }
      });
    }
    _handlers[eventString] = event;
  };
  _public.get = function () {
    return _handlers;
  };
  _public.addEvents = function (events) {
    allEvents = allEvents.concat(events);
  };

  /**
   * This method can return a copy of all the events fired
   * @return {Array} array of events fired
   */
  _public.getEvents = function () {
    return eventsFired.toArray().map(val => Object.assign({}, val));
  };
  return _public;
}();
_utils_js__WEBPACK_IMPORTED_MODULE_3__._setEventEmitter(_public.emit.bind(_public));
const {
  on,
  off,
  get,
  getEvents,
  emit,
  addEvents,
  has
} = _public;
function clearEvents() {
  eventsFired.clear();
}

/***/ }),

/***/ "./src/fpd/enrichment.js":
/*!*******************************!*\
  !*** ./src/fpd/enrichment.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   enrichFPD: () => (/* binding */ enrichFPD)
/* harmony export */ });
/* unused harmony export dep */
/* harmony import */ var _hook_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../hook.js */ "./src/hook.js");
/* harmony import */ var _refererDetection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../refererDetection.js */ "./src/refererDetection.js");
/* harmony import */ var _rootDomain_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rootDomain.js */ "./src/fpd/rootDomain.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ "./src/utils.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../config.js */ "./src/config.js");
/* harmony import */ var _sua_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sua.js */ "./src/fpd/sua.js");
/* harmony import */ var _utils_promise_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _oneClient_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./oneClient.js */ "./src/fpd/oneClient.js");
/* harmony import */ var _activities_rules_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../activities/rules.js */ "./src/activities/rules.js");
/* harmony import */ var _activities_activityParams_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../activities/activityParams.js */ "./src/activities/activityParams.js");
/* harmony import */ var _activities_activities_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../activities/activities.js */ "./src/activities/activities.js");
/* harmony import */ var _activities_modules_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../activities/modules.js */ "./src/activities/modules.js");
/* harmony import */ var _libraries_viewport_viewport_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../libraries/viewport/viewport.js */ "./libraries/viewport/viewport.js");













const dep = {
  getRefererInfo: _refererDetection_js__WEBPACK_IMPORTED_MODULE_0__.getRefererInfo,
  findRootDomain: _rootDomain_js__WEBPACK_IMPORTED_MODULE_1__.findRootDomain,
  getWindowTop: _utils_js__WEBPACK_IMPORTED_MODULE_2__.getWindowTop,
  getWindowSelf: _utils_js__WEBPACK_IMPORTED_MODULE_2__.getWindowSelf,
  getHighEntropySUA: _sua_js__WEBPACK_IMPORTED_MODULE_3__.getHighEntropySUA,
  getLowEntropySUA: _sua_js__WEBPACK_IMPORTED_MODULE_3__.getLowEntropySUA,
  getDocument: _utils_js__WEBPACK_IMPORTED_MODULE_2__.getDocument
};
const oneClient = (0,_oneClient_js__WEBPACK_IMPORTED_MODULE_4__.clientSectionChecker)('FPD');

/**
 * Enrich an ortb2 object with first-party data.
 * @param {Promise<Object>} fpd - A promise that resolves to an ortb2 object.
 * @returns {Promise<Object>} - A promise that resolves to an enriched ortb2 object.
 */
const enrichFPD = (0,_hook_js__WEBPACK_IMPORTED_MODULE_5__.hook)('sync', fpd => {
  const promArr = [fpd, getSUA().catch(() => null), tryToGetCdepLabel().catch(() => null)];
  return _utils_promise_js__WEBPACK_IMPORTED_MODULE_6__.PbPromise.all(promArr).then(_ref => {
    let [ortb2, sua, cdep] = _ref;
    const ri = dep.getRefererInfo();
    Object.entries(ENRICHMENTS).forEach(_ref2 => {
      let [section, getEnrichments] = _ref2;
      const data = getEnrichments(ortb2, ri);
      if (data && Object.keys(data).length > 0) {
        ortb2[section] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeDeep)({}, data, ortb2[section]);
      }
    });
    if (sua) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.dset)(ortb2, 'device.sua', Object.assign({}, sua, ortb2.device.sua));
    }
    if (cdep) {
      const ext = {
        cdep
      };
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.dset)(ortb2, 'device.ext', Object.assign({}, ext, ortb2.device.ext));
    }
    const documentLang = dep.getDocument().documentElement.lang;
    if (documentLang) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.dset)(ortb2, 'site.ext.data.documentLang', documentLang);
    }
    ortb2 = oneClient(ortb2);
    for (let section of _oneClient_js__WEBPACK_IMPORTED_MODULE_4__.CLIENT_SECTIONS) {
      if ((0,_oneClient_js__WEBPACK_IMPORTED_MODULE_4__.hasSection)(ortb2, section)) {
        ortb2[section] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeDeep)({}, clientEnrichment(ortb2, ri), ortb2[section]);
        break;
      }
    }
    return ortb2;
  });
});
function winFallback(fn) {
  try {
    return fn(dep.getWindowTop());
  } catch (e) {
    return fn(dep.getWindowSelf());
  }
}
function getSUA() {
  const hints = _config_js__WEBPACK_IMPORTED_MODULE_8__.config.getConfig('firstPartyData.uaHints');
  return !Array.isArray(hints) || hints.length === 0 ? _utils_promise_js__WEBPACK_IMPORTED_MODULE_6__.PbPromise.resolve(dep.getLowEntropySUA()) : dep.getHighEntropySUA(hints);
}
function removeUndef(obj) {
  return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.getDefinedParams)(obj, Object.keys(obj));
}
function tryToGetCdepLabel() {
  return _utils_promise_js__WEBPACK_IMPORTED_MODULE_6__.PbPromise.resolve('cookieDeprecationLabel' in navigator && (0,_activities_rules_js__WEBPACK_IMPORTED_MODULE_9__.isActivityAllowed)(_activities_activities_js__WEBPACK_IMPORTED_MODULE_10__.ACTIVITY_ACCESS_DEVICE, (0,_activities_activityParams_js__WEBPACK_IMPORTED_MODULE_11__.activityParams)(_activities_modules_js__WEBPACK_IMPORTED_MODULE_12__.MODULE_TYPE_PREBID, 'cdep')) && navigator.cookieDeprecationLabel.getValue());
}
const ENRICHMENTS = {
  site(ortb2, ri) {
    if (_oneClient_js__WEBPACK_IMPORTED_MODULE_4__.CLIENT_SECTIONS.filter(p => p !== 'site').some(_oneClient_js__WEBPACK_IMPORTED_MODULE_4__.hasSection.bind(null, ortb2))) {
      // do not enrich site if dooh or app are set
      return;
    }
    return removeUndef({
      page: ri.page,
      ref: ri.ref
    });
  },
  device() {
    return winFallback(win => {
      // screen.width and screen.height are the physical dimensions of the screen
      const w = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.getWinDimensions)().screen.width;
      const h = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.getWinDimensions)().screen.height;

      // vpw and vph are the viewport dimensions of the browser window
      const {
        width: vpw,
        height: vph
      } = (0,_libraries_viewport_viewport_js__WEBPACK_IMPORTED_MODULE_13__.getViewportSize)();
      const device = {
        w,
        h,
        dnt: (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.getDNT)() ? 1 : 0,
        ua: win.navigator.userAgent,
        language: win.navigator.language.split('-').shift(),
        ext: {
          vpw,
          vph
        }
      };
      if (win.navigator?.webdriver) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.dset)(device, 'ext.webdriver', true);
      }
      return device;
    });
  },
  regs() {
    const regs = {};
    if (winFallback(win => win.navigator.globalPrivacyControl)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.dset)(regs, 'ext.gpc', '1');
    }
    const coppa = _config_js__WEBPACK_IMPORTED_MODULE_8__.config.getConfig('coppa');
    if (typeof coppa === 'boolean') {
      regs.coppa = coppa ? 1 : 0;
    }
    return regs;
  }
};

// Enrichment of properties common across dooh, app and site - will be dropped into whatever
// section is appropriate
function clientEnrichment(ortb2, ri) {
  const domain = (0,_refererDetection_js__WEBPACK_IMPORTED_MODULE_0__.parseDomain)(ri.page, {
    noLeadingWww: true
  });
  const keywords = winFallback(win => win.document.querySelector('meta[name=\'keywords\']'))?.content?.replace?.(/\s/g, '');
  return removeUndef({
    domain,
    keywords,
    publisher: removeUndef({
      domain: dep.findRootDomain(domain)
    })
  });
}

/***/ }),

/***/ "./src/fpd/oneClient.js":
/*!******************************!*\
  !*** ./src/fpd/oneClient.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CLIENT_SECTIONS: () => (/* binding */ CLIENT_SECTIONS),
/* harmony export */   clientSectionChecker: () => (/* binding */ clientSectionChecker),
/* harmony export */   hasSection: () => (/* binding */ hasSection)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./src/utils.js");


// mutually exclusive ORTB sections in order of priority - 'dooh' beats 'app' & 'site' and 'app' beats 'site';
// if one is set, the others will be removed
const CLIENT_SECTIONS = ['dooh', 'app', 'site'];
function clientSectionChecker(logPrefix) {
  return function onlyOneClientSection(ortb2) {
    CLIENT_SECTIONS.reduce((found, section) => {
      if (hasSection(ortb2, section)) {
        if (found != null) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)(`${logPrefix} specifies both '${found}' and '${section}'; dropping the latter.`);
          delete ortb2[section];
        } else {
          found = section;
        }
      }
      return found;
    }, null);
    return ortb2;
  };
}
function hasSection(ortb2, section) {
  return ortb2[section] != null && Object.keys(ortb2[section]).length > 0;
}

/***/ }),

/***/ "./src/fpd/rootDomain.js":
/*!*******************************!*\
  !*** ./src/fpd/rootDomain.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findRootDomain: () => (/* binding */ findRootDomain)
/* harmony export */ });
/* unused harmony export coreStorage */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./src/utils.js");
/* harmony import */ var _storageManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../storageManager.js */ "./src/storageManager.js");


const coreStorage = (0,_storageManager_js__WEBPACK_IMPORTED_MODULE_0__.getCoreStorageManager)('fpdEnrichment');

/**
 * Find the root domain by testing for the topmost domain that will allow setting cookies.
 */

const findRootDomain = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.memoize)(function findRootDomain() {
  let fullDomain = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.host;
  if (!coreStorage.cookiesAreEnabled()) {
    return fullDomain;
  }
  const domainParts = fullDomain.split('.');
  if (domainParts.length === 2) {
    return fullDomain;
  }
  let rootDomain;
  let continueSearching;
  let startIndex = -2;
  const TEST_COOKIE_NAME = `_rdc${Date.now()}`;
  const TEST_COOKIE_VALUE = 'writeable';
  do {
    rootDomain = domainParts.slice(startIndex).join('.');
    let expirationDate = new Date((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.timestamp)() + 10 * 1000).toUTCString();

    // Write a test cookie
    coreStorage.setCookie(TEST_COOKIE_NAME, TEST_COOKIE_VALUE, expirationDate, 'Lax', rootDomain, undefined);

    // See if the write was successful
    const value = coreStorage.getCookie(TEST_COOKIE_NAME, undefined);
    if (value === TEST_COOKIE_VALUE) {
      continueSearching = false;
      // Delete our test cookie
      coreStorage.setCookie(TEST_COOKIE_NAME, '', 'Thu, 01 Jan 1970 00:00:01 GMT', undefined, rootDomain, undefined);
    } else {
      startIndex += -1;
      continueSearching = Math.abs(startIndex) <= domainParts.length;
    }
  } while (continueSearching);
  return rootDomain;
});

/***/ }),

/***/ "./src/fpd/sua.js":
/*!************************!*\
  !*** ./src/fpd/sua.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getHighEntropySUA: () => (/* binding */ getHighEntropySUA),
/* harmony export */   getLowEntropySUA: () => (/* binding */ getLowEntropySUA)
/* harmony export */ });
/* unused harmony exports SUA_SOURCE_UNKNOWN, SUA_SOURCE_LOW_ENTROPY, SUA_SOURCE_HIGH_ENTROPY, SUA_SOURCE_UA_HEADER, HIGH_ENTROPY_HINTS, LOW_ENTROPY_HINTS, lowEntropySUAAccessor, highEntropySUAAccessor, uaDataToSUA */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./src/utils.js");
/* harmony import */ var _utils_promise_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/promise.js */ "./src/utils/promise.js");


const SUA_SOURCE_UNKNOWN = 0;
const SUA_SOURCE_LOW_ENTROPY = 1;
const SUA_SOURCE_HIGH_ENTROPY = 2;
const SUA_SOURCE_UA_HEADER = 3;

// "high entropy" (i.e. privacy-sensitive) fields that can be requested from the navigator.
const HIGH_ENTROPY_HINTS = ['architecture', 'bitness', 'model', 'platformVersion', 'fullVersionList'];
const LOW_ENTROPY_HINTS = ['brands', 'mobile', 'platform'];

/**
 * Returns low entropy UA client hints encoded as an ortb2.6 device.sua object; or null if no UA client hints are available.
 */
const getLowEntropySUA = lowEntropySUAAccessor();

/**
 * Returns a promise to high entropy UA client hints encoded as an ortb2.6 device.sua object, or null if no UA client hints are available.
 *
 * Note that the return value is a promise because the underlying browser API returns a promise; this
 * seems to plan for additional controls (such as alerts / permission request prompts to the user); it's unclear
 * at the moment if this means that asking for more hints would result in slower / more expensive calls.
 *
 * @param {Array[String]} hints hints to request, defaults to all (HIGH_ENTROPY_HINTS).
 */
const getHighEntropySUA = highEntropySUAAccessor();
function lowEntropySUAAccessor() {
  let uaData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.navigator?.userAgentData;
  const sua = uaData && LOW_ENTROPY_HINTS.some(h => typeof uaData[h] !== 'undefined') ? Object.freeze(uaDataToSUA(SUA_SOURCE_LOW_ENTROPY, uaData)) : null;
  return function () {
    return sua;
  };
}
function highEntropySUAAccessor() {
  let uaData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.navigator?.userAgentData;
  const cache = {};
  const keys = new WeakMap();
  return function () {
    let hints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HIGH_ENTROPY_HINTS;
    if (!keys.has(hints)) {
      const sorted = Array.from(hints);
      sorted.sort();
      keys.set(hints, sorted.join('|'));
    }
    const key = keys.get(hints);
    if (!cache.hasOwnProperty(key)) {
      try {
        cache[key] = uaData.getHighEntropyValues(hints).then(result => {
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(result) ? null : Object.freeze(uaDataToSUA(SUA_SOURCE_HIGH_ENTROPY, result));
        }).catch(() => null);
      } catch (e) {
        cache[key] = _utils_promise_js__WEBPACK_IMPORTED_MODULE_1__.PbPromise.resolve(null);
      }
    }
    return cache[key];
  };
}

/**
 * Convert a User Agent client hints object to an ORTB 2.6 device.sua fragment
 * https://iabtechlab.com/wp-content/uploads/2022/04/OpenRTB-2-6_FINAL.pdf
 *
 * @param source source of the UAData object (0 to 3)
 * @param uaData https://developer.mozilla.org/en-US/docs/Web/API/NavigatorUAData/
 * @return {{}}
 */
function uaDataToSUA(source, uaData) {
  function toBrandVersion(brand, version) {
    const bv = {
      brand
    };
    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr)(version) && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isEmptyStr)(version)) {
      bv.version = version.split('.');
    }
    return bv;
  }
  const sua = {
    source
  };
  if (uaData.platform) {
    sua.platform = toBrandVersion(uaData.platform, uaData.platformVersion);
  }
  if (uaData.fullVersionList || uaData.brands) {
    sua.browsers = (uaData.fullVersionList || uaData.brands).map(_ref => {
      let {
        brand,
        version
      } = _ref;
      return toBrandVersion(brand, version);
    });
  }
  if (typeof uaData['mobile'] !== 'undefined') {
    sua.mobile = uaData.mobile ? 1 : 0;
  }
  ['model', 'bitness', 'architecture'].forEach(prop => {
    const value = uaData[prop];
    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr)(value)) {
      sua[prop] = value;
    }
  });
  return sua;
}

/***/ }),

/***/ "./src/hook.js":
/*!*********************!*\
  !*** ./src/hook.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getHook: () => (/* binding */ getHook),
/* harmony export */   hook: () => (/* binding */ hook),
/* harmony export */   ignoreCallbackArg: () => (/* binding */ ignoreCallbackArg),
/* harmony export */   module: () => (/* binding */ module),
/* harmony export */   ready: () => (/* binding */ ready),
/* harmony export */   setupBeforeHookFnOnce: () => (/* binding */ setupBeforeHookFnOnce),
/* harmony export */   submodule: () => (/* binding */ submodule),
/* harmony export */   wrapHook: () => (/* binding */ wrapHook)
/* harmony export */ });
/* harmony import */ var fun_hooks_no_eval_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fun-hooks/no-eval/index.js */ "./node_modules/fun-hooks/no-eval/index.js");
/* harmony import */ var fun_hooks_no_eval_index_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fun_hooks_no_eval_index_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_promise_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/promise.js */ "./src/utils/promise.js");



/**
 * NOTE: you must not call `next` asynchronously from 'sync' hooks
 * see https://github.com/snapwich/fun-hooks/issues/42
 */
let hook = fun_hooks_no_eval_index_js__WEBPACK_IMPORTED_MODULE_0___default()({
  ready: (fun_hooks_no_eval_index_js__WEBPACK_IMPORTED_MODULE_0___default().SYNC) | (fun_hooks_no_eval_index_js__WEBPACK_IMPORTED_MODULE_0___default().ASYNC) | (fun_hooks_no_eval_index_js__WEBPACK_IMPORTED_MODULE_0___default().QUEUE)
});
const readyCtl = (0,_utils_promise_js__WEBPACK_IMPORTED_MODULE_1__.defer)();
hook.ready = (() => {
  const ready = hook.ready;
  return function () {
    try {
      return ready.apply(hook, arguments);
    } finally {
      readyCtl.resolve();
    }
  };
})();

/**
 * A promise that resolves when hooks are ready.
 * @type {Promise}
 */
const ready = readyCtl.promise;
const getHook = hook.get;
function setupBeforeHookFnOnce(baseFn, hookFn) {
  let priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 15;
  let result = baseFn.getHooks({
    hook: hookFn
  });
  if (result.length === 0) {
    baseFn.before(hookFn, priority);
  }
}
const submoduleInstallMap = {};
function module(name, install) {
  let {
    postInstallAllowed = false
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  hook('async', function (submodules) {
    submodules.forEach(args => install(...args));
    if (postInstallAllowed) submoduleInstallMap[name] = install;
  }, name)([]); // will be queued until hook.ready() called in pbjs.processQueue();
}
function submodule(name) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  const install = submoduleInstallMap[name];
  if (install) return install(...args);
  getHook(name).before((next, modules) => {
    modules.push(args);
    next(modules);
  });
}

/**
 * Copy hook methods (.before, .after, etc) from a given hook to a given wrapper object.
 */
function wrapHook(hook, wrapper) {
  Object.defineProperties(wrapper, Object.fromEntries(['before', 'after', 'getHooks', 'removeAll'].map(m => [m, {
    get: () => hook[m]
  }])));
  return wrapper;
}

/**
 * 'async' hooks expect the last argument to be a callback, and have special treatment for it if it's a function;
 * which prevents it from being used as a normal argument in 'before' hooks - and presents a modified version of it
 * to the hooked function.
 *
 * This returns a wrapper around a given 'async' hook that works around this, for when the last argument
 * should be treated as a normal argument.
 */
function ignoreCallbackArg(hook) {
  return wrapHook(hook, function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    args.push(function () {});
    return hook.apply(this, args);
  });
}

/***/ }),

/***/ "./src/mediaTypes.js":
/*!***************************!*\
  !*** ./src/mediaTypes.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ADPOD: () => (/* binding */ ADPOD),
/* harmony export */   ALL_MEDIATYPES: () => (/* binding */ ALL_MEDIATYPES),
/* harmony export */   BANNER: () => (/* binding */ BANNER),
/* harmony export */   NATIVE: () => (/* binding */ NATIVE),
/* harmony export */   VIDEO: () => (/* binding */ VIDEO)
/* harmony export */ });
/**
 * This file contains the valid Media Types in Prebid.
 *
 * All adapters are assumed to support banner ads. Other media types are specified by Adapters when they
 * register themselves with prebid-core.
 */

/**
 * @typedef {('native'|'video'|'banner')} MediaType
 * @typedef {('adpod')} VideoContext
 */

/** @type {MediaType} */
const NATIVE = 'native';
/** @type {MediaType} */
const VIDEO = 'video';
/** @type {MediaType} */
const BANNER = 'banner';
/** @type {VideoContext} */
const ADPOD = 'adpod';
const ALL_MEDIATYPES = [NATIVE, VIDEO, BANNER];

/***/ }),

/***/ "./src/native.js":
/*!***********************!*\
  !*** ./src/native.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NATIVE_TARGETING_KEYS: () => (/* binding */ NATIVE_TARGETING_KEYS),
/* harmony export */   convertOrtbRequestToProprietaryNative: () => (/* binding */ convertOrtbRequestToProprietaryNative),
/* harmony export */   decorateAdUnitsWithNativeParams: () => (/* binding */ decorateAdUnitsWithNativeParams),
/* harmony export */   fireNativeTrackers: () => (/* binding */ fireNativeTrackers),
/* harmony export */   getAllAssetsMessage: () => (/* binding */ getAllAssetsMessage),
/* harmony export */   getAssetMessage: () => (/* binding */ getAssetMessage),
/* harmony export */   getNativeTargeting: () => (/* binding */ getNativeTargeting),
/* harmony export */   isNativeResponse: () => (/* binding */ isNativeResponse),
/* harmony export */   nativeAdapters: () => (/* binding */ nativeAdapters),
/* harmony export */   nativeBidIsValid: () => (/* binding */ nativeBidIsValid),
/* harmony export */   setNativeResponseProperties: () => (/* binding */ setNativeResponseProperties)
/* harmony export */ });
/* unused harmony exports IMAGE, processNativeAdUnitParams, isOpenRTBBidRequestValid, nativeAdUnit, nativeBidder, hasNonNativeBidder, isNativeOpenRTBBidValid, fireImpressionTrackers, fireClickTrackers, getNativeRenderingData, toOrtbNativeRequest, fromOrtbNativeRequest, legacyPropertiesToOrtbNative, toOrtbNativeResponse, toLegacyResponse */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _auctionManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./auctionManager.js */ "./src/auctionManager.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./src/constants.js");
/* harmony import */ var _mediaTypes_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mediaTypes.js */ "./src/mediaTypes.js");
/* harmony import */ var _adRendering_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./adRendering.js */ "./src/adRendering.js");
/* harmony import */ var _creativeRenderers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./creativeRenderers.js */ "./src/creativeRenderers.js");
/* harmony import */ var _eventTrackers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventTrackers.js */ "./src/eventTrackers.js");








/**
 * @typedef {import('../src/adapters/bidderFactory.js').BidRequest} BidRequest
 * @typedef {import('../src/adapters/bidderFactory.js').Bid} Bid
 */

const nativeAdapters = [];
const NATIVE_TARGETING_KEYS = Object.keys(_constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_KEYS).map(key => _constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_KEYS[key]);
const IMAGE = {
  ortb: {
    ver: '1.2',
    assets: [{
      required: 1,
      id: 1,
      img: {
        type: 3,
        wmin: 100,
        hmin: 100
      }
    }, {
      required: 1,
      id: 2,
      title: {
        len: 140
      }
    }, {
      required: 1,
      id: 3,
      data: {
        type: 1
      }
    }, {
      required: 0,
      id: 4,
      data: {
        type: 2
      }
    }, {
      required: 0,
      id: 5,
      img: {
        type: 1,
        wmin: 20,
        hmin: 20
      }
    }]
  },
  image: {
    required: true
  },
  title: {
    required: true
  },
  sponsoredBy: {
    required: true
  },
  clickUrl: {
    required: true
  },
  body: {
    required: false
  },
  icon: {
    required: false
  }
};
const SUPPORTED_TYPES = {
  image: IMAGE
};

// inverse native maps useful for converting to legacy
const PREBID_NATIVE_DATA_KEYS_TO_ORTB_INVERSE = inverse(_constants_js__WEBPACK_IMPORTED_MODULE_0__.PREBID_NATIVE_DATA_KEYS_TO_ORTB);
const NATIVE_ASSET_TYPES_INVERSE = inverse(_constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_ASSET_TYPES);
function isNativeResponse(bidResponse) {
  // check for native data and not mediaType; it's possible
  // to treat banner responses as native
  return bidResponse.native && typeof bidResponse.native === 'object';
}

/**
 * Recieves nativeParams from an adUnit. If the params were not of type 'type',
 * passes them on directly. If they were of type 'type', translate
 * them into the predefined specific asset requests for that type of native ad.
 */
function processNativeAdUnitParams(params) {
  if (params && params.type && typeIsSupported(params.type)) {
    params = SUPPORTED_TYPES[params.type];
  }
  if (params && params.ortb && !isOpenRTBBidRequestValid(params.ortb)) {
    return;
  }
  return params;
}
function decorateAdUnitsWithNativeParams(adUnits) {
  adUnits.forEach(adUnit => {
    const nativeParams = adUnit.nativeParams || adUnit?.mediaTypes?.native;
    if (nativeParams) {
      adUnit.nativeParams = processNativeAdUnitParams(nativeParams);
    }
    if (adUnit.nativeParams) {
      adUnit.nativeOrtbRequest = adUnit.nativeParams.ortb || toOrtbNativeRequest(adUnit.nativeParams);
    }
  });
}
function isOpenRTBBidRequestValid(ortb) {
  const assets = ortb.assets;
  if (!Array.isArray(assets) || assets.length === 0) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`assets in mediaTypes.native.ortb is not an array, or it's empty. Assets: `, assets);
    return false;
  }

  // validate that ids exist, that they are unique and that they are numbers
  const ids = assets.map(asset => asset.id);
  if (assets.length !== new Set(ids).size || ids.some(id => id !== parseInt(id, 10))) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`each asset object must have 'id' property, it must be unique and it must be an integer`);
    return false;
  }
  if (ortb.hasOwnProperty('eventtrackers') && !Array.isArray(ortb.eventtrackers)) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)('ortb.eventtrackers is not an array. Eventtrackers: ', ortb.eventtrackers);
    return false;
  }
  return assets.every(asset => isOpenRTBAssetValid(asset));
}
function isOpenRTBAssetValid(asset) {
  if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(asset)) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`asset must be an object. Provided asset: `, asset);
    return false;
  }
  if (asset.img) {
    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(asset.img.w) && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(asset.img.wmin)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`for img asset there must be 'w' or 'wmin' property`);
      return false;
    }
    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(asset.img.h) && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(asset.img.hmin)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`for img asset there must be 'h' or 'hmin' property`);
      return false;
    }
  } else if (asset.title) {
    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(asset.title.len)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`for title asset there must be 'len' property defined`);
      return false;
    }
  } else if (asset.data) {
    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(asset.data.type)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`for data asset 'type' property must be a number`);
      return false;
    }
  } else if (asset.video) {
    if (!Array.isArray(asset.video.mimes) || !Array.isArray(asset.video.protocols) || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(asset.video.minduration) || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(asset.video.maxduration)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)('video asset is not properly configured');
      return false;
    }
  }
  return true;
}

/**
 * Check if the native type specified in the adUnit is supported by Prebid.
 */
function typeIsSupported(type) {
  if (!(type && Object.keys(SUPPORTED_TYPES).includes(type))) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`${type} nativeParam is not supported`);
    return false;
  }
  return true;
}

/**
 * Helper functions for working with native-enabled adUnits
 * TODO: abstract this and the video helper functions into general
 * adunit validation helper functions
 */
const nativeAdUnit = adUnit => {
  const mediaType = adUnit.mediaType === 'native';
  const mediaTypes = adUnit?.mediaTypes?.native;
  return mediaType || mediaTypes;
};
const nativeBidder = bid => nativeAdapters.includes(bid.bidder);
const hasNonNativeBidder = adUnit => adUnit.bids.filter(bid => !nativeBidder(bid)).length;

/**
 * Validate that the native assets on this bid contain all assets that were
 * marked as required in the adUnit configuration.
 * @param {Bid} bid Native bid to validate
 * @param {BidRequest[]} bidRequests All bid requests for an auction
 * @return {Boolean} If object is valid
 */
function nativeBidIsValid(bid) {
  let {
    index = _auctionManager_js__WEBPACK_IMPORTED_MODULE_2__.auctionManager.index
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const adUnit = index.getAdUnit(bid);
  if (!adUnit) {
    return false;
  }
  let ortbRequest = adUnit.nativeOrtbRequest;
  let ortbResponse = bid.native?.ortb || toOrtbNativeResponse(bid.native, ortbRequest);
  return isNativeOpenRTBBidValid(ortbResponse, ortbRequest);
}
function isNativeOpenRTBBidValid(bidORTB, bidRequestORTB) {
  if (!bidORTB?.link?.url) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`native response doesn't have 'link' property. Ortb response: `, bidORTB);
    return false;
  }
  let requiredAssetIds = bidRequestORTB.assets.filter(asset => asset.required === 1).map(a => a.id);
  let returnedAssetIds = bidORTB.assets.map(asset => asset.id);
  const match = requiredAssetIds.every(assetId => returnedAssetIds.includes(assetId));
  if (!match) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`didn't receive a bid with all required assets. Required ids: ${requiredAssetIds}, but received ids in response: ${returnedAssetIds}`);
  }
  return match;
}

/*
 * Native responses may have associated impression or click trackers.
 * This retrieves the appropriate tracker urls for the given ad object and
 * fires them. As a native creatives may be in a cross-origin frame, it may be
 * necessary to invoke this function via postMessage. secureCreatives is
 * configured to fire this function when it receives a `message` of 'Prebid Native'
 * and an `adId` with the value of the `bid.adId`. When a message is posted with
 * these parameters, impression trackers are fired. To fire click trackers, the
 * message should contain an `action` set to 'click'.
 *
 * // Native creative template example usage
 * <a href="%%CLICK_URL_UNESC%%%%PATTERN:hb_native_linkurl%%"
 *    target="_blank"
 *    onclick="fireTrackers('click')">
 *    %%PATTERN:hb_native_title%%
 * </a>
 *
 * <script>
 *   function fireTrackers(action) {
 *     var message = {message: 'Prebid Native', adId: '%%PATTERN:hb_adid%%'};
 *     if (action === 'click') {message.action = 'click';} // fires click trackers
 *     window.parent.postMessage(JSON.stringify(message), '*');
 *   }
 *   fireTrackers(); // fires impressions when creative is loaded
 * </script>
 */
function fireNativeTrackers(message, bidResponse) {
  const nativeResponse = bidResponse.native.ortb || legacyPropertiesToOrtbNative(bidResponse.native);
  if (message.action === 'click') {
    fireClickTrackers(nativeResponse, message?.assetId);
  } else {
    fireImpressionTrackers(nativeResponse);
  }
  return message.action;
}
function fireImpressionTrackers(nativeResponse) {
  let {
    runMarkup = mkup => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.insertHtmlIntoIframe)(mkup),
    fetchURL = _utils_js__WEBPACK_IMPORTED_MODULE_1__.triggerPixel
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let {
    [_eventTrackers_js__WEBPACK_IMPORTED_MODULE_3__.TRACKER_METHOD_IMG]: img = [],
    [_eventTrackers_js__WEBPACK_IMPORTED_MODULE_3__.TRACKER_METHOD_JS]: js = []
  } = (0,_eventTrackers_js__WEBPACK_IMPORTED_MODULE_3__.parseEventTrackers)(nativeResponse.eventtrackers || [])[_eventTrackers_js__WEBPACK_IMPORTED_MODULE_3__.EVENT_TYPE_IMPRESSION] || {};
  if (nativeResponse.imptrackers) {
    img = img.concat(nativeResponse.imptrackers);
  }
  img.forEach(url => fetchURL(url));
  js = js.map(url => `<script async src="${url}"></script>`);
  if (nativeResponse.jstracker) {
    // jstracker is already HTML markup
    js = js.concat([nativeResponse.jstracker]);
  }
  if (js.length) {
    runMarkup(js.join('\n'));
  }
}
function fireClickTrackers(nativeResponse) {
  let assetId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  let {
    fetchURL = _utils_js__WEBPACK_IMPORTED_MODULE_1__.triggerPixel
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // legacy click tracker
  if (!assetId) {
    (nativeResponse.link?.clicktrackers || []).forEach(url => fetchURL(url));
  } else {
    // ortb click tracker. This will try to call the clicktracker associated with the asset;
    // will fallback to the link if none is found.
    const assetIdLinkMap = (nativeResponse.assets || []).filter(a => a.link).reduce((map, asset) => {
      map[asset.id] = asset.link;
      return map;
    }, {});
    const masterClickTrackers = nativeResponse.link?.clicktrackers || [];
    let assetLink = assetIdLinkMap[assetId];
    let clickTrackers = masterClickTrackers;
    if (assetLink) {
      clickTrackers = assetLink.clicktrackers || [];
    }
    clickTrackers.forEach(url => fetchURL(url));
  }
}
function setNativeResponseProperties(bid, adUnit) {
  const nativeOrtbRequest = adUnit?.nativeOrtbRequest;
  const nativeOrtbResponse = bid.native?.ortb;
  if (nativeOrtbRequest && nativeOrtbResponse) {
    const legacyResponse = toLegacyResponse(nativeOrtbResponse, nativeOrtbRequest);
    Object.assign(bid.native, legacyResponse);
  }
  ['rendererUrl', 'adTemplate'].forEach(prop => {
    const val = adUnit?.nativeParams?.[prop];
    if (val) {
      bid.native[prop] = getAssetValue(val);
    }
  });
}

/**
 * Gets native targeting key-value pairs
 * @param {Object} bid
 * @return {Object} targeting
 */
function getNativeTargeting(bid) {
  let {
    index = _auctionManager_js__WEBPACK_IMPORTED_MODULE_2__.auctionManager.index
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let keyValues = {};
  const adUnit = index.getAdUnit(bid);
  const globalSendTargetingKeys = adUnit?.nativeParams?.ortb == null && adUnit?.nativeParams?.sendTargetingKeys !== false;
  const nativeKeys = getNativeKeys(adUnit);
  const flatBidNativeKeys = {
    ...bid.native,
    ...bid.native.ext
  };
  delete flatBidNativeKeys.ext;
  Object.keys(flatBidNativeKeys).forEach(asset => {
    const key = nativeKeys[asset];
    let value = getAssetValue(bid.native[asset]) || getAssetValue(bid?.native?.ext?.[asset]);
    if (asset === 'adTemplate' || !key || !value) {
      return;
    }
    let sendPlaceholder = adUnit?.nativeParams?.[asset]?.sendId;
    if (typeof sendPlaceholder !== 'boolean') {
      sendPlaceholder = adUnit?.nativeParams?.ext?.[asset]?.sendId;
    }
    if (sendPlaceholder) {
      const placeholder = `${key}:${bid.adId}`;
      value = placeholder;
    }
    let assetSendTargetingKeys = adUnit?.nativeParams?.[asset]?.sendTargetingKeys;
    if (typeof assetSendTargetingKeys !== 'boolean') {
      assetSendTargetingKeys = adUnit?.nativeParams?.ext?.[asset]?.sendTargetingKeys;
    }
    const sendTargeting = typeof assetSendTargetingKeys === 'boolean' ? assetSendTargetingKeys : globalSendTargetingKeys;
    if (sendTargeting) {
      keyValues[key] = value;
    }
  });
  return keyValues;
}
function getNativeAssets(nativeProps, keys) {
  let ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let assets = [];
  Object.entries(nativeProps).filter(_ref => {
    let [k, v] = _ref;
    return v && (ext === false && k === 'ext' || keys == null || keys.includes(k));
  }).forEach(_ref2 => {
    let [key, value] = _ref2;
    if (ext === false && key === 'ext') {
      assets.push(...getNativeAssets(value, keys, true));
    } else if (ext || _constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_KEYS.hasOwnProperty(key)) {
      assets.push({
        key,
        value: getAssetValue(value)
      });
    }
  });
  return assets;
}
function getNativeRenderingData(bid, adUnit, keys) {
  const data = {
    ...(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getDefinedParams)(bid.native, ['rendererUrl', 'adTemplate']),
    assets: getNativeAssets(bid.native, keys),
    nativeKeys: _constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_KEYS
  };
  if (bid.native.ortb) {
    data.ortb = bid.native.ortb;
  } else if (adUnit.mediaTypes?.native?.ortb) {
    data.ortb = toOrtbNativeResponse(bid.native, adUnit.nativeOrtbRequest);
  }
  return data;
}
function assetsMessage(data, adObject, keys) {
  let {
    index = _auctionManager_js__WEBPACK_IMPORTED_MODULE_2__.auctionManager.index
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const msg = {
    message: 'assetResponse',
    adId: data.adId
  };
  let renderData = (0,_adRendering_js__WEBPACK_IMPORTED_MODULE_4__.getRenderingData)(adObject).native;
  if (renderData) {
    // if we have native rendering data (set up by the nativeRendering module)
    // include it in full ("all assets") together with the renderer.
    // this is to allow PUC to use dynamic renderers without requiring changes in creative setup
    msg.native = Object.assign({}, renderData);
    msg.renderer = (0,_creativeRenderers_js__WEBPACK_IMPORTED_MODULE_5__.getCreativeRendererSource)(adObject);
    msg.rendererVersion = _creativeRenderers_js__WEBPACK_IMPORTED_MODULE_5__.PUC_MIN_VERSION;
    if (keys != null) {
      renderData.assets = renderData.assets.filter(_ref3 => {
        let {
          key
        } = _ref3;
        return keys.includes(key);
      });
    }
  } else {
    renderData = getNativeRenderingData(adObject, index.getAdUnit(adObject), keys);
  }
  return Object.assign(msg, renderData);
}
const NATIVE_KEYS_INVERTED = Object.fromEntries(Object.entries(_constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_KEYS).map(_ref4 => {
  let [k, v] = _ref4;
  return [v, k];
}));

/**
 * Constructs a message object containing asset values for each of the
 * requested data keys.
 */
function getAssetMessage(data, adObject) {
  const keys = data.assets.map(k => NATIVE_KEYS_INVERTED[k]);
  return assetsMessage(data, adObject, keys);
}
function getAllAssetsMessage(data, adObject) {
  return assetsMessage(data, adObject, null);
}

/**
 * Native assets can be a string or an object with a url prop. Returns the value
 * appropriate for sending in adserver targeting or placeholder replacement.
 */
function getAssetValue(value) {
  return value?.url || value;
}
function getNativeKeys(adUnit) {
  const extraNativeKeys = {};
  if (adUnit?.nativeParams?.ext) {
    Object.keys(adUnit.nativeParams.ext).forEach(extKey => {
      extraNativeKeys[extKey] = `hb_native_${extKey}`;
    });
  }
  return {
    ..._constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_KEYS,
    ...extraNativeKeys
  };
}

/**
 * converts Prebid legacy native assets request to OpenRTB format
 * @param {object} legacyNativeAssets an object that describes a native bid request in Prebid proprietary format
 * @returns an OpenRTB format of the same bid request
 */
function toOrtbNativeRequest(legacyNativeAssets) {
  if (!legacyNativeAssets && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(legacyNativeAssets)) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)('Native assets object is empty or not an object: ', legacyNativeAssets);
    return;
  }
  const ortb = {
    ver: '1.2',
    assets: []
  };
  for (let key in legacyNativeAssets) {
    // skip conversion for non-asset keys
    if (_constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_KEYS_THAT_ARE_NOT_ASSETS.includes(key)) continue;
    if (!_constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_KEYS.hasOwnProperty(key)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`Unrecognized native asset code: ${key}. Asset will be ignored.`);
      continue;
    }
    if (key === 'privacyLink') {
      ortb.privacy = 1;
      continue;
    }
    const asset = legacyNativeAssets[key];
    let required = 0;
    if (asset.required && (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(asset.required)) {
      required = Number(asset.required);
    }
    const ortbAsset = {
      id: ortb.assets.length,
      required
    };
    // data cases
    if (key in _constants_js__WEBPACK_IMPORTED_MODULE_0__.PREBID_NATIVE_DATA_KEYS_TO_ORTB) {
      ortbAsset.data = {
        type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_ASSET_TYPES[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PREBID_NATIVE_DATA_KEYS_TO_ORTB[key]]
      };
      if (asset.len) {
        ortbAsset.data.len = asset.len;
      }
      // icon or image case
    } else if (key === 'icon' || key === 'image') {
      ortbAsset.img = {
        type: key === 'icon' ? _constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_IMAGE_TYPES.ICON : _constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_IMAGE_TYPES.MAIN
      };
      // if min_width and min_height are defined in aspect_ratio, they are preferred
      if (asset.aspect_ratios) {
        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(asset.aspect_ratios)) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)("image.aspect_ratios was passed, but it's not a an array:", asset.aspect_ratios);
        } else if (!asset.aspect_ratios.length) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)("image.aspect_ratios was passed, but it's empty:", asset.aspect_ratios);
        } else {
          const {
            min_width: minWidth,
            min_height: minHeight
          } = asset.aspect_ratios[0];
          if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isInteger)(minWidth) || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isInteger)(minHeight)) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)('image.aspect_ratios min_width or min_height are invalid: ', minWidth, minHeight);
          } else {
            ortbAsset.img.wmin = minWidth;
            ortbAsset.img.hmin = minHeight;
          }
          const aspectRatios = asset.aspect_ratios.filter(ar => ar.ratio_width && ar.ratio_height).map(ratio => `${ratio.ratio_width}:${ratio.ratio_height}`);
          if (aspectRatios.length > 0) {
            ortbAsset.img.ext = {
              aspectratios: aspectRatios
            };
          }
        }
      }

      // if asset.sizes exist, by OpenRTB spec we should remove wmin and hmin
      if (asset.sizes) {
        if (asset.sizes.length !== 2 || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isInteger)(asset.sizes[0]) || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isInteger)(asset.sizes[1])) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)('image.sizes was passed, but its value is not an array of integers:', asset.sizes);
        } else {
          ortbAsset.img.w = asset.sizes[0];
          ortbAsset.img.h = asset.sizes[1];
          delete ortbAsset.img.hmin;
          delete ortbAsset.img.wmin;
        }
      }
      // title case
    } else if (key === 'title') {
      ortbAsset.title = {
        // in openRTB, len is required for titles, while in legacy prebid was not.
        // for this reason, if len is missing in legacy prebid, we're adding a default value of 140.
        len: asset.len || 140
      };
      // all extensions to the native bid request are passed as is
    } else if (key === 'ext') {
      ortbAsset.ext = asset;
      // in `ext` case, required field is not needed
      delete ortbAsset.required;
    }
    ortb.assets.push(ortbAsset);
  }
  return ortb;
}

/**
 * Greatest common divisor between two positive integers
 * https://en.wikipedia.org/wiki/Euclidean_algorithm
 */
function gcd(a, b) {
  while (a && b && a !== b) {
    if (a > b) {
      a = a - b;
    } else {
      b = b - a;
    }
  }
  return a || b;
}

/**
 * This function converts an OpenRTB native request object to Prebid proprietary
 * format. The purpose of this function is to help adapters to handle the
 * transition phase where publishers may be using OpenRTB objects but the
 *  bidder does not yet support it.
 * @param {object} openRTBRequest an OpenRTB v1.2 request object
 * @returns a Prebid legacy native format request
 */
function fromOrtbNativeRequest(openRTBRequest) {
  if (!isOpenRTBBidRequestValid(openRTBRequest)) {
    return;
  }
  const oldNativeObject = {};
  for (const asset of openRTBRequest.assets) {
    if (asset.title) {
      const title = {
        required: asset.required ? Boolean(asset.required) : false,
        len: asset.title.len
      };
      oldNativeObject.title = title;
    } else if (asset.img) {
      const image = {
        required: asset.required ? Boolean(asset.required) : false
      };
      if (asset.img.w && asset.img.h) {
        image.sizes = [asset.img.w, asset.img.h];
      } else if (asset.img.wmin && asset.img.hmin) {
        const scale = gcd(asset.img.wmin, asset.img.hmin);
        image.aspect_ratios = [{
          min_width: asset.img.wmin,
          min_height: asset.img.hmin,
          ratio_width: asset.img.wmin / scale,
          ratio_height: asset.img.hmin / scale
        }];
      }
      if (asset.img.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_IMAGE_TYPES.MAIN) {
        oldNativeObject.image = image;
      } else {
        oldNativeObject.icon = image;
      }
    } else if (asset.data) {
      let assetType = Object.keys(_constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_ASSET_TYPES).find(k => _constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_ASSET_TYPES[k] === asset.data.type);
      let prebidAssetName = Object.keys(_constants_js__WEBPACK_IMPORTED_MODULE_0__.PREBID_NATIVE_DATA_KEYS_TO_ORTB).find(k => _constants_js__WEBPACK_IMPORTED_MODULE_0__.PREBID_NATIVE_DATA_KEYS_TO_ORTB[k] === assetType);
      oldNativeObject[prebidAssetName] = {
        required: asset.required ? Boolean(asset.required) : false
      };
      if (asset.data.len) {
        oldNativeObject[prebidAssetName].len = asset.data.len;
      }
    }
    if (openRTBRequest.privacy) {
      oldNativeObject.privacyLink = {
        required: false
      };
    }
    // video was not supported by old prebid assets
  }
  return oldNativeObject;
}

/**
 * Converts an OpenRTB request to a proprietary Prebid.js format.
 * The proprietary Prebid format has many limitations and will be dropped in
 * the future; adapters are encouraged to stop using it in favour of OpenRTB format.
 * IMPLEMENTATION DETAILS: This function returns the same exact object if no
 * conversion is needed. If a conversion is needed (meaning, at least one
 * bidRequest contains a native.ortb definition), it will return a copy.
 *
 * @param {BidRequest[]} bidRequests an array of valid bid requests
 * @returns an array of valid bid requests where the openRTB bids are converted to proprietary format.
 */
function convertOrtbRequestToProprietaryNative(bidRequests) {
  if (true) {
    if (!bidRequests || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(bidRequests)) return bidRequests;
    // check if a conversion is needed
    if (!bidRequests.some(bidRequest => (bidRequest?.mediaTypes || {})[_mediaTypes_js__WEBPACK_IMPORTED_MODULE_6__.NATIVE]?.ortb)) {
      return bidRequests;
    }
    let bidRequestsCopy = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.deepClone)(bidRequests);
    // convert Native ORTB definition to old-style prebid native definition
    for (const bidRequest of bidRequestsCopy) {
      if (bidRequest.mediaTypes && bidRequest.mediaTypes[_mediaTypes_js__WEBPACK_IMPORTED_MODULE_6__.NATIVE] && bidRequest.mediaTypes[_mediaTypes_js__WEBPACK_IMPORTED_MODULE_6__.NATIVE].ortb) {
        bidRequest.mediaTypes[_mediaTypes_js__WEBPACK_IMPORTED_MODULE_6__.NATIVE] = Object.assign((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.pick)(bidRequest.mediaTypes[_mediaTypes_js__WEBPACK_IMPORTED_MODULE_6__.NATIVE], _constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_KEYS_THAT_ARE_NOT_ASSETS), fromOrtbNativeRequest(bidRequest.mediaTypes[_mediaTypes_js__WEBPACK_IMPORTED_MODULE_6__.NATIVE].ortb));
        bidRequest.nativeParams = processNativeAdUnitParams(bidRequest.mediaTypes[_mediaTypes_js__WEBPACK_IMPORTED_MODULE_6__.NATIVE]);
      }
    }
    return bidRequestsCopy;
  }
  return bidRequests;
}

/**
 * convert PBJS proprietary native properties that are *not* assets to the ORTB native format.
 *
 * @param legacyNative `bidResponse.native` object as returned by adapters
 */
function legacyPropertiesToOrtbNative(legacyNative) {
  const response = {
    link: {},
    eventtrackers: []
  };
  Object.entries(legacyNative).forEach(_ref5 => {
    let [key, value] = _ref5;
    switch (key) {
      case 'clickUrl':
        response.link.url = value;
        break;
      case 'clickTrackers':
        response.link.clicktrackers = Array.isArray(value) ? value : [value];
        break;
      case 'impressionTrackers':
        (Array.isArray(value) ? value : [value]).forEach(url => {
          response.eventtrackers.push({
            event: _eventTrackers_js__WEBPACK_IMPORTED_MODULE_3__.EVENT_TYPE_IMPRESSION,
            method: _eventTrackers_js__WEBPACK_IMPORTED_MODULE_3__.TRACKER_METHOD_IMG,
            url
          });
        });
        break;
      case 'javascriptTrackers':
        // jstracker is deprecated, but we need to use it here since 'javascriptTrackers' is markup, not an url
        // TODO: at the time of writing this, core expected javascriptTrackers to be a string (despite the name),
        // but many adapters are passing an array. It's possible that some of them are, in fact, passing URLs and not markup
        // in general, native trackers seem to be neglected and/or broken
        response.jstracker = Array.isArray(value) ? value.join('') : value;
        break;
      case 'privacyLink':
        response.privacy = value;
        break;
    }
  });
  return response;
}
function toOrtbNativeResponse(legacyResponse, ortbRequest) {
  const ortbResponse = {
    ...legacyPropertiesToOrtbNative(legacyResponse),
    assets: []
  };
  function useRequestAsset(predicate, fn) {
    let asset = ortbRequest.assets.find(predicate);
    if (asset != null) {
      asset = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.deepClone)(asset);
      fn(asset);
      ortbResponse.assets.push(asset);
    }
  }
  Object.keys(legacyResponse).filter(key => !!legacyResponse[key]).forEach(key => {
    const value = getAssetValue(legacyResponse[key]);
    switch (key) {
      // process titles
      case 'title':
        useRequestAsset(asset => asset.title != null, titleAsset => {
          titleAsset.title = {
            text: value
          };
        });
        break;
      case 'image':
      case 'icon':
        const imageType = key === 'image' ? _constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_IMAGE_TYPES.MAIN : _constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_IMAGE_TYPES.ICON;
        useRequestAsset(asset => asset.img != null && asset.img.type === imageType, imageAsset => {
          imageAsset.img = {
            url: value
          };
        });
        break;
      default:
        if (key in _constants_js__WEBPACK_IMPORTED_MODULE_0__.PREBID_NATIVE_DATA_KEYS_TO_ORTB) {
          useRequestAsset(asset => asset.data != null && asset.data.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_ASSET_TYPES[_constants_js__WEBPACK_IMPORTED_MODULE_0__.PREBID_NATIVE_DATA_KEYS_TO_ORTB[key]], dataAsset => {
            dataAsset.data = {
              value
            };
          });
        }
        break;
    }
  });
  return ortbResponse;
}

/**
 * Generates a legacy response from an ortb response. Useful during the transition period.
 * @param {*} ortbResponse a standard ortb response object
 * @param {*} ortbRequest the ortb request, useful to match ids.
 * @returns an object containing the response in legacy native format: { title: "this is a title", image: ... }
 */
function toLegacyResponse(ortbResponse, ortbRequest) {
  const legacyResponse = {};
  const requestAssets = ortbRequest?.assets || [];
  legacyResponse.clickUrl = ortbResponse.link?.url;
  legacyResponse.privacyLink = ortbResponse.privacy;
  for (const asset of ortbResponse?.assets || []) {
    const requestAsset = requestAssets.find(reqAsset => asset.id === reqAsset.id);
    if (asset.title) {
      legacyResponse.title = asset.title.text;
    } else if (asset.img) {
      legacyResponse[requestAsset?.img?.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_IMAGE_TYPES.MAIN ? 'image' : 'icon'] = {
        url: asset.img.url,
        width: asset.img.w,
        height: asset.img.h
      };
    } else if (asset.data) {
      legacyResponse[PREBID_NATIVE_DATA_KEYS_TO_ORTB_INVERSE[NATIVE_ASSET_TYPES_INVERSE[requestAsset?.data?.type]]] = asset.data.value;
    }
  }

  // Handle trackers
  legacyResponse.impressionTrackers = [];
  let jsTrackers = [];
  if (ortbResponse.imptrackers) {
    legacyResponse.impressionTrackers.push(...ortbResponse.imptrackers);
  }
  for (const eventTracker of ortbResponse?.eventtrackers || []) {
    if (eventTracker.event === _eventTrackers_js__WEBPACK_IMPORTED_MODULE_3__.EVENT_TYPE_IMPRESSION && eventTracker.method === _eventTrackers_js__WEBPACK_IMPORTED_MODULE_3__.TRACKER_METHOD_IMG) {
      legacyResponse.impressionTrackers.push(eventTracker.url);
    }
    if (eventTracker.event === _eventTrackers_js__WEBPACK_IMPORTED_MODULE_3__.EVENT_TYPE_IMPRESSION && eventTracker.method === _eventTrackers_js__WEBPACK_IMPORTED_MODULE_3__.TRACKER_METHOD_JS) {
      jsTrackers.push(eventTracker.url);
    }
  }
  jsTrackers = jsTrackers.map(url => `<script async src="${url}"></script>`);
  if (ortbResponse?.jstracker) {
    jsTrackers.push(ortbResponse.jstracker);
  }
  if (jsTrackers.length) {
    legacyResponse.javascriptTrackers = jsTrackers.join('\n');
  }
  return legacyResponse;
}

/**
 * Inverts key-values of an object.
 */
function inverse(obj) {
  var retobj = {};
  for (var key in obj) {
    retobj[obj[key]] = key;
  }
  return retobj;
}

/***/ }),

/***/ "./src/pbjsORTB.js":
/*!*************************!*\
  !*** ./src/pbjsORTB.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BID_RESPONSE: () => (/* binding */ BID_RESPONSE),
/* harmony export */   DEFAULT: () => (/* binding */ DEFAULT),
/* harmony export */   IMP: () => (/* binding */ IMP),
/* harmony export */   PBS: () => (/* binding */ PBS),
/* harmony export */   PROCESSOR_TYPES: () => (/* binding */ PROCESSOR_TYPES),
/* harmony export */   REQUEST: () => (/* binding */ REQUEST),
/* harmony export */   RESPONSE: () => (/* binding */ RESPONSE),
/* harmony export */   getProcessors: () => (/* binding */ getProcessors),
/* harmony export */   registerOrtbProcessor: () => (/* binding */ registerOrtbProcessor)
/* harmony export */ });
/* unused harmony exports PROCESSOR_DIALECTS, processorRegistry */
const PROCESSOR_TYPES = ['request', 'imp', 'bidResponse', 'response'];
const PROCESSOR_DIALECTS = ['default', 'pbs'];
const [REQUEST, IMP, BID_RESPONSE, RESPONSE] = PROCESSOR_TYPES;
const [DEFAULT, PBS] = PROCESSOR_DIALECTS;
const types = new Set(PROCESSOR_TYPES);
function processorRegistry() {
  const processors = {};
  return {
    registerOrtbProcessor(_ref) {
      let {
        type,
        name,
        fn,
        priority = 0,
        dialects = [DEFAULT]
      } = _ref;
      if (!types.has(type)) {
        throw new Error(`ORTB processor type must be one of: ${PROCESSOR_TYPES.join(', ')}`);
      }
      dialects.forEach(dialect => {
        if (!processors.hasOwnProperty(dialect)) {
          processors[dialect] = {};
        }
        if (!processors[dialect].hasOwnProperty(type)) {
          processors[dialect][type] = {};
        }
        processors[dialect][type][name] = {
          priority,
          fn
        };
      });
    },
    getProcessors(dialect) {
      return processors[dialect] || {};
    }
  };
}
const {
  registerOrtbProcessor,
  getProcessors
} = processorRegistry();

/***/ }),

/***/ "./src/prebid.js":
/*!***********************!*\
  !*** ./src/prebid.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkAdUnitSetup: () => (/* binding */ checkAdUnitSetup),
/* harmony export */   startAuction: () => (/* binding */ startAuction)
/* harmony export */ });
/* unused harmony exports syncOrtb2, adUnitSetupChecks, executeCallbacks */
/* harmony import */ var _prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _secureCreatives_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./secureCreatives.js */ "./src/secureCreatives.js");
/* harmony import */ var _userSync_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./userSync.js */ "./src/userSync.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./config.js */ "./src/config.js");
/* harmony import */ var _auctionManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./auctionManager.js */ "./src/auctionManager.js");
/* harmony import */ var _targeting_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./targeting.js */ "./src/targeting.js");
/* harmony import */ var _hook_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./hook.js */ "./src/hook.js");
/* harmony import */ var _debugging_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./debugging.js */ "./src/debugging.js");
/* harmony import */ var _bidfactory_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./bidfactory.js */ "./src/bidfactory.js");
/* harmony import */ var _storageManager_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./storageManager.js */ "./src/storageManager.js");
/* harmony import */ var _adapterManager_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./adapterManager.js */ "./src/adapterManager.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ "./src/constants.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./events.js */ "./src/events.js");
/* harmony import */ var _utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./utils/perfMetrics.js */ "./src/utils/perfMetrics.js");
/* harmony import */ var _utils_promise_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _fpd_enrichment_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./fpd/enrichment.js */ "./src/fpd/enrichment.js");
/* harmony import */ var _consentHandler_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./consentHandler.js */ "./src/consentHandler.js");
/* harmony import */ var _adRendering_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./adRendering.js */ "./src/adRendering.js");
/* harmony import */ var _utils_reducers_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/reducers.js */ "./src/utils/reducers.js");
/* harmony import */ var _video_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./video.js */ "./src/video.js");
/* harmony import */ var _banner_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./banner.js */ "./src/banner.js");
/* harmony import */ var _mediaTypes_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mediaTypes.js */ "./src/mediaTypes.js");
/* harmony import */ var _utils_prerendering_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utils/prerendering.js */ "./src/utils/prerendering.js");
/* harmony import */ var _adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./adapters/bidderFactory.js */ "./src/adapters/bidderFactory.js");
/** @module pbjs */


























const pbjsInstance = (0,_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__.getGlobal)();
const {
  triggerUserSyncs
} = _userSync_js__WEBPACK_IMPORTED_MODULE_1__.userSync;

/* private variables */
const {
  ADD_AD_UNITS,
  REQUEST_BIDS,
  SET_TARGETING
} = _constants_js__WEBPACK_IMPORTED_MODULE_2__.EVENTS;
const eventValidators = {
  bidWon: checkDefinedPlacement
};

// initialize existing debugging sessions if present
(0,_debugging_js__WEBPACK_IMPORTED_MODULE_3__.loadSession)();

/* Public vars */
pbjsInstance.bidderSettings = pbjsInstance.bidderSettings || {};

// let the world know we are loaded
pbjsInstance.libLoaded = true;

// version auto generated from build
pbjsInstance.version = "v9.49.0-pre";
(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Prebid.js v9.49.0-pre loaded");
pbjsInstance.installedModules = pbjsInstance.installedModules || [];

// create adUnit array
pbjsInstance.adUnits = pbjsInstance.adUnits || [];

// Allow publishers who enable user sync override to trigger their sync
pbjsInstance.triggerUserSyncs = triggerUserSyncs;
function checkDefinedPlacement(id) {
  var adUnitCodes = _auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager.getBidsRequested().map(bidSet => bidSet.bids.map(bid => bid.adUnitCode)).reduce(_utils_js__WEBPACK_IMPORTED_MODULE_4__.flatten).filter(_utils_js__WEBPACK_IMPORTED_MODULE_4__.uniques);
  if (!adUnitCodes.includes(id)) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('The "' + id + '" placement is not defined.');
    return;
  }
  return true;
}
function validateSizes(sizes, targLength) {
  let cleanSizes = [];
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(sizes) && (targLength ? sizes.length === targLength : sizes.length > 0)) {
    // check if an array of arrays or array of numbers
    if (sizes.every(sz => (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isArrayOfNums)(sz, 2))) {
      cleanSizes = sizes;
    } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isArrayOfNums)(sizes, 2)) {
      cleanSizes.push(sizes);
    }
  }
  return cleanSizes;
}

// synchronize fields between mediaTypes[mediaType] and ortb2Imp[mediaType]
function syncOrtb2(adUnit, mediaType) {
  const ortb2Imp = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__["default"])(adUnit, `ortb2Imp.${mediaType}`);
  const mediaTypes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__["default"])(adUnit, `mediaTypes.${mediaType}`);
  if (!ortb2Imp && !mediaTypes) {
    // omitting sync due to not present mediaType
    return;
  }
  const fields = {
    [_mediaTypes_js__WEBPACK_IMPORTED_MODULE_7__.VIDEO]:  true && _video_js__WEBPACK_IMPORTED_MODULE_8__.ORTB_VIDEO_PARAMS,
    [_mediaTypes_js__WEBPACK_IMPORTED_MODULE_7__.BANNER]: _banner_js__WEBPACK_IMPORTED_MODULE_9__.ORTB_BANNER_PARAMS
  }[mediaType];
  if (!fields) {
    return;
  }
  [...fields].forEach(_ref => {
    let [key, validator] = _ref;
    const mediaTypesFieldValue = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__["default"])(adUnit, `mediaTypes.${mediaType}.${key}`);
    const ortbFieldValue = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__["default"])(adUnit, `ortb2Imp.${mediaType}.${key}`);
    if (mediaTypesFieldValue == undefined && ortbFieldValue == undefined) {
      // omitting the params if it's not defined on either of sides
    } else if (mediaTypesFieldValue == undefined) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_10__.dset)(adUnit, `mediaTypes.${mediaType}.${key}`, ortbFieldValue);
    } else if (ortbFieldValue == undefined) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_10__.dset)(adUnit, `ortb2Imp.${mediaType}.${key}`, mediaTypesFieldValue);
    } else {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logWarn)(`adUnit ${adUnit.code}: specifies conflicting ortb2Imp.${mediaType}.${key} and mediaTypes.${mediaType}.${key}, the latter will be ignored`, adUnit);
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_10__.dset)(adUnit, `mediaTypes.${mediaType}.${key}`, ortbFieldValue);
    }
  });
}
function validateBannerMediaType(adUnit) {
  const validatedAdUnit = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.deepClone)(adUnit);
  const banner = validatedAdUnit.mediaTypes.banner;
  const bannerSizes = banner.sizes == null ? null : validateSizes(banner.sizes);
  const format = adUnit.ortb2Imp?.banner?.format ?? banner?.format;
  let formatSizes;
  if (format != null) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_10__.dset)(validatedAdUnit, 'ortb2Imp.banner.format', format);
    banner.format = format;
    try {
      formatSizes = format.filter(_ref2 => {
        let {
          w,
          h,
          wratio,
          hratio
        } = _ref2;
        if ((w ?? h) != null && (wratio ?? hratio) != null) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logWarn)(`Ad unit banner.format specifies both w/h and wratio/hratio`, adUnit);
          return false;
        }
        return w != null && h != null || wratio != null && hratio != null;
      }).map(_ref3 => {
        let {
          w,
          h,
          wratio,
          hratio
        } = _ref3;
        return [w ?? wratio, h ?? hratio];
      });
    } catch (e) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)(`Invalid format definition on ad unit ${adUnit.code}`, format);
    }
    if (formatSizes != null && bannerSizes != null && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(bannerSizes, formatSizes)) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logWarn)(`Ad unit ${adUnit.code} has conflicting sizes and format definitions`, adUnit);
    }
  }
  const sizes = formatSizes ?? bannerSizes ?? [];
  const expdir = adUnit.ortb2Imp?.banner?.expdir ?? banner.expdir;
  if (expdir != null) {
    banner.expdir = expdir;
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_10__.dset)(validatedAdUnit, 'ortb2Imp.banner.expdir', expdir);
  }
  if (sizes.length > 0) {
    banner.sizes = sizes;
    // Deprecation Warning: This property will be deprecated in next release in favor of adUnit.mediaTypes.banner.sizes
    validatedAdUnit.sizes = sizes;
  } else {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('Detected a mediaTypes.banner object without a proper sizes field.  Please ensure the sizes are listed like: [[300, 250], ...].  Removing invalid mediaTypes.banner object from request.');
    delete validatedAdUnit.mediaTypes.banner;
  }
  syncOrtb2(validatedAdUnit, 'banner');
  return validatedAdUnit;
}
function validateVideoMediaType(adUnit) {
  const validatedAdUnit = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.deepClone)(adUnit);
  const video = validatedAdUnit.mediaTypes.video;
  if (video.playerSize) {
    let tarPlayerSizeLen = typeof video.playerSize[0] === 'number' ? 2 : 1;
    const videoSizes = validateSizes(video.playerSize, tarPlayerSizeLen);
    if (videoSizes.length > 0) {
      if (tarPlayerSizeLen === 2) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)('Transforming video.playerSize from [640,480] to [[640,480]] so it\'s in the proper format.');
      }
      video.playerSize = videoSizes;
      // Deprecation Warning: This property will be deprecated in next release in favor of adUnit.mediaTypes.video.playerSize
      validatedAdUnit.sizes = videoSizes;
    } else {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('Detected incorrect configuration of mediaTypes.video.playerSize.  Please specify only one set of dimensions in a format like: [[640, 480]]. Removing invalid mediaTypes.video.playerSize property from request.');
      delete validatedAdUnit.mediaTypes.video.playerSize;
    }
  }
  (0,_video_js__WEBPACK_IMPORTED_MODULE_8__.validateOrtbVideoFields)(validatedAdUnit);
  syncOrtb2(validatedAdUnit, 'video');
  return validatedAdUnit;
}
function validateNativeMediaType(adUnit) {
  function err(msg) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)(`Error in adUnit "${adUnit.code}": ${msg}. Removing native request from ad unit`, adUnit);
    delete validatedAdUnit.mediaTypes.native;
    return validatedAdUnit;
  }
  function checkDeprecated(onDeprecated) {
    for (const key of ['sendTargetingKeys', 'types']) {
      if (native.hasOwnProperty(key)) {
        const res = onDeprecated(key);
        if (res) return res;
      }
    }
  }
  const validatedAdUnit = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.deepClone)(adUnit);
  const native = validatedAdUnit.mediaTypes.native;
  // if native assets are specified in OpenRTB format, remove legacy assets and print a warn.
  if (native.ortb) {
    if (native.ortb.assets?.some(asset => !(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isNumber)(asset.id) || asset.id < 0 || asset.id % 1 !== 0)) {
      return err('native asset ID must be a nonnegative integer');
    }
    if (checkDeprecated(key => err(`ORTB native requests cannot specify "${key}"`))) {
      return validatedAdUnit;
    }
    const legacyNativeKeys = Object.keys(_constants_js__WEBPACK_IMPORTED_MODULE_2__.NATIVE_KEYS).filter(key => _constants_js__WEBPACK_IMPORTED_MODULE_2__.NATIVE_KEYS[key].includes('hb_native_'));
    const nativeKeys = Object.keys(native);
    const intersection = nativeKeys.filter(nativeKey => legacyNativeKeys.includes(nativeKey));
    if (intersection.length > 0) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)(`when using native OpenRTB format, you cannot use legacy native properties. Deleting ${intersection} keys from request.`);
      intersection.forEach(legacyKey => delete validatedAdUnit.mediaTypes.native[legacyKey]);
    }
  } else {
    checkDeprecated(key => `mediaTypes.native.${key} is deprecated, consider using native ORTB instead`, adUnit);
  }
  if (native.image && native.image.sizes && !Array.isArray(native.image.sizes)) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('Please use an array of sizes for native.image.sizes field.  Removing invalid mediaTypes.native.image.sizes property from request.');
    delete validatedAdUnit.mediaTypes.native.image.sizes;
  }
  if (native.image && native.image.aspect_ratios && !Array.isArray(native.image.aspect_ratios)) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('Please use an array of sizes for native.image.aspect_ratios field.  Removing invalid mediaTypes.native.image.aspect_ratios property from request.');
    delete validatedAdUnit.mediaTypes.native.image.aspect_ratios;
  }
  if (native.icon && native.icon.sizes && !Array.isArray(native.icon.sizes)) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('Please use an array of sizes for native.icon.sizes field.  Removing invalid mediaTypes.native.icon.sizes property from request.');
    delete validatedAdUnit.mediaTypes.native.icon.sizes;
  }
  return validatedAdUnit;
}
function validateAdUnitPos(adUnit, mediaType) {
  let pos = adUnit?.mediaTypes?.[mediaType]?.pos;
  if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isNumber)(pos) || isNaN(pos) || !isFinite(pos)) {
    let warning = `Value of property 'pos' on ad unit ${adUnit.code} should be of type: Number`;
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logWarn)(warning);
    delete adUnit.mediaTypes[mediaType].pos;
  }
  return adUnit;
}
function validateAdUnit(adUnit) {
  const msg = msg => `adUnit.code '${adUnit.code}' ${msg}`;
  const mediaTypes = adUnit.mediaTypes;
  const bids = adUnit.bids;
  if (bids != null && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(bids)) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)(msg(`defines 'adUnit.bids' that is not an array. Removing adUnit from auction`));
    return null;
  }
  if (bids == null && adUnit.ortb2Imp == null) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)(msg(`has no 'adUnit.bids' and no 'adUnit.ortb2Imp'. Removing adUnit from auction`));
    return null;
  }
  if (!mediaTypes || Object.keys(mediaTypes).length === 0) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)(msg(`does not define a 'mediaTypes' object.  This is a required field for the auction, so this adUnit has been removed.`));
    return null;
  }
  if (adUnit.ortb2Imp != null && (bids == null || bids.length === 0)) {
    adUnit.bids = [{
      bidder: null
    }]; // the 'null' bidder is treated as an s2s-only placeholder by adapterManager
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logMessage)(msg(`defines 'adUnit.ortb2Imp' with no 'adUnit.bids'; it will be seen only by S2S adapters`));
  }
  return adUnit;
}
const adUnitSetupChecks = {
  validateAdUnit,
  validateBannerMediaType,
  validateSizes
};
if (true) {
  Object.assign(adUnitSetupChecks, {
    validateNativeMediaType
  });
}
if (true) {
  Object.assign(adUnitSetupChecks, {
    validateVideoMediaType
  });
}
const checkAdUnitSetup = (0,_hook_js__WEBPACK_IMPORTED_MODULE_11__.hook)('sync', function (adUnits) {
  const validatedAdUnits = [];
  adUnits.forEach(adUnit => {
    adUnit = validateAdUnit(adUnit);
    if (adUnit == null) return;
    const mediaTypes = adUnit.mediaTypes;
    let validatedBanner, validatedVideo, validatedNative;
    if (mediaTypes.banner) {
      validatedBanner = validateBannerMediaType(adUnit);
      if (mediaTypes.banner.hasOwnProperty('pos')) validatedBanner = validateAdUnitPos(validatedBanner, 'banner');
    }
    if ( true && mediaTypes.video) {
      validatedVideo = validatedBanner ? validateVideoMediaType(validatedBanner) : validateVideoMediaType(adUnit);
      if (mediaTypes.video.hasOwnProperty('pos')) validatedVideo = validateAdUnitPos(validatedVideo, 'video');
    }
    if ( true && mediaTypes.native) {
      validatedNative = validatedVideo ? validateNativeMediaType(validatedVideo) : validatedBanner ? validateNativeMediaType(validatedBanner) : validateNativeMediaType(adUnit);
    }
    const validatedAdUnit = Object.assign({}, validatedBanner, validatedVideo, validatedNative);
    validatedAdUnits.push(validatedAdUnit);
  });
  return validatedAdUnits;
}, 'checkAdUnitSetup');
function fillAdUnitDefaults(adUnits) {
  if (true) {
    adUnits.forEach(au => (0,_video_js__WEBPACK_IMPORTED_MODULE_8__.fillVideoDefaults)(au));
  }
}

/// ///////////////////////////////
//                              //
//    Start Public APIs         //
//                              //
/// ///////////////////////////////

/**
 * This function returns the query string targeting parameters available at this moment for a given ad unit. Note that some bidder's response may not have been received if you call this function too quickly after the requests are sent.
 * @param  {string} [adunitCode] adUnitCode to get the bid responses for
 * @alias module:pbjs.getAdserverTargetingForAdUnitCodeStr
 * @return {Array}  returnObj return bids array
 */
pbjsInstance.getAdserverTargetingForAdUnitCodeStr = function (adunitCode) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.getAdserverTargetingForAdUnitCodeStr", arguments);

  // call to retrieve bids array
  if (adunitCode) {
    var res = pbjsInstance.getAdserverTargetingForAdUnitCode(adunitCode);
    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.transformAdServerTargetingObj)(res);
  } else {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logMessage)('Need to call getAdserverTargetingForAdUnitCodeStr with adunitCode');
  }
};

/**
 * This function returns the query string targeting parameters available at this moment for a given ad unit. Note that some bidder's response may not have been received if you call this function too quickly after the requests are sent.
 * @param adunitCode {string} adUnitCode to get the bid responses for
 * @alias module:pbjs.getHighestUnusedBidResponseForAdUnitCode
 * @returns {Object}  returnObj return bid
 */
pbjsInstance.getHighestUnusedBidResponseForAdUnitCode = function (adunitCode) {
  if (adunitCode) {
    const bid = _auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager.getAllBidsForAdUnitCode(adunitCode).filter(_targeting_js__WEBPACK_IMPORTED_MODULE_12__.isBidUsable);
    return bid.length ? bid.reduce(_utils_reducers_js__WEBPACK_IMPORTED_MODULE_13__.getHighestCpm) : {};
  } else {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logMessage)('Need to call getHighestUnusedBidResponseForAdUnitCode with adunitCode');
  }
};

/**
 * This function returns the query string targeting parameters available at this moment for a given ad unit. Note that some bidder's response may not have been received if you call this function too quickly after the requests are sent.
 * @param adUnitCode {string} adUnitCode to get the bid responses for
 * @alias module:pbjs.getAdserverTargetingForAdUnitCode
 * @returns {Object}  returnObj return bids
 */
pbjsInstance.getAdserverTargetingForAdUnitCode = function (adUnitCode) {
  return pbjsInstance.getAdserverTargeting(adUnitCode)[adUnitCode];
};

/**
 * returns all ad server targeting for all ad units
 * @return {Object} Map of adUnitCodes and targeting values []
 * @alias module:pbjs.getAdserverTargeting
 */

pbjsInstance.getAdserverTargeting = function (adUnitCode) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.getAdserverTargeting", arguments);
  return _targeting_js__WEBPACK_IMPORTED_MODULE_12__.targeting.getAllTargeting(adUnitCode);
};
pbjsInstance.getConsentMetadata = function () {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.getConsentMetadata");
  return _consentHandler_js__WEBPACK_IMPORTED_MODULE_14__.allConsent.getConsentMeta();
};
function getBids(type) {
  const responses = _auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager[type]().filter(bid => _auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager.getAdUnitCodes().includes(bid.adUnitCode));

  // find the last auction id to get responses for most recent auction only
  const currentAuctionId = _auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager.getLastAuctionId();
  return responses.map(bid => bid.adUnitCode).filter(_utils_js__WEBPACK_IMPORTED_MODULE_4__.uniques).map(adUnitCode => responses.filter(bid => bid.auctionId === currentAuctionId && bid.adUnitCode === adUnitCode)).filter(bids => bids && bids[0] && bids[0].adUnitCode).map(bids => {
    return {
      [bids[0].adUnitCode]: {
        bids
      }
    };
  }).reduce((a, b) => Object.assign(a, b), {});
}

/**
 * This function returns the bids requests involved in an auction but not bid on
 * @alias module:pbjs.getNoBids
 * @return {Object}            map | object that contains the bidRequests
 */

pbjsInstance.getNoBids = function () {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.getNoBids", arguments);
  return getBids('getNoBids');
};

/**
 * This function returns the bids requests involved in an auction but not bid on or the specified adUnitCode
 * @param  {string} adUnitCode adUnitCode
 * @alias module:pbjs.getNoBidsForAdUnitCode
 * @return {Object}           bidResponse object
 */

pbjsInstance.getNoBidsForAdUnitCode = function (adUnitCode) {
  const bids = _auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager.getNoBids().filter(bid => bid.adUnitCode === adUnitCode);
  return {
    bids
  };
};

/**
 * This function returns the bid responses at the given moment.
 * @alias module:pbjs.getBidResponses
 * @return {Object}            map | object that contains the bidResponses
 */

pbjsInstance.getBidResponses = function () {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.getBidResponses", arguments);
  return getBids('getBidsReceived');
};

/**
 * Returns bidResponses for the specified adUnitCode
 * @param  {string} adUnitCode adUnitCode
 * @alias module:pbjs.getBidResponsesForAdUnitCode
 * @return {Object}            bidResponse object
 */

pbjsInstance.getBidResponsesForAdUnitCode = function (adUnitCode) {
  const bids = _auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager.getBidsReceived().filter(bid => bid.adUnitCode === adUnitCode);
  return {
    bids
  };
};

/**
 * Set query string targeting on one or more GPT ad units.
 * @param {(string|string[])} adUnit a single `adUnit.code` or multiple.
 * @param {function(object): function(string): boolean} customSlotMatching gets a GoogleTag slot and returns a filter function for adUnitCode, so you can decide to match on either eg. return slot => { return adUnitCode => { return slot.getSlotElementId() === 'myFavoriteDivId'; } };
 * @alias module:pbjs.setTargetingForGPTAsync
 */
pbjsInstance.setTargetingForGPTAsync = function (adUnit, customSlotMatching) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.setTargetingForGPTAsync", arguments);
  if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isGptPubadsDefined)()) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('window.googletag is not defined on the page');
    return;
  }
  _targeting_js__WEBPACK_IMPORTED_MODULE_12__.targeting.setTargetingForGPT(adUnit, customSlotMatching);
};

/**
 * Set query string targeting on all AST (AppNexus Seller Tag) ad units. Note that this function has to be called after all ad units on page are defined. For working example code, see [Using Prebid.js with AppNexus Publisher Ad Server](http://prebid.org/dev-docs/examples/use-prebid-with-appnexus-ad-server.html).
 * @param  {(string|string[])} adUnitCodes adUnitCode or array of adUnitCodes
 * @alias module:pbjs.setTargetingForAst
 */
pbjsInstance.setTargetingForAst = function (adUnitCodes) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.setTargetingForAn", arguments);
  if (!_targeting_js__WEBPACK_IMPORTED_MODULE_12__.targeting.isApntagDefined()) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('window.apntag is not defined on the page');
    return;
  }
  _targeting_js__WEBPACK_IMPORTED_MODULE_12__.targeting.setTargetingForAst(adUnitCodes);

  // emit event
  _events_js__WEBPACK_IMPORTED_MODULE_15__.emit(SET_TARGETING, _targeting_js__WEBPACK_IMPORTED_MODULE_12__.targeting.getAllTargeting());
};

/**
 * This function will render the ad (based on params) in the given iframe document passed through.
 * Note that doc SHOULD NOT be the parent document page as we can't doc.write() asynchronously
 * @param  {Document} doc document
 * @param  {string} id bid id to locate the ad
 * @alias module:pbjs.renderAd
 */
pbjsInstance.renderAd = (0,_hook_js__WEBPACK_IMPORTED_MODULE_11__.hook)('async', function (doc, id, options) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.renderAd", arguments);
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logMessage)('Calling renderAd with adId :' + id);
  (0,_adRendering_js__WEBPACK_IMPORTED_MODULE_16__.renderAdDirect)(doc, id, options);
});

/**
 * Remove adUnit from the $$PREBID_GLOBAL$$ configuration, if there are no addUnitCode(s) it will remove all
 * @param  {string| Array} adUnitCode the adUnitCode(s) to remove
 * @alias module:pbjs.removeAdUnit
 */
pbjsInstance.removeAdUnit = function (adUnitCode) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.removeAdUnit", arguments);
  if (!adUnitCode) {
    pbjsInstance.adUnits = [];
    return;
  }
  let adUnitCodes;
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(adUnitCode)) {
    adUnitCodes = adUnitCode;
  } else {
    adUnitCodes = [adUnitCode];
  }
  adUnitCodes.forEach(adUnitCode => {
    for (let i = pbjsInstance.adUnits.length - 1; i >= 0; i--) {
      if (pbjsInstance.adUnits[i].code === adUnitCode) {
        pbjsInstance.adUnits.splice(i, 1);
      }
    }
  });
};

/**
 * @param {Object} requestOptions
 * @param {function} requestOptions.bidsBackHandler
 * @param {number} requestOptions.timeout
 * @param {Array} requestOptions.adUnits
 * @param {Array} requestOptions.adUnitCodes
 * @param {Array} requestOptions.labels
 * @param {String} requestOptions.auctionId
 * @alias module:pbjs.requestBids
 */
pbjsInstance.requestBids = function () {
  const delegate = (0,_hook_js__WEBPACK_IMPORTED_MODULE_11__.hook)('async', function () {
    let {
      bidsBackHandler,
      timeout,
      adUnits,
      adUnitCodes,
      labels,
      auctionId,
      ttlBuffer,
      ortb2,
      metrics,
      defer
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _events_js__WEBPACK_IMPORTED_MODULE_15__.emit(REQUEST_BIDS);
    const cbTimeout = timeout || _config_js__WEBPACK_IMPORTED_MODULE_17__.config.getConfig('bidderTimeout');
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.requestBids", arguments);
    if (adUnitCodes != null && !Array.isArray(adUnitCodes)) {
      adUnitCodes = [adUnitCodes];
    }
    if (adUnitCodes && adUnitCodes.length) {
      // if specific adUnitCodes supplied filter adUnits for those codes
      adUnits = adUnits.filter(unit => adUnitCodes.includes(unit.code));
    } else {
      // otherwise derive adUnitCodes from adUnits
      adUnitCodes = adUnits && adUnits.map(unit => unit.code);
    }
    adUnitCodes = adUnitCodes.filter(_utils_js__WEBPACK_IMPORTED_MODULE_4__.uniques);
    const ortb2Fragments = {
      global: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.mergeDeep)({}, _config_js__WEBPACK_IMPORTED_MODULE_17__.config.getAnyConfig('ortb2') || {}, ortb2 || {}),
      bidder: Object.fromEntries(Object.entries(_config_js__WEBPACK_IMPORTED_MODULE_17__.config.getBidderConfig()).map(_ref4 => {
        let [bidder, cfg] = _ref4;
        return [bidder, (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.deepClone)(cfg.ortb2)];
      }).filter(_ref5 => {
        let [_, ortb2] = _ref5;
        return ortb2 != null;
      }))
    };
    return (0,_fpd_enrichment_js__WEBPACK_IMPORTED_MODULE_18__.enrichFPD)(_utils_promise_js__WEBPACK_IMPORTED_MODULE_19__.PbPromise.resolve(ortb2Fragments.global)).then(global => {
      ortb2Fragments.global = global;
      return startAuction({
        bidsBackHandler,
        timeout: cbTimeout,
        adUnits,
        adUnitCodes,
        labels,
        auctionId,
        ttlBuffer,
        ortb2Fragments,
        metrics,
        defer
      });
    });
  }, 'requestBids');
  return (0,_hook_js__WEBPACK_IMPORTED_MODULE_11__.wrapHook)(delegate, (0,_utils_prerendering_js__WEBPACK_IMPORTED_MODULE_20__.delayIfPrerendering)(() => !_config_js__WEBPACK_IMPORTED_MODULE_17__.config.getConfig('allowPrerendering'), function requestBids() {
    let req = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // unlike the main body of `delegate`, this runs before any other hook has a chance to;
    // it's also not restricted in its return value in the way `async` hooks are.

    // if the request does not specify adUnits, clone the global adUnit array;
    // otherwise, if the caller goes on to use addAdUnits/removeAdUnits, any asynchronous logic
    // in any hook might see their effects.

    let adUnits = req.adUnits || pbjsInstance.adUnits;
    req.adUnits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(adUnits) ? adUnits.slice() : [adUnits];
    req.metrics = (0,_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_21__.newMetrics)();
    req.metrics.checkpoint('requestBids');
    req.defer = (0,_utils_promise_js__WEBPACK_IMPORTED_MODULE_19__.defer)({
      promiseFactory: r => new Promise(r)
    });
    delegate.call(this, req);
    return req.defer.promise;
  }));
}();
const startAuction = (0,_hook_js__WEBPACK_IMPORTED_MODULE_11__.hook)('async', function () {
  let {
    bidsBackHandler,
    timeout: cbTimeout,
    adUnits,
    ttlBuffer,
    adUnitCodes,
    labels,
    auctionId,
    ortb2Fragments,
    metrics,
    defer
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const s2sBidders = (0,_adapterManager_js__WEBPACK_IMPORTED_MODULE_22__.getS2SBidderSet)(_config_js__WEBPACK_IMPORTED_MODULE_17__.config.getConfig('s2sConfig') || []);
  fillAdUnitDefaults(adUnits);
  adUnits = (0,_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_21__.useMetrics)(metrics).measureTime('requestBids.validate', () => checkAdUnitSetup(adUnits));
  function auctionDone(bids, timedOut, auctionId) {
    if (typeof bidsBackHandler === 'function') {
      try {
        bidsBackHandler(bids, timedOut, auctionId);
      } catch (e) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('Error executing bidsBackHandler', null, e);
      }
    }
    defer.resolve({
      bids,
      timedOut,
      auctionId
    });
  }
  const tids = {};

  /*
   * for a given adunit which supports a set of mediaTypes
   * and a given bidder which supports a set of mediaTypes
   * a bidder is eligible to participate on the adunit
   * if it supports at least one of the mediaTypes on the adunit
   */
  adUnits.forEach(adUnit => {
    // get the adunit's mediaTypes, defaulting to banner if mediaTypes isn't present
    const adUnitMediaTypes = Object.keys(adUnit.mediaTypes || {
      'banner': 'banner'
    });

    // get the bidder's mediaTypes
    const allBidders = adUnit.bids.map(bid => bid.bidder);
    const bidderRegistry = _adapterManager_js__WEBPACK_IMPORTED_MODULE_22__["default"].bidderRegistry;
    const bidders = allBidders.filter(bidder => !s2sBidders.has(bidder));
    adUnit.adUnitId = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.generateUUID)();
    const tid = adUnit.ortb2Imp?.ext?.tid;
    if (tid) {
      if (tids.hasOwnProperty(adUnit.code)) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logWarn)(`Multiple distinct ortb2Imp.ext.tid were provided for twin ad units '${adUnit.code}'`);
      } else {
        tids[adUnit.code] = tid;
      }
    }
    if (ttlBuffer != null && !adUnit.hasOwnProperty('ttlBuffer')) {
      adUnit.ttlBuffer = ttlBuffer;
    }
    bidders.forEach(bidder => {
      const adapter = bidderRegistry[bidder];
      const spec = adapter && adapter.getSpec && adapter.getSpec();
      // banner is default if not specified in spec
      const bidderMediaTypes = spec && spec.supportedMediaTypes || ['banner'];

      // check if the bidder's mediaTypes are not in the adUnit's mediaTypes
      const bidderEligible = adUnitMediaTypes.some(type => bidderMediaTypes.includes(type));
      if (!bidderEligible) {
        // drop the bidder from the ad unit if it's not compatible
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logWarn)((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.unsupportedBidderMessage)(adUnit, bidder));
        adUnit.bids = adUnit.bids.filter(bid => bid.bidder !== bidder);
      }
    });
  });
  if (!adUnits || adUnits.length === 0) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logMessage)('No adUnits configured. No bids requested.');
    auctionDone();
  } else {
    adUnits.forEach(au => {
      const tid = au.ortb2Imp?.ext?.tid || tids[au.code] || (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.generateUUID)();
      if (!tids.hasOwnProperty(au.code)) {
        tids[au.code] = tid;
      }
      au.transactionId = tid;
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_10__.dset)(au, 'ortb2Imp.ext.tid', tid);
    });
    const auction = _auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager.createAuction({
      adUnits,
      adUnitCodes,
      callback: auctionDone,
      cbTimeout,
      labels,
      auctionId,
      ortb2Fragments,
      metrics
    });
    let adUnitsLen = adUnits.length;
    if (adUnitsLen > 15) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)(`Current auction ${auction.getAuctionId()} contains ${adUnitsLen} adUnits.`, adUnits);
    }
    adUnitCodes.forEach(code => _targeting_js__WEBPACK_IMPORTED_MODULE_12__.targeting.setLatestAuctionForAdUnit(code, auction.getAuctionId()));
    auction.callBids();
  }
}, 'startAuction');
function executeCallbacks(fn, reqBidsConfigObj) {
  runAll(_storageManager_js__WEBPACK_IMPORTED_MODULE_23__.storageCallbacks);
  runAll(enableAnalyticsCallbacks);
  fn.call(this, reqBidsConfigObj);
  function runAll(queue) {
    var queued;
    while (queued = queue.shift()) {
      queued();
    }
  }
}

// This hook will execute all storage callbacks which were registered before gdpr enforcement hook was added. Some bidders, user id modules use storage functions when module is parsed but gdpr enforcement hook is not added at that stage as setConfig callbacks are yet to be called. Hence for such calls we execute all the stored callbacks just before requestBids. At this hook point we will know for sure that tcfControl module is added or not
pbjsInstance.requestBids.before(executeCallbacks, 49);

/**
 *
 * Add adunit(s)
 * @param {Array|Object} adUnitArr Array of adUnits or single adUnit Object.
 * @alias module:pbjs.addAdUnits
 */
pbjsInstance.addAdUnits = function (adUnitArr) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.addAdUnits", arguments);
  pbjsInstance.adUnits.push.apply(pbjsInstance.adUnits, (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(adUnitArr) ? adUnitArr : [adUnitArr]);
  // emit event
  _events_js__WEBPACK_IMPORTED_MODULE_15__.emit(ADD_AD_UNITS);
};

/**
 * @param {string} event the name of the event
 * @param {Function} handler a callback to set on event
 * @param {string} id an identifier in the context of the event
 * @alias module:pbjs.onEvent
 *
 * This API call allows you to register a callback to handle a Prebid.js event.
 * An optional `id` parameter provides more finely-grained event callback registration.
 * This makes it possible to register callback events for a specific item in the
 * event context. For example, `bidWon` events will accept an `id` for ad unit code.
 * `bidWon` callbacks registered with an ad unit code id will be called when a bid
 * for that ad unit code wins the auction. Without an `id` this method registers the
 * callback for every `bidWon` event.
 *
 * Currently `bidWon` is the only event that accepts an `id` parameter.
 */
pbjsInstance.onEvent = function (event, handler, id) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.onEvent", arguments);
  if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isFn)(handler)) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('The event handler provided is not a function and was not set on event "' + event + '".');
    return;
  }
  if (id && !eventValidators[event].call(null, id)) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('The id provided is not valid for event "' + event + '" and no handler was set.');
    return;
  }
  _events_js__WEBPACK_IMPORTED_MODULE_15__.on(event, handler, id);
};

/**
 * @param {string} event the name of the event
 * @param {Function} handler a callback to remove from the event
 * @param {string} id an identifier in the context of the event (see `$$PREBID_GLOBAL$$.onEvent`)
 * @alias module:pbjs.offEvent
 */
pbjsInstance.offEvent = function (event, handler, id) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.offEvent", arguments);
  if (id && !eventValidators[event].call(null, id)) {
    return;
  }
  _events_js__WEBPACK_IMPORTED_MODULE_15__.off(event, handler, id);
};

/**
 * Return a copy of all events emitted
 *
 * @alias module:pbjs.getEvents
 */
pbjsInstance.getEvents = function () {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.getEvents");
  return _events_js__WEBPACK_IMPORTED_MODULE_15__.getEvents();
};

/*
 * Wrapper to register bidderAdapter externally (adapterManager.registerBidAdapter())
 * @param  {Function} bidderAdaptor [description]
 * @param  {string} bidderCode [description]
 * @param  {object} spec [description]
 * @alias module:pbjs.registerBidAdapter
 */
pbjsInstance.registerBidAdapter = function (bidderAdaptor, bidderCode, spec) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.registerBidAdapter", arguments);
  try {
    const bidder = spec ? (0,_adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_24__.newBidder)(spec) : bidderAdaptor();
    _adapterManager_js__WEBPACK_IMPORTED_MODULE_22__["default"].registerBidAdapter(bidder, bidderCode);
  } catch (e) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('Error registering bidder adapter : ' + e.message);
  }
};

/**
 * Wrapper to register analyticsAdapter externally (adapterManager.registerAnalyticsAdapter())
 * @param  {Object} options [description]
 * @alias module:pbjs.registerAnalyticsAdapter
 */
pbjsInstance.registerAnalyticsAdapter = function (options) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.registerAnalyticsAdapter", arguments);
  try {
    _adapterManager_js__WEBPACK_IMPORTED_MODULE_22__["default"].registerAnalyticsAdapter(options);
  } catch (e) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('Error registering analytics adapter : ' + e.message);
  }
};

/**
 * Wrapper to bidfactory.createBid()
 * @param  {string} statusCode [description]
 * @alias module:pbjs.createBid
 * @return {Object} bidResponse [description]
 */
pbjsInstance.createBid = function (statusCode) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.createBid", arguments);
  return (0,_bidfactory_js__WEBPACK_IMPORTED_MODULE_25__.createBid)(statusCode);
};

/**
 * Enable sending analytics data to the analytics provider of your
 * choice.
 *
 * For usage, see [Integrate with the Prebid Analytics
 * API](http://prebid.org/dev-docs/integrate-with-the-prebid-analytics-api.html).
 *
 * For a list of analytics adapters, see [Analytics for
 * Prebid](http://prebid.org/overview/analytics.html).
 * @param  {Object} config
 * @param {string} config.provider The name of the provider, e.g., `"ga"` for Google Analytics.
 * @param {Object} config.options The options for this particular analytics adapter.  This will likely vary between adapters.
 * @alias module:pbjs.enableAnalytics
 */

// Stores 'enableAnalytics' callbacks for later execution.
const enableAnalyticsCallbacks = [];
const enableAnalyticsCb = (0,_hook_js__WEBPACK_IMPORTED_MODULE_11__.hook)('async', function (config) {
  if (config && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isEmpty)(config)) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.enableAnalytics for: ", config);
    _adapterManager_js__WEBPACK_IMPORTED_MODULE_22__["default"].enableAnalytics(config);
  } else {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)("pbjs.enableAnalytics should be called with option {}");
  }
}, 'enableAnalyticsCb');
pbjsInstance.enableAnalytics = function (config) {
  enableAnalyticsCallbacks.push(enableAnalyticsCb.bind(this, config));
};

/**
 * @alias module:pbjs.aliasBidder
 */
pbjsInstance.aliasBidder = function (bidderCode, alias, options) {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)("Invoking pbjs.aliasBidder", arguments);
  if (bidderCode && alias) {
    _adapterManager_js__WEBPACK_IMPORTED_MODULE_22__["default"].aliasBidAdapter(bidderCode, alias, options);
  } else {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('bidderCode and alias must be passed as arguments', "pbjs.aliasBidder");
  }
};

/**
 * @alias module:pbjs.aliasRegistry
 */
pbjsInstance.aliasRegistry = _adapterManager_js__WEBPACK_IMPORTED_MODULE_22__["default"].aliasRegistry;
_config_js__WEBPACK_IMPORTED_MODULE_17__.config.getConfig('aliasRegistry', config => {
  if (config.aliasRegistry === 'private') delete pbjsInstance.aliasRegistry;
});

/**
 * The bid response object returned by an external bidder adapter during the auction.
 * @typedef {Object} AdapterBidResponse
 * @property {string} pbAg Auto granularity price bucket; CPM <= 5 ? increment = 0.05 : CPM > 5 && CPM <= 10 ? increment = 0.10 : CPM > 10 && CPM <= 20 ? increment = 0.50 : CPM > 20 ? priceCap = 20.00.  Example: `"0.80"`.
 * @property {string} pbCg Custom price bucket.  For example setup, see `setConfig({ priceGranularity: ... })`.  Example: `"0.84"`.
 * @property {string} pbDg Dense granularity price bucket; CPM <= 3 ? increment = 0.01 : CPM > 3 && CPM <= 8 ? increment = 0.05 : CPM > 8 && CPM <= 20 ? increment = 0.50 : CPM > 20? priceCap = 20.00.  Example: `"0.84"`.
 * @property {string} pbLg Low granularity price bucket; $0.50 increment, capped at $5, floored to two decimal places.  Example: `"0.50"`.
 * @property {string} pbMg Medium granularity price bucket; $0.10 increment, capped at $20, floored to two decimal places.  Example: `"0.80"`.
 * @property {string} pbHg High granularity price bucket; $0.01 increment, capped at $20, floored to two decimal places.  Example: `"0.84"`.
 *
 * @property {string} bidder The string name of the bidder.  This *may* be the same as the `bidderCode`.  For For a list of all bidders and their codes, see [Bidders' Params](http://prebid.org/dev-docs/bidders.html).
 * @property {string} bidderCode The unique string that identifies this bidder.  For a list of all bidders and their codes, see [Bidders' Params](http://prebid.org/dev-docs/bidders.html).
 *
 * @property {string} requestId The [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) representing the bid request.
 * @property {number} requestTimestamp The time at which the bid request was sent out, expressed in milliseconds.
 * @property {number} responseTimestamp The time at which the bid response was received, expressed in milliseconds.
 * @property {number} timeToRespond How long it took for the bidder to respond with this bid, expressed in milliseconds.
 *
 * @property {string} size The size of the ad creative, expressed in `"AxB"` format, where A and B are numbers of pixels.  Example: `"320x50"`.
 * @property {string} width The width of the ad creative in pixels.  Example: `"320"`.
 * @property {string} height The height of the ad creative in pixels.  Example: `"50"`.
 *
 * @property {string} ad The actual ad creative content, often HTML with CSS, JavaScript, and/or links to additional content.  Example: `"<div id='beacon_-YQbipJtdxmMCgEPHExLhmqzEm' style='position: absolute; left: 0px; top: 0px; visibility: hidden;'><img src='http://aplus-...'/></div><iframe src=\"http://aax-us-east.amazon-adsystem.com/e/is/8dcfcd..." width=\"728\" height=\"90\" frameborder=\"0\" ...></iframe>",`.
 * @property {number} ad_id The ad ID of the creative, as understood by the bidder's system.  Used by the line item's [creative in the ad server](http://prebid.org/adops/send-all-bids-adops.html#step-3-add-a-creative).
 * @property {string} adUnitCode The code used to uniquely identify the ad unit on the publisher's page.
 *
 * @property {string} statusMessage The status of the bid.  Allowed values: `"Bid available"` or `"Bid returned empty or error response"`.
 * @property {number} cpm The exact bid price from the bidder, expressed to the thousandths place.  Example: `"0.849"`.
 *
 * @property {Object} adserverTargeting An object whose values represent the ad server's targeting on the bid.
 * @property {string} adserverTargeting.hb_adid The ad ID of the creative, as understood by the ad server.
 * @property {string} adserverTargeting.hb_pb The price paid to show the creative, as logged in the ad server.
 * @property {string} adserverTargeting.hb_bidder The winning bidder whose ad creative will be served by the ad server.
 */

/**
 * Get all of the bids that have been rendered.  Useful for [troubleshooting your integration](http://prebid.org/dev-docs/prebid-troubleshooting-guide.html).
 * @return {Array<AdapterBidResponse>} A list of bids that have been rendered.
 */
pbjsInstance.getAllWinningBids = function () {
  return _auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager.getAllWinningBids();
};

/**
 * Get all of the bids that have won their respective auctions.
 * @deprecated
 * @return {Array<AdapterBidResponse>} A list of bids that have won their respective auctions but failed to win the ad server auction.
 */
pbjsInstance.getAllPrebidWinningBids = function () {
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logWarn)('getAllPrebidWinningBids may be removed or renamed in a future version. This function returns bids that have won in prebid and have had targeting set but have not (yet?) won in the ad server. It excludes bids that have been rendered.');
  return _auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager.getBidsReceived().filter(bid => bid.status === _constants_js__WEBPACK_IMPORTED_MODULE_2__.BID_STATUS.BID_TARGETING_SET);
};

/**
 * Get array of highest cpm bids for all adUnits, or highest cpm bid
 * object for the given adUnit
 * @param {string} adUnitCode - optional ad unit code
 * @alias module:pbjs.getHighestCpmBids
 * @return {Array} array containing highest cpm bid object(s)
 */
pbjsInstance.getHighestCpmBids = function (adUnitCode) {
  return _targeting_js__WEBPACK_IMPORTED_MODULE_12__.targeting.getWinningBids(adUnitCode);
};
pbjsInstance.clearAllAuctions = function () {
  _auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager.clearAllAuctions();
};
if (true) {
  /**
   * Mark the winning bid as used, should only be used in conjunction with video
   * @typedef {Object} MarkBidRequest
   * @property {string} adUnitCode The ad unit code
   * @property {string} adId The id representing the ad we want to mark
   * @property {boolean} events If true, fires tracking pixels and BID_WON handlers
   * @property {boolean} analytics alias of `events` (for backwards compat)
   *
   * @alias module:pbjs.markWinningBidAsUsed
   */
  pbjsInstance.markWinningBidAsUsed = function (_ref6) {
    let {
      adId,
      adUnitCode,
      analytics = false,
      events = false
    } = _ref6;
    let bids;
    if (adUnitCode && adId == null) {
      bids = _targeting_js__WEBPACK_IMPORTED_MODULE_12__.targeting.getWinningBids(adUnitCode);
    } else if (adId) {
      bids = _auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager.getBidsReceived().filter(bid => bid.adId === adId);
    } else {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logWarn)('Improper use of markWinningBidAsUsed. It needs an adUnitCode or an adId to function.');
    }
    if (bids.length > 0) {
      if (analytics || events) {
        (0,_adRendering_js__WEBPACK_IMPORTED_MODULE_16__.markWinningBid)(bids[0]);
      } else {
        _auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager.addWinningBid(bids[0]);
      }
      (0,_adRendering_js__WEBPACK_IMPORTED_MODULE_16__.markBidAsRendered)(bids[0]);
    }
  };
}

/**
 * Get Prebid config options
 * @param {Object} options
 * @alias module:pbjs.getConfig
 */
pbjsInstance.getConfig = _config_js__WEBPACK_IMPORTED_MODULE_17__.config.getAnyConfig;
pbjsInstance.readConfig = _config_js__WEBPACK_IMPORTED_MODULE_17__.config.readAnyConfig;
pbjsInstance.mergeConfig = _config_js__WEBPACK_IMPORTED_MODULE_17__.config.mergeConfig;
pbjsInstance.mergeBidderConfig = _config_js__WEBPACK_IMPORTED_MODULE_17__.config.mergeBidderConfig;

/**
 * Set Prebid config options.
 * See https://docs.prebid.org/dev-docs/publisher-api-reference/setConfig.html
 *
 * @param {Object} options Global Prebid configuration object. Must be JSON - no JavaScript functions are allowed.
 */
pbjsInstance.setConfig = _config_js__WEBPACK_IMPORTED_MODULE_17__.config.setConfig;
pbjsInstance.setBidderConfig = _config_js__WEBPACK_IMPORTED_MODULE_17__.config.setBidderConfig;
pbjsInstance.que.push(() => (0,_secureCreatives_js__WEBPACK_IMPORTED_MODULE_26__.listenMessagesFromCreative)());

/**
 * This queue lets users load Prebid asynchronously, but run functions the same way regardless of whether it gets loaded
 * before or after their script executes. For example, given the code:
 *
 * <script src="url/to/Prebid.js" async></script>
 * <script>
 *   var pbjs = pbjs || {};
 *   pbjs.cmd = pbjs.cmd || [];
 *   pbjs.cmd.push(functionToExecuteOncePrebidLoads);
 * </script>
 *
 * If the page's script runs before prebid loads, then their function gets added to the queue, and executed
 * by prebid once it's done loading. If it runs after prebid loads, then this monkey-patch causes their
 * function to execute immediately.
 *
 * @param  {function} command A function which takes no arguments. This is guaranteed to run exactly once, and only after
 *                            the Prebid script has been fully loaded.
 * @alias module:pbjs.cmd.push
 * @alias module:pbjs.que.push
 */
function quePush(command) {
  if (typeof command === 'function') {
    try {
      command.call();
    } catch (e) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('Error processing command :', e.message, e.stack);
    }
  } else {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)("Commands written into pbjs.cmd.push must be wrapped in a function");
  }
}
function processQueue(queue) {
  queue.forEach(function (cmd) {
    if (typeof cmd.called === 'undefined') {
      try {
        cmd.call();
        cmd.called = true;
      } catch (e) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('Error processing command :', 'prebid.js', e);
      }
    }
  });
}

/**
 * @alias module:pbjs.processQueue
 */
pbjsInstance.processQueue = (0,_utils_prerendering_js__WEBPACK_IMPORTED_MODULE_20__.delayIfPrerendering)(() => (0,_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__.getGlobal)().delayPrerendering, function () {
  pbjsInstance.que.push = pbjsInstance.cmd.push = quePush;
  (0,_adRendering_js__WEBPACK_IMPORTED_MODULE_16__.insertLocatorFrame)();
  _hook_js__WEBPACK_IMPORTED_MODULE_11__.hook.ready();
  processQueue(pbjsInstance.que);
  processQueue(pbjsInstance.cmd);
});

/**
 * @alias module:pbjs.triggerBilling
 */
pbjsInstance.triggerBilling = _ref7 => {
  let {
    adId,
    adUnitCode
  } = _ref7;
  _auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager.getAllWinningBids().filter(bid => bid.adId === adId || adId == null && bid.adUnitCode === adUnitCode).forEach(bid => {
    _adapterManager_js__WEBPACK_IMPORTED_MODULE_22__["default"].triggerBilling(bid);
    (0,_adRendering_js__WEBPACK_IMPORTED_MODULE_16__.renderIfDeferred)(bid);
  });
};
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = (pbjsInstance);

/***/ }),

/***/ "./src/prebidGlobal.js":
/*!*****************************!*\
  !*** ./src/prebidGlobal.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGlobal: () => (/* binding */ getGlobal),
/* harmony export */   registerModule: () => (/* binding */ registerModule)
/* harmony export */ });
// if $$PREBID_GLOBAL$$ already exists in global document scope, use it, if not, create the object
// global defination should happen BEFORE imports to avoid global undefined errors.
/* global $$DEFINE_PREBID_GLOBAL$$ */
const scope =  false ? 0 : window;
const global = scope.pbjs = scope.pbjs || {};
global.cmd = global.cmd || [];
global.que = global.que || [];

// create a pbjs global pointer
if (scope === window) {
  scope._pbjsGlobals = scope._pbjsGlobals || [];
  scope._pbjsGlobals.push("pbjs");
}
function getGlobal() {
  return global;
}
function registerModule(name) {
  global.installedModules.push(name);
}

/***/ }),

/***/ "./src/refererDetection.js":
/*!*********************************!*\
  !*** ./src/refererDetection.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getRefererInfo: () => (/* binding */ getRefererInfo),
/* harmony export */   parseDomain: () => (/* binding */ parseDomain)
/* harmony export */ });
/* unused harmony exports ensureProtocol, detectReferer, cacheWithLocation */
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ "./src/config.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/**
 * The referer detection module attempts to gather referer information from the current page that prebid.js resides in.
 * The information that it tries to collect includes:
 * The detected top url in the nav bar,
 * Whether it was able to reach the top most window (if for example it was embedded in several iframes),
 * The number of iframes it was embedded in if applicable (by default max ten iframes),
 * A list of the domains of each embedded window if applicable.
 * Canonical URL which refers to an HTML link element, with the attribute of rel="canonical", found in the <head> element of your webpage
 */




/**
 * Prepend a URL with the page's protocol (http/https), if necessary.
 */
function ensureProtocol(url) {
  let win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
  if (!url) return url;
  if (/\w+:\/\//.exec(url)) {
    // url already has protocol
    return url;
  }
  let windowProto = win.location.protocol;
  try {
    windowProto = win.top.location.protocol;
  } catch (e) {}
  if (/^\/\//.exec(url)) {
    // url uses relative protocol ("//example.com")
    return windowProto + url;
  } else {
    return `${windowProto}//${url}`;
  }
}

/**
 * Extract the domain portion from a URL.
 * @param {string} url - The URL to extract the domain from.
 * @param {Object} options - Options for parsing the domain.
 * @param {boolean} options.noLeadingWww - If true, remove 'www.' appearing at the beginning of the domain.
 * @param {boolean} options.noPort - If true, do not include the ':[port]' portion.
 * @return {string|undefined} - The extracted domain or undefined if the URL is invalid.
 */
function parseDomain(url) {
  let {
    noLeadingWww = false,
    noPort = false
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  try {
    url = new URL(ensureProtocol(url));
  } catch (e) {
    return;
  }
  url = noPort ? url.hostname : url.host;
  if (noLeadingWww && url.startsWith('www.')) {
    url = url.substring(4);
  }
  return url;
}

/**
 * This function returns canonical URL which refers to an HTML link element, with the attribute of rel="canonical", found in the <head> element of your webpage
 *
 * @param {Object} doc document
 * @returns {string|null}
 */
function getCanonicalUrl(doc) {
  try {
    const element = doc.querySelector("link[rel='canonical']");
    if (element !== null) {
      return element.href;
    }
  } catch (e) {
    // Ignore error
  }
  return null;
}

/**
 * @param {Window} win Window
 * @returns {Function}
 */
function detectReferer(win) {
  /**
   * This function would return a read-only array of hostnames for all the parent frames.
   * win.location.ancestorOrigins is only supported in webkit browsers. For non-webkit browsers it will return undefined.
   *
   * @param {Window} win Window object
   * @returns {(undefined|Array)} Ancestor origins or undefined
   */
  function getAncestorOrigins(win) {
    try {
      if (!win.location.ancestorOrigins) {
        return;
      }
      return win.location.ancestorOrigins;
    } catch (e) {
      // Ignore error
    }
  }

  // TODO: the meaning of "reachedTop" seems to be intentionally ambiguous - best to leave them out of
  // the typedef for now. (for example, unit tests enforce that "reachedTop" should be false in some situations where we
  // happily provide a location for the top).

  /**
   * @typedef {Object} refererInfo
   * @property {string|null} location the browser's location, or null if not available (due to cross-origin restrictions)
   * @property {string|null} canonicalUrl the site's canonical URL as set by the publisher, through setConfig({pageUrl}) or <link rel="canonical" />
   * @property {string|null} page the best candidate for the current page URL: `canonicalUrl`, falling back to `location`
   * @property {string|null} domain the domain portion of `page`
   * @property {string|null} ref the referrer (document.referrer) to the current page, or null if not available (due to cross-origin restrictions)
   * @property {string} topmostLocation of the top-most frame for which we could guess the location. Outside of cross-origin scenarios, this is equivalent to `location`.
   * @property {number} numIframes number of steps between window.self and window.top
   * @property {Array<string|null>} stack our best guess at the location for each frame, in the direction top -> self.
   */

  /**
   * Walk up the windows to get the origin stack and best available referrer, canonical URL, etc.
   *
   * @returns {refererInfo} An object containing referer information.
   */
  function refererInfo() {
    const stack = [];
    const ancestors = getAncestorOrigins(win);
    const maxNestedIframes = _config_js__WEBPACK_IMPORTED_MODULE_0__.config.getConfig('maxNestedIframes');
    let currentWindow;
    let bestLocation;
    let bestCanonicalUrl;
    let reachedTop = false;
    let level = 0;
    let valuesFromAmp = false;
    let inAmpFrame = false;
    let hasTopLocation = false;
    do {
      const previousWindow = currentWindow;
      const wasInAmpFrame = inAmpFrame;
      let currentLocation;
      let crossOrigin = false;
      let foundLocation = null;
      inAmpFrame = false;
      currentWindow = currentWindow ? currentWindow.parent : win;
      try {
        currentLocation = currentWindow.location.href || null;
      } catch (e) {
        crossOrigin = true;
      }
      if (crossOrigin) {
        if (wasInAmpFrame) {
          const context = previousWindow.context;
          try {
            foundLocation = context.sourceUrl;
            bestLocation = foundLocation;
            hasTopLocation = true;
            valuesFromAmp = true;
            if (currentWindow === win.top) {
              reachedTop = true;
            }
            if (context.canonicalUrl) {
              bestCanonicalUrl = context.canonicalUrl;
            }
          } catch (e) {/* Do nothing */}
        } else {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)('Trying to access cross domain iframe. Continuing without referrer and location');
          try {
            // the referrer to an iframe is the parent window
            const referrer = previousWindow.document.referrer;
            if (referrer) {
              foundLocation = referrer;
              if (currentWindow === win.top) {
                reachedTop = true;
              }
            }
          } catch (e) {/* Do nothing */}
          if (!foundLocation && ancestors && ancestors[level - 1]) {
            foundLocation = ancestors[level - 1];
            if (currentWindow === win.top) {
              hasTopLocation = true;
            }
          }
          if (foundLocation && !valuesFromAmp) {
            bestLocation = foundLocation;
          }
        }
      } else {
        if (currentLocation) {
          foundLocation = currentLocation;
          bestLocation = foundLocation;
          valuesFromAmp = false;
          if (currentWindow === win.top) {
            reachedTop = true;
            const canonicalUrl = getCanonicalUrl(currentWindow.document);
            if (canonicalUrl) {
              bestCanonicalUrl = canonicalUrl;
            }
          }
        }
        if (currentWindow.context && currentWindow.context.sourceUrl) {
          inAmpFrame = true;
        }
      }
      stack.push(foundLocation);
      level++;
    } while (currentWindow !== win.top && level < maxNestedIframes);
    stack.reverse();
    let ref;
    try {
      ref = win.top.document.referrer;
    } catch (e) {}
    const location = reachedTop || hasTopLocation ? bestLocation : null;
    const canonicalUrl = _config_js__WEBPACK_IMPORTED_MODULE_0__.config.getConfig('pageUrl') || bestCanonicalUrl || null;
    let page = _config_js__WEBPACK_IMPORTED_MODULE_0__.config.getConfig('pageUrl') || location || ensureProtocol(canonicalUrl, win);
    if (location && location.indexOf('?') > -1 && page.indexOf('?') === -1) {
      page = `${page}${location.substring(location.indexOf('?'))}`;
    }
    return {
      reachedTop,
      isAmp: valuesFromAmp,
      numIframes: level - 1,
      stack,
      topmostLocation: bestLocation || null,
      location,
      canonicalUrl,
      page,
      domain: parseDomain(page) || null,
      ref: ref || null,
      // TODO: the "legacy" refererInfo object is provided here, for now, to accomodate
      // adapters that decided to just send it verbatim to their backend.
      legacy: {
        reachedTop,
        isAmp: valuesFromAmp,
        numIframes: level - 1,
        stack,
        referer: bestLocation || null,
        canonicalUrl
      }
    };
  }
  return refererInfo;
}

// cache result of fn (= referer info) as long as:
// - we are the top window
// - canonical URL tag and window location have not changed
function cacheWithLocation(fn) {
  let win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
  if (win.top !== win) return fn;
  let canonical, href, value;
  return function () {
    const newCanonical = getCanonicalUrl(win.document);
    const newHref = win.location.href;
    if (canonical !== newCanonical || newHref !== href) {
      canonical = newCanonical;
      href = newHref;
      value = fn();
    }
    return value;
  };
}

/**
 * @type {function(): refererInfo}
 */
const getRefererInfo = cacheWithLocation(detectReferer(window));

/***/ }),

/***/ "./src/secureCreatives.js":
/*!********************************!*\
  !*** ./src/secureCreatives.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   listenMessagesFromCreative: () => (/* binding */ listenMessagesFromCreative)
/* harmony export */ });
/* unused harmony exports getReplier, receiveMessage, resizeRemoteCreative */
/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./native.js */ "./src/native.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./src/constants.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _adRendering_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./adRendering.js */ "./src/adRendering.js");
/* harmony import */ var _creativeRenderers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./creativeRenderers.js */ "./src/creativeRenderers.js");
/* Secure Creatives
  Provides support for rendering creatives into cross domain iframes such as SafeFrame to prevent
   access to a publisher page from creative payloads.
 */






const {
  REQUEST,
  RESPONSE,
  NATIVE,
  EVENT
} = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MESSAGES;
const HANDLER_MAP = {
  [REQUEST]: handleRenderRequest,
  [EVENT]: handleEventRequest
};
if (true) {
  Object.assign(HANDLER_MAP, {
    [NATIVE]: handleNativeRequest
  });
}
function listenMessagesFromCreative() {
  window.addEventListener('message', function (ev) {
    receiveMessage(ev);
  }, false);
}
function getReplier(ev) {
  if (ev.origin == null && ev.ports.length === 0) {
    return function () {
      const msg = 'Cannot post message to a frame with null origin. Please update creatives to use MessageChannel, see https://github.com/prebid/Prebid.js/issues/7870';
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(msg);
      throw new Error(msg);
    };
  } else if (ev.ports.length > 0) {
    return function (message) {
      ev.ports[0].postMessage(JSON.stringify(message));
    };
  } else {
    return function (message) {
      ev.source.postMessage(JSON.stringify(message), ev.origin);
    };
  }
}
function ensureAdId(adId, reply) {
  return function (data) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return reply(Object.assign({}, data, {
      adId
    }), ...args);
  };
}
function receiveMessage(ev) {
  var key = ev.message ? 'message' : 'data';
  var data = {};
  try {
    data = JSON.parse(ev[key]);
  } catch (e) {
    return;
  }
  if (data && data.adId && data.message && HANDLER_MAP.hasOwnProperty(data.message)) {
    return (0,_adRendering_js__WEBPACK_IMPORTED_MODULE_2__.getBidToRender)(data.adId, data.message === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MESSAGES.REQUEST).then(adObject => {
      HANDLER_MAP[data.message](ensureAdId(data.adId, getReplier(ev)), data, adObject);
    });
  }
}
function getResizer(adId, bidResponse) {
  // in some situations adId !== bidResponse.adId
  // the first is the one that was requested and is tied to the element
  // the second is the one that is being rendered (sometimes different, e.g. in some paapi setups)
  return function (width, height) {
    resizeRemoteCreative({
      ...bidResponse,
      width,
      height,
      adId
    });
  };
}
function handleRenderRequest(reply, message, bidResponse) {
  (0,_adRendering_js__WEBPACK_IMPORTED_MODULE_2__.handleRender)({
    renderFn(adData) {
      reply(Object.assign({
        message: RESPONSE,
        renderer: (0,_creativeRenderers_js__WEBPACK_IMPORTED_MODULE_3__.getCreativeRendererSource)(bidResponse),
        rendererVersion: _creativeRenderers_js__WEBPACK_IMPORTED_MODULE_3__.PUC_MIN_VERSION
      }, adData));
    },
    resizeFn: getResizer(message.adId, bidResponse),
    options: message.options,
    adId: message.adId,
    bidResponse
  });
}
function handleNativeRequest(reply, data, adObject) {
  // handle this script from native template in an ad server
  // window.parent.postMessage(JSON.stringify({
  //   message: 'Prebid Native',
  //   adId: '%%PATTERN:hb_adid%%'
  // }), '*');
  if (adObject == null) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`Cannot find ad for x-origin event request: '${data.adId}'`);
    return;
  }
  switch (data.action) {
    case 'assetRequest':
      (0,_adRendering_js__WEBPACK_IMPORTED_MODULE_2__.deferRendering)(adObject, () => reply((0,_native_js__WEBPACK_IMPORTED_MODULE_4__.getAssetMessage)(data, adObject)));
      break;
    case 'allAssetRequest':
      (0,_adRendering_js__WEBPACK_IMPORTED_MODULE_2__.deferRendering)(adObject, () => reply((0,_native_js__WEBPACK_IMPORTED_MODULE_4__.getAllAssetsMessage)(data, adObject)));
      break;
    default:
      (0,_adRendering_js__WEBPACK_IMPORTED_MODULE_2__.handleNativeMessage)(data, adObject, {
        resizeFn: getResizer(data.adId, adObject)
      });
      (0,_adRendering_js__WEBPACK_IMPORTED_MODULE_2__.markWinner)(adObject);
  }
}
function handleEventRequest(reply, data, adObject) {
  if (adObject == null) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`Cannot find ad '${data.adId}' for x-origin event request`);
    return;
  }
  if (adObject.status !== _constants_js__WEBPACK_IMPORTED_MODULE_0__.BID_STATUS.RENDERED) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Received x-origin event request without corresponding render request for ad '${adObject.adId}'`);
    return;
  }
  return (0,_adRendering_js__WEBPACK_IMPORTED_MODULE_2__.handleCreativeEvent)(data, adObject);
}
function resizeRemoteCreative(_ref) {
  let {
    instl,
    adId,
    adUnitCode,
    width,
    height
  } = _ref;
  // do not resize interstitials - the creative frame takes the full screen and sizing of the ad should
  // be handled within it.
  if (instl) return;
  function getDimension(value) {
    return value ? value + 'px' : '100%';
  }
  // resize both container div + iframe
  ['div', 'iframe'].forEach(elmType => {
    // not select element that gets removed after dfp render
    let element = getElementByAdUnit(elmType + ':not([style*="display: none"])');
    if (element) {
      let elementStyle = element.style;
      elementStyle.width = getDimension(width);
      elementStyle.height = getDimension(height);
    } else {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`Unable to locate matching page element for adUnitCode ${adUnitCode}.  Can't resize it to ad's dimensions.  Please review setup.`);
    }
  });
  function getElementByAdUnit(elmType) {
    let id = getElementIdBasedOnAdServer(adId, adUnitCode);
    let parentDivEle = document.getElementById(id);
    return parentDivEle && parentDivEle.querySelector(elmType);
  }
  function getElementIdBasedOnAdServer(adId, adUnitCode) {
    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isGptPubadsDefined)()) {
      return getDfpElementId(adId);
    } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isApnGetTagDefined)()) {
      return getAstElementId(adUnitCode);
    } else {
      return adUnitCode;
    }
  }
  function getDfpElementId(adId) {
    const slot = window.googletag.pubads().getSlots().find(slot => {
      return slot.getTargetingKeys().find(key => {
        return slot.getTargeting(key).includes(adId);
      });
    });
    return slot ? slot.getSlotElementId() : null;
  }
  function getAstElementId(adUnitCode) {
    let astTag = window.apntag.getTag(adUnitCode);
    return astTag && astTag.targetId;
  }
}

/***/ }),

/***/ "./src/storageManager.js":
/*!*******************************!*\
  !*** ./src/storageManager.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   STORAGE_TYPE_COOKIES: () => (/* binding */ STORAGE_TYPE_COOKIES),
/* harmony export */   STORAGE_TYPE_LOCALSTORAGE: () => (/* binding */ STORAGE_TYPE_LOCALSTORAGE),
/* harmony export */   getCoreStorageManager: () => (/* binding */ getCoreStorageManager),
/* harmony export */   getStorageManager: () => (/* binding */ getStorageManager),
/* harmony export */   storageCallbacks: () => (/* binding */ storageCallbacks)
/* harmony export */ });
/* unused harmony exports newStorageManager, deviceAccessRule, storageAllowedRule, resetData */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _bidderSettings_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./bidderSettings.js */ "./src/bidderSettings.js");
/* harmony import */ var _activities_modules_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./activities/modules.js */ "./src/activities/modules.js");
/* harmony import */ var _activities_rules_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activities/rules.js */ "./src/activities/rules.js");
/* harmony import */ var _activities_params_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./activities/params.js */ "./src/activities/params.js");
/* harmony import */ var _activities_activities_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./activities/activities.js */ "./src/activities/activities.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config.js */ "./src/config.js");
/* harmony import */ var _adapterManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./adapterManager.js */ "./src/adapterManager.js");
/* harmony import */ var _activities_activityParams_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./activities/activityParams.js */ "./src/activities/activityParams.js");









const STORAGE_TYPE_LOCALSTORAGE = 'html5';
const STORAGE_TYPE_COOKIES = 'cookie';
let storageCallbacks = [];

/* eslint-disable no-restricted-properties */

/*
 *  Storage manager constructor. Consumers should prefer one of `getStorageManager` or `getCoreStorageManager`.
 */
function newStorageManager() {
  let {
    moduleName,
    moduleType
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let {
    isAllowed = _activities_rules_js__WEBPACK_IMPORTED_MODULE_0__.isActivityAllowed
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  function isValid(cb, storageType) {
    let mod = moduleName;
    const curBidder = _config_js__WEBPACK_IMPORTED_MODULE_1__.config.getCurrentBidder();
    if (curBidder && moduleType === _activities_modules_js__WEBPACK_IMPORTED_MODULE_2__.MODULE_TYPE_BIDDER && _adapterManager_js__WEBPACK_IMPORTED_MODULE_3__["default"].aliasRegistry[curBidder] === moduleName) {
      mod = curBidder;
    }
    const result = {
      valid: isAllowed(_activities_activities_js__WEBPACK_IMPORTED_MODULE_4__.ACTIVITY_ACCESS_DEVICE, (0,_activities_activityParams_js__WEBPACK_IMPORTED_MODULE_5__.activityParams)(moduleType, mod, {
        [_activities_params_js__WEBPACK_IMPORTED_MODULE_6__.ACTIVITY_PARAM_STORAGE_TYPE]: storageType
      }))
    };
    return cb(result);
  }
  function schedule(operation, storageType, done) {
    if (done && typeof done === 'function') {
      storageCallbacks.push(function () {
        let result = isValid(operation, storageType);
        done(result);
      });
    } else {
      return isValid(operation, storageType);
    }
  }

  /**
   * @param {string} key
   * @param {string} value
   * @param {string} [expires='']
   * @param {string} [sameSite='/']
   * @param {string} [domain] domain (e.g., 'example.com' or 'subdomain.example.com').
   * If not specified, defaults to the host portion of the current document location.
   * If a domain is specified, subdomains are always included.
   * Domain must match the domain of the JavaScript origin. Setting cookies to foreign domains will be silently ignored.
   * @param {function} [done]
   */
  const setCookie = function (key, value, expires, sameSite, domain, done) {
    let cb = function (result) {
      if (result && result.valid) {
        const domainPortion = domain && domain !== '' ? ` ;domain=${encodeURIComponent(domain)}` : '';
        const expiresPortion = expires && expires !== '' ? ` ;expires=${expires}` : '';
        const isNone = sameSite != null && sameSite.toLowerCase() == 'none';
        const secure = isNone ? '; Secure' : '';
        document.cookie = `${key}=${encodeURIComponent(value)}${expiresPortion}; path=/${domainPortion}${sameSite ? `; SameSite=${sameSite}` : ''}${secure}`;
      }
    };
    return schedule(cb, STORAGE_TYPE_COOKIES, done);
  };

  /**
   * @param {string} name
   * @param {function} [done]
   * @returns {(string|null)}
   */
  const getCookie = function (name, done) {
    let cb = function (result) {
      if (result && result.valid) {
        let m = window.document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]*)\\s*(;|$)');
        return m ? decodeURIComponent(m[2]) : null;
      }
      return null;
    };
    return schedule(cb, STORAGE_TYPE_COOKIES, done);
  };

  /**
   * @param {function} [done]
   * @returns {boolean}
   */
  const cookiesAreEnabled = function (done) {
    let cb = function (result) {
      if (result && result.valid) {
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.checkCookieSupport)();
      }
      return false;
    };
    return schedule(cb, STORAGE_TYPE_COOKIES, done);
  };
  function storageMethods(name) {
    const capName = name.charAt(0).toUpperCase() + name.substring(1);
    const backend = () => window[name];
    const hasStorage = function (done) {
      let cb = function (result) {
        if (result && result.valid) {
          try {
            return !!backend();
          } catch (e) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.logError)(`${name} api disabled`);
          }
        }
        return false;
      };
      return schedule(cb, STORAGE_TYPE_LOCALSTORAGE, done);
    };
    return {
      [`has${capName}`]: hasStorage,
      [`${name}IsEnabled`](done) {
        let cb = function (result) {
          if (result && result.valid) {
            try {
              backend().setItem('prebid.cookieTest', '1');
              return backend().getItem('prebid.cookieTest') === '1';
            } catch (error) {} finally {
              try {
                backend().removeItem('prebid.cookieTest');
              } catch (error) {}
            }
          }
          return false;
        };
        return schedule(cb, STORAGE_TYPE_LOCALSTORAGE, done);
      },
      [`setDataIn${capName}`](key, value, done) {
        let cb = function (result) {
          if (result && result.valid && hasStorage()) {
            backend().setItem(key, value);
          }
        };
        return schedule(cb, STORAGE_TYPE_LOCALSTORAGE, done);
      },
      [`getDataFrom${capName}`](key, done) {
        let cb = function (result) {
          if (result && result.valid && hasStorage()) {
            return backend().getItem(key);
          }
          return null;
        };
        return schedule(cb, STORAGE_TYPE_LOCALSTORAGE, done);
      },
      [`removeDataFrom${capName}`](key, done) {
        let cb = function (result) {
          if (result && result.valid && hasStorage()) {
            backend().removeItem(key);
          }
        };
        return schedule(cb, STORAGE_TYPE_LOCALSTORAGE, done);
      }
    };
  }

  /**
   * Returns all cookie values from the jar whose names contain the `keyLike`
   * Needs to exist in `utils.js` as it follows the StorageHandler interface defined in live-connect-js. If that module were to be removed, this function can go as well.
   * @param {string} keyLike
   * @param {function} [done]
   * @returns {string[]}
   */
  const findSimilarCookies = function (keyLike, done) {
    let cb = function (result) {
      if (result && result.valid) {
        const all = [];
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hasDeviceAccess)()) {
          const cookies = document.cookie.split(';');
          while (cookies.length) {
            const cookie = cookies.pop();
            let separatorIndex = cookie.indexOf('=');
            separatorIndex = separatorIndex < 0 ? cookie.length : separatorIndex;
            const cookieName = decodeURIComponent(cookie.slice(0, separatorIndex).replace(/^\s+/, ''));
            if (cookieName.indexOf(keyLike) >= 0) {
              all.push(decodeURIComponent(cookie.slice(separatorIndex + 1)));
            }
          }
        }
        return all;
      }
    };
    return schedule(cb, STORAGE_TYPE_COOKIES, done);
  };
  return {
    setCookie,
    getCookie,
    cookiesAreEnabled,
    ...storageMethods('localStorage'),
    ...storageMethods('sessionStorage'),
    findSimilarCookies
  };
}

/**
 * Get a storage manager for a particular module.
 *
 * Either bidderCode or a combination of moduleType + moduleName must be provided. The former is a shorthand
 *  for `{moduleType: 'bidder', moduleName: bidderCode}`.
 *
 */
function getStorageManager() {
  let {
    moduleType,
    moduleName,
    bidderCode
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  function err() {
    throw new Error(`Invalid invocation for getStorageManager: must set either bidderCode, or moduleType + moduleName`);
  }
  if (bidderCode) {
    if (moduleType && moduleType !== _activities_modules_js__WEBPACK_IMPORTED_MODULE_2__.MODULE_TYPE_BIDDER || moduleName) err();
    moduleType = _activities_modules_js__WEBPACK_IMPORTED_MODULE_2__.MODULE_TYPE_BIDDER;
    moduleName = bidderCode;
  } else if (!moduleName || !moduleType) {
    err();
  }
  return newStorageManager({
    moduleType,
    moduleName
  });
}

/**
 * Get a storage manager for "core" (vendorless, or first-party) modules. Shorthand for `getStorageManager({moduleName, moduleType: 'core'})`.
 *
 * @param {string} moduleName Module name
 */
function getCoreStorageManager(moduleName) {
  return newStorageManager({
    moduleName: moduleName,
    moduleType: _activities_modules_js__WEBPACK_IMPORTED_MODULE_2__.MODULE_TYPE_PREBID
  });
}

/**
 * Block all access to storage when deviceAccess = false
 */
function deviceAccessRule() {
  if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_7__.hasDeviceAccess)()) {
    return {
      allow: false
    };
  }
}
(0,_activities_rules_js__WEBPACK_IMPORTED_MODULE_0__.registerActivityControl)(_activities_activities_js__WEBPACK_IMPORTED_MODULE_4__.ACTIVITY_ACCESS_DEVICE, 'deviceAccess config', deviceAccessRule);

/**
 * By default, deny bidders accessDevice unless they enable it through bidderSettings
 *
 * // TODO: for backwards compat, the check is done on the adapter - rather than bidder's code.
 */
function storageAllowedRule(params) {
  let bs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _bidderSettings_js__WEBPACK_IMPORTED_MODULE_8__.bidderSettings;
  if (params[_activities_params_js__WEBPACK_IMPORTED_MODULE_6__.ACTIVITY_PARAM_COMPONENT_TYPE] !== _activities_modules_js__WEBPACK_IMPORTED_MODULE_2__.MODULE_TYPE_BIDDER) return;
  let allow = bs.get(params[_activities_params_js__WEBPACK_IMPORTED_MODULE_6__.ACTIVITY_PARAM_ADAPTER_CODE], 'storageAllowed');
  if (!allow || allow === true) {
    allow = !!allow;
  } else {
    const storageType = params[_activities_params_js__WEBPACK_IMPORTED_MODULE_6__.ACTIVITY_PARAM_STORAGE_TYPE];
    allow = Array.isArray(allow) ? allow.some(e => e === storageType) : allow === storageType;
  }
  if (!allow) {
    return {
      allow
    };
  }
}
(0,_activities_rules_js__WEBPACK_IMPORTED_MODULE_0__.registerActivityControl)(_activities_activities_js__WEBPACK_IMPORTED_MODULE_4__.ACTIVITY_ACCESS_DEVICE, 'bidderSettings.*.storageAllowed', storageAllowedRule);
function resetData() {
  storageCallbacks = [];
}

/***/ }),

/***/ "./src/targeting.js":
/*!**************************!*\
  !*** ./src/targeting.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   filters: () => (/* binding */ filters),
/* harmony export */   getGPTSlotsForAdUnits: () => (/* binding */ getGPTSlotsForAdUnits),
/* harmony export */   isBidUsable: () => (/* binding */ isBidUsable),
/* harmony export */   targeting: () => (/* binding */ targeting)
/* harmony export */ });
/* unused harmony exports TARGETING_KEYS_ARR, getHighestCpmBidsFromBidPool, sortByDealAndPriceBucketOrCpm, newTargeting */
/* harmony import */ var _auctionManager_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./auctionManager.js */ "./src/auctionManager.js");
/* harmony import */ var _bidTTL_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bidTTL.js */ "./src/bidTTL.js");
/* harmony import */ var _bidderSettings_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./bidderSettings.js */ "./src/bidderSettings.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config.js */ "./src/config.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./src/constants.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./events.js */ "./src/events.js");
/* harmony import */ var _hook_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hook.js */ "./src/hook.js");
/* harmony import */ var _mediaTypes_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./mediaTypes.js */ "./src/mediaTypes.js");
/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./native.js */ "./src/native.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _utils_reducers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/reducers.js */ "./src/utils/reducers.js");











var pbTargetingKeys = [];
const MAX_DFP_KEYLENGTH = 20;
const CFG_ALLOW_TARGETING_KEYS = `targetingControls.allowTargetingKeys`;
const CFG_ADD_TARGETING_KEYS = `targetingControls.addTargetingKeys`;
const TARGETING_KEY_CONFIGURATION_ERROR_MSG = `Only one of "${CFG_ALLOW_TARGETING_KEYS}" or "${CFG_ADD_TARGETING_KEYS}" can be set`;
const TARGETING_KEYS_ARR = Object.keys(_constants_js__WEBPACK_IMPORTED_MODULE_0__.TARGETING_KEYS).map(key => _constants_js__WEBPACK_IMPORTED_MODULE_0__.TARGETING_KEYS[key]);

// return unexpired bids
const isBidNotExpired = bid => bid.responseTimestamp + (0,_bidTTL_js__WEBPACK_IMPORTED_MODULE_1__.getBufferedTTL)(bid) * 1000 > (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.timestamp)();

// return bids whose status is not set. Winning bids can only have a status of `rendered`.
const isUnusedBid = bid => bid && (bid.status && ![_constants_js__WEBPACK_IMPORTED_MODULE_0__.BID_STATUS.RENDERED].includes(bid.status) || !bid.status);
let filters = {
  isActualBid(bid) {
    return bid.getStatusCode() === _constants_js__WEBPACK_IMPORTED_MODULE_0__.STATUS.GOOD;
  },
  isBidNotExpired,
  isUnusedBid
};
function isBidUsable(bid) {
  return !Object.values(filters).some(predicate => !predicate(bid));
}

// If two bids are found for same adUnitCode, we will use the highest one to take part in auction
// This can happen in case of concurrent auctions
// If adUnitBidLimit is set above 0 return top N number of bids
const getHighestCpmBidsFromBidPool = (0,_hook_js__WEBPACK_IMPORTED_MODULE_3__.hook)('sync', function (bidsReceived, winReducer) {
  let adUnitBidLimit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let hasModified = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  let winSorter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _utils_js__WEBPACK_IMPORTED_MODULE_2__.sortByHighestCpm;
  if (!hasModified) {
    const bids = [];
    const dealPrioritization = _config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('sendBidsControl.dealPrioritization');
    // bucket by adUnitcode
    let buckets = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.groupBy)(bidsReceived, 'adUnitCode');
    // filter top bid for each bucket by bidder
    Object.keys(buckets).forEach(bucketKey => {
      let bucketBids = [];
      let bidsByBidder = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.groupBy)(buckets[bucketKey], 'bidderCode');
      Object.keys(bidsByBidder).forEach(key => {
        bucketBids.push(bidsByBidder[key].reduce(winReducer));
      });
      // if adUnitBidLimit is set, pass top N number bids
      if (adUnitBidLimit) {
        bucketBids = dealPrioritization ? bucketBids.sort(sortByDealAndPriceBucketOrCpm(true)) : bucketBids.sort((a, b) => b.cpm - a.cpm);
        bids.push(...bucketBids.slice(0, adUnitBidLimit));
      } else {
        bucketBids = bucketBids.sort(winSorter);
        bids.push(...bucketBids);
      }
    });
    return bids;
  }
  return bidsReceived;
});

/**
 * A descending sort function that will sort the list of objects based on the following two dimensions:
 *  - bids with a deal are sorted before bids w/o a deal
 *  - then sort bids in each grouping based on the hb_pb value
 * eg: the following list of bids would be sorted like:
 *  [{
 *    "hb_adid": "vwx",
 *    "hb_pb": "28",
 *    "hb_deal": "7747"
 *  }, {
 *    "hb_adid": "jkl",
 *    "hb_pb": "10",
 *    "hb_deal": "9234"
 *  }, {
 *    "hb_adid": "stu",
 *    "hb_pb": "50"
 *  }, {
 *    "hb_adid": "def",
 *    "hb_pb": "2"
 *  }]
 */
function sortByDealAndPriceBucketOrCpm() {
  let useCpm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return function (a, b) {
    if (a.adserverTargeting.hb_deal !== undefined && b.adserverTargeting.hb_deal === undefined) {
      return -1;
    }
    if (a.adserverTargeting.hb_deal === undefined && b.adserverTargeting.hb_deal !== undefined) {
      return 1;
    }

    // assuming both values either have a deal or don't have a deal - sort by the hb_pb param
    if (useCpm) {
      return b.cpm - a.cpm;
    }
    return b.adserverTargeting.hb_pb - a.adserverTargeting.hb_pb;
  };
}

/**
 * Return a map where each code in `adUnitCodes` maps to a list of GPT slots that match it.
 *
 * @param {Array<String>} adUnitCodes
 * @param customSlotMatching
 * @param getSlots
 * @return {Object.<string,any>}
 */
function getGPTSlotsForAdUnits(adUnitCodes, customSlotMatching) {
  let getSlots = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => window.googletag.pubads().getSlots();
  return getSlots().reduce((auToSlots, slot) => {
    const customMatch = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isFn)(customSlotMatching) && customSlotMatching(slot);
    Object.keys(auToSlots).filter((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isFn)(customMatch) ? customMatch : (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isAdUnitCodeMatchingSlot)(slot)).forEach(au => auToSlots[au].push(slot));
    return auToSlots;
  }, Object.fromEntries(adUnitCodes.map(au => [au, []])));
}

/**
 * Clears targeting for bids
 */
function clearTargeting(slot) {
  pbTargetingKeys.forEach(key => {
    if (slot.getTargeting(key)) {
      slot.clearTargeting(key);
    }
  });
}

/**
 * @typedef {Object.<string,string>} targeting
 * @property {string} targeting_key
 */

/**
 * @typedef {Object.<string,Object.<string,string[]>[]>[]} targetingArray
 */

function newTargeting(auctionManager) {
  let targeting = {};
  let latestAuctionForAdUnit = {};
  targeting.setLatestAuctionForAdUnit = function (adUnitCode, auctionId) {
    latestAuctionForAdUnit[adUnitCode] = auctionId;
  };
  targeting.resetPresetTargeting = function (adUnitCode, customSlotMatching) {
    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isGptPubadsDefined)()) {
      const adUnitCodes = getAdUnitCodes(adUnitCode);
      Object.values(getGPTSlotsForAdUnits(adUnitCodes, customSlotMatching)).forEach(slots => {
        slots.forEach(slot => {
          clearTargeting(slot);
        });
      });
    }
  };
  targeting.resetPresetTargetingAST = function (adUnitCode) {
    const adUnitCodes = getAdUnitCodes(adUnitCode);
    adUnitCodes.forEach(function (unit) {
      const astTag = window.apntag.getTag(unit);
      if (astTag && astTag.keywords) {
        const currentKeywords = Object.keys(astTag.keywords);
        const newKeywords = {};
        currentKeywords.forEach(key => {
          if (!pbTargetingKeys.includes(key.toLowerCase())) {
            newKeywords[key] = astTag.keywords[key];
          }
        });
        window.apntag.modifyTag(unit, {
          keywords: newKeywords
        });
      }
    });
  };
  function addBidToTargeting(bids) {
    let enableSendAllBids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let deals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    const standardKeys =  true ? TARGETING_KEYS_ARR.concat(_native_js__WEBPACK_IMPORTED_MODULE_5__.NATIVE_TARGETING_KEYS) : 0;
    const allowSendAllBidsTargetingKeys = _config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('targetingControls.allowSendAllBidsTargetingKeys');
    const allowedSendAllBidTargeting = allowSendAllBidsTargetingKeys ? allowSendAllBidsTargetingKeys.map(key => _constants_js__WEBPACK_IMPORTED_MODULE_0__.TARGETING_KEYS[key]) : standardKeys;
    return bids.reduce((result, bid) => {
      if (enableSendAllBids || deals && bid.dealId) {
        const targetingValue = getTargetingMap(bid, standardKeys.filter(key => typeof bid.adserverTargeting[key] !== 'undefined' && (deals || allowedSendAllBidTargeting.indexOf(key) !== -1)));
        if (targetingValue) {
          result.push({
            [bid.adUnitCode]: targetingValue
          });
        }
      }
      return result;
    }, []);
  }
  function getBidderTargeting(bids) {
    const alwaysIncludeDeals = _config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('targetingControls.alwaysIncludeDeals');
    const enableSendAllBids = _config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('enableSendAllBids');
    return addBidToTargeting(bids, enableSendAllBids, alwaysIncludeDeals);
  }

  /**
   * Returns filtered ad server targeting for custom and allowed keys.
   * @param {targetingArray} targeting
   * @param {string[]} allowedKeys
   * @return {targetingArray} filtered targeting
   */
  function getAllowedTargetingKeyValues(targeting, allowedKeys) {
    const defaultKeyring = Object.assign({}, _constants_js__WEBPACK_IMPORTED_MODULE_0__.TARGETING_KEYS, _constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_KEYS);
    const defaultKeys = Object.keys(defaultKeyring);
    const keyDispositions = {};
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)(`allowTargetingKeys - allowed keys [ ${allowedKeys.map(k => defaultKeyring[k]).join(', ')} ]`);
    targeting.map(adUnit => {
      const adUnitCode = Object.keys(adUnit)[0];
      const keyring = adUnit[adUnitCode];
      const keys = keyring.filter(kvPair => {
        const key = Object.keys(kvPair)[0];
        // check if key is in default keys, if not, it's custom, we won't remove it.
        const isCustom = defaultKeys.filter(defaultKey => key.indexOf(defaultKeyring[defaultKey]) === 0).length === 0;
        // check if key explicitly allowed, if not, we'll remove it.
        const found = isCustom || allowedKeys.find(allowedKey => {
          const allowedKeyName = defaultKeyring[allowedKey];
          // we're looking to see if the key exactly starts with one of our default keys.
          // (which hopefully means it's not custom)
          const found = key.indexOf(allowedKeyName) === 0;
          return found;
        });
        keyDispositions[key] = !found;
        return found;
      });
      adUnit[adUnitCode] = keys;
    });
    const removedKeys = Object.keys(keyDispositions).filter(d => keyDispositions[d]);
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)(`allowTargetingKeys - removed keys [ ${removedKeys.join(', ')} ]`);
    // remove any empty targeting objects, as they're unnecessary.
    const filteredTargeting = targeting.filter(adUnit => {
      const adUnitCode = Object.keys(adUnit)[0];
      const keyring = adUnit[adUnitCode];
      return keyring.length > 0;
    });
    return filteredTargeting;
  }

  /**
   * Returns all ad server targeting for all ad units.
   * @param {string=} adUnitCode
   * @return {Object.<string,targeting>} targeting
   */
  targeting.getAllTargeting = function (adUnitCode, bidLimit, bidsReceived) {
    let winReducer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _utils_reducers_js__WEBPACK_IMPORTED_MODULE_6__.getHighestCpm;
    let winSorter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _utils_js__WEBPACK_IMPORTED_MODULE_2__.sortByHighestCpm;
    bidsReceived ||= getBidsReceived(winReducer, winSorter);
    const adUnitCodes = getAdUnitCodes(adUnitCode);
    const sendAllBids = _config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('enableSendAllBids');
    const bidLimitConfigValue = _config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('sendBidsControl.bidLimit');
    const adUnitBidLimit = sendAllBids && (bidLimit || bidLimitConfigValue) || 0;
    const {
      customKeysByUnit,
      filteredBids
    } = getfilteredBidsAndCustomKeys(adUnitCodes, bidsReceived);
    const bidsSorted = getHighestCpmBidsFromBidPool(filteredBids, winReducer, adUnitBidLimit, undefined, winSorter);
    let targeting = getTargetingLevels(bidsSorted, customKeysByUnit, adUnitCodes);
    const defaultKeys = Object.keys(Object.assign({}, _constants_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TARGETING_KEYS, _constants_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE_KEYS));
    let allowedKeys = _config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig(CFG_ALLOW_TARGETING_KEYS);
    const addedKeys = _config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig(CFG_ADD_TARGETING_KEYS);
    if (addedKeys != null && allowedKeys != null) {
      throw new Error(TARGETING_KEY_CONFIGURATION_ERROR_MSG);
    } else if (addedKeys != null) {
      allowedKeys = defaultKeys.concat(addedKeys);
    } else {
      allowedKeys = allowedKeys || defaultKeys;
    }
    if (Array.isArray(allowedKeys) && allowedKeys.length > 0) {
      targeting = getAllowedTargetingKeyValues(targeting, allowedKeys);
    }
    targeting = flattenTargeting(targeting);
    const auctionKeysThreshold = _config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('targetingControls.auctionKeyMaxChars');
    if (auctionKeysThreshold) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)(`Detected 'targetingControls.auctionKeyMaxChars' was active for this auction; set with a limit of ${auctionKeysThreshold} characters.  Running checks on auction keys...`);
      targeting = filterTargetingKeys(targeting, auctionKeysThreshold);
    }

    // make sure at least there is a entry per adUnit code in the targetingSet so receivers of SET_TARGETING call's can know what ad units are being invoked
    adUnitCodes.forEach(code => {
      if (!targeting[code]) {
        targeting[code] = {};
      }
    });
    return targeting;
  };
  function updatePBTargetingKeys(adUnitCode) {
    Object.keys(adUnitCode).forEach(key => {
      adUnitCode[key].forEach(targetKey => {
        const targetKeys = Object.keys(targetKey);
        if (pbTargetingKeys.indexOf(targetKeys[0]) === -1) {
          pbTargetingKeys = targetKeys.concat(pbTargetingKeys);
        }
      });
    });
  }
  function getTargetingLevels(bidsSorted, customKeysByUnit, adUnitCodes) {
    const useAllBidsCustomTargeting = _config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('targetingControls.allBidsCustomTargeting') !== false;
    const targeting = getWinningBidTargeting(bidsSorted, adUnitCodes).concat(getBidderTargeting(bidsSorted)).concat(getAdUnitTargeting(adUnitCodes));
    if (useAllBidsCustomTargeting) {
      targeting.push(...getCustomBidTargeting(bidsSorted, customKeysByUnit));
    }
    targeting.forEach(adUnitCode => {
      updatePBTargetingKeys(adUnitCode);
    });
    return targeting;
  }
  function getfilteredBidsAndCustomKeys(adUnitCodes, bidsReceived) {
    const filteredBids = [];
    const customKeysByUnit = {};
    const alwaysIncludeDeals = _config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('targetingControls.alwaysIncludeDeals');
    bidsReceived.forEach(bid => {
      const adUnitIsEligible = adUnitCodes.includes(bid.adUnitCode);
      const cpmAllowed = _bidderSettings_js__WEBPACK_IMPORTED_MODULE_7__.bidderSettings.get(bid.bidderCode, 'allowZeroCpmBids') === true ? bid.cpm >= 0 : bid.cpm > 0;
      const isPreferredDeal = alwaysIncludeDeals && bid.dealId;
      if (adUnitIsEligible && (isPreferredDeal || cpmAllowed)) {
        filteredBids.push(bid);
        Object.keys(bid.adserverTargeting).filter(getCustomKeys()).forEach(key => {
          const truncKey = key.substring(0, MAX_DFP_KEYLENGTH);
          const data = customKeysByUnit[bid.adUnitCode] || {};
          const value = [bid.adserverTargeting[key]];
          if (data[truncKey]) {
            data[truncKey] = data[truncKey].concat(value).filter(_utils_js__WEBPACK_IMPORTED_MODULE_2__.uniques);
          } else {
            data[truncKey] = value;
          }
          customKeysByUnit[bid.adUnitCode] = data;
        });
      }
    });
    return {
      filteredBids,
      customKeysByUnit
    };
  }

  // warn about conflicting configuration
  _config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('targetingControls', function (config) {
    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"])(config, CFG_ALLOW_TARGETING_KEYS) != null && (0,_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"])(config, CFG_ADD_TARGETING_KEYS) != null) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)(TARGETING_KEY_CONFIGURATION_ERROR_MSG);
    }
  });

  // create an encoded string variant based on the keypairs of the provided object
  //  - note this will encode the characters between the keys (ie = and &)
  function convertKeysToQueryForm(keyMap) {
    return Object.keys(keyMap).reduce(function (queryString, key) {
      let encodedKeyPair = `${key}%3d${encodeURIComponent(keyMap[key])}%26`;
      return queryString += encodedKeyPair;
    }, '');
  }
  function filterTargetingKeys(targeting, auctionKeysThreshold) {
    // read each targeting.adUnit object and sort the adUnits into a list of adUnitCodes based on priorization setting (eg CPM)
    let targetingCopy = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.deepClone)(targeting);
    let targetingMap = Object.keys(targetingCopy).map(adUnitCode => {
      return {
        adUnitCode,
        adserverTargeting: targetingCopy[adUnitCode]
      };
    }).sort(sortByDealAndPriceBucketOrCpm());

    // iterate through the targeting based on above list and transform the keys into the query-equivalent and count characters
    return targetingMap.reduce(function (accMap, currMap, index, arr) {
      let adUnitQueryString = convertKeysToQueryForm(currMap.adserverTargeting);

      // for the last adUnit - trim last encoded ampersand from the converted query string
      if (index + 1 === arr.length) {
        adUnitQueryString = adUnitQueryString.slice(0, -3);
      }

      // if under running threshold add to result
      let code = currMap.adUnitCode;
      let querySize = adUnitQueryString.length;
      if (querySize <= auctionKeysThreshold) {
        auctionKeysThreshold -= querySize;
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)(`AdUnit '${code}' auction keys comprised of ${querySize} characters.  Deducted from running threshold; new limit is ${auctionKeysThreshold}`, targetingCopy[code]);
        accMap[code] = targetingCopy[code];
      } else {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)(`The following keys for adUnitCode '${code}' exceeded the current limit of the 'auctionKeyMaxChars' setting.\nThe key-set size was ${querySize}, the current allotted amount was ${auctionKeysThreshold}.\n`, targetingCopy[code]);
      }
      if (index + 1 === arr.length && Object.keys(accMap).length === 0) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)('No auction targeting keys were permitted due to the setting in setConfig(targetingControls.auctionKeyMaxChars).  Please review setup and consider adjusting.');
      }
      return accMap;
    }, {});
  }

  /**
   * Converts targeting array and flattens to make it easily iteratable
   * e.g: Sample input to this function
   * ```
   * [
   *    {
   *      "div-gpt-ad-1460505748561-0": [{"hb_bidder": ["appnexusAst"]}]
   *    },
   *    {
   *      "div-gpt-ad-1460505748561-0": [{"hb_bidder_appnexusAs": ["appnexusAst", "other"]}]
   *    }
   * ]
   * ```
   * Resulting array
   * ```
   * {
   *  "div-gpt-ad-1460505748561-0": {
   *    "hb_bidder": "appnexusAst",
   *    "hb_bidder_appnexusAs": "appnexusAst,other"
   *  }
   * }
   * ```
   *
   * @param {targetingArray}  targeting
   * @return {Object.<string,targeting>}  targeting
   */
  function flattenTargeting(targeting) {
    let targetingObj = targeting.map(targeting => {
      return {
        [Object.keys(targeting)[0]]: targeting[Object.keys(targeting)[0]].map(target => {
          return {
            [Object.keys(target)[0]]: target[Object.keys(target)[0]].join(',')
          };
        }).reduce((p, c) => Object.assign(c, p), {})
      };
    });
    targetingObj = targetingObj.reduce(function (accumulator, targeting) {
      var key = Object.keys(targeting)[0];
      accumulator[key] = Object.assign({}, accumulator[key], targeting[key]);
      return accumulator;
    }, {});
    return targetingObj;
  }
  targeting.setTargetingForGPT = (0,_hook_js__WEBPACK_IMPORTED_MODULE_3__.hook)('sync', function (adUnit, customSlotMatching) {
    // get our ad unit codes
    let targetingSet = targeting.getAllTargeting(adUnit);
    let resetMap = Object.fromEntries(pbTargetingKeys.map(key => [key, null]));
    Object.entries(getGPTSlotsForAdUnits(Object.keys(targetingSet), customSlotMatching)).forEach(_ref => {
      let [targetId, slots] = _ref;
      if (slots.length > 1) {
        // This can lead to duplicate impressions. This is existing behavior and changing to only target one slot could be a breaking change for existing integrations.
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)(`Multiple slots found matching: ${targetId}. Targeting will be set on all matching slots, which can lead to duplicate impressions if more than one are requested from GAM. To resolve this, ensure the arguments to setTargetingForGPTAsync resolve to a single slot by explicitly matching the desired slotElementID.`);
      }
      slots.forEach(slot => {
        // now set new targeting keys
        Object.keys(targetingSet[targetId]).forEach(key => {
          let value = targetingSet[targetId][key];
          if (typeof value === 'string' && value.indexOf(',') !== -1) {
            // due to the check the array will be formed only if string has ',' else plain string will be assigned as value
            value = value.split(',');
          }
          targetingSet[targetId][key] = value;
        });
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.logMessage)(`Attempting to set targeting-map for slot: ${slot.getSlotElementId()} with targeting-map:`, targetingSet[targetId]);
        slot.updateTargetingFromMap(Object.assign({}, resetMap, targetingSet[targetId]));
      });
    });
    Object.keys(targetingSet).forEach(adUnitCode => {
      Object.keys(targetingSet[adUnitCode]).forEach(targetingKey => {
        if (targetingKey === 'hb_adid') {
          auctionManager.setStatusForBids(targetingSet[adUnitCode][targetingKey], _constants_js__WEBPACK_IMPORTED_MODULE_0__.BID_STATUS.BID_TARGETING_SET);
        }
      });
    });
    targeting.targetingDone(targetingSet);

    // emit event
    _events_js__WEBPACK_IMPORTED_MODULE_9__.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.EVENTS.SET_TARGETING, targetingSet);
  }, 'setTargetingForGPT');
  targeting.targetingDone = (0,_hook_js__WEBPACK_IMPORTED_MODULE_3__.hook)('sync', function (targetingSet) {
    return targetingSet;
  }, 'targetingDone');

  /**
   * normlizes input to a `adUnit.code` array
   * @param  {(string|string[])} adUnitCode [description]
   * @return {string[]}     AdUnit code array
   */
  function getAdUnitCodes(adUnitCode) {
    if (typeof adUnitCode === 'string') {
      return [adUnitCode];
    } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(adUnitCode)) {
      return adUnitCode;
    }
    return auctionManager.getAdUnitCodes() || [];
  }
  function getBidsReceived() {
    let winReducer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _utils_reducers_js__WEBPACK_IMPORTED_MODULE_6__.getOldestHighestCpmBid;
    let winSorter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    let bidsReceived = auctionManager.getBidsReceived().reduce((bids, bid) => {
      const bidCacheEnabled = _config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('useBidCache');
      const filterFunction = _config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('bidCacheFilterFunction');
      const isBidFromLastAuction = latestAuctionForAdUnit[bid.adUnitCode] === bid.auctionId;
      const filterFunctionResult = bidCacheEnabled && !isBidFromLastAuction && typeof filterFunction === 'function' ? !!filterFunction(bid) : true;
      const cacheFilter = bidCacheEnabled || isBidFromLastAuction;
      const bidFilter = cacheFilter && filterFunctionResult;
      if (bidFilter && (0,_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"])(bid, 'video.context') !== _mediaTypes_js__WEBPACK_IMPORTED_MODULE_10__.ADPOD && isBidUsable(bid)) {
        bid.latestTargetedAuctionId = latestAuctionForAdUnit[bid.adUnitCode];
        bids.push(bid);
      }
      return bids;
    }, []);
    return getHighestCpmBidsFromBidPool(bidsReceived, winReducer, undefined, undefined, undefined, winSorter);
  }

  /**
   * Returns top bids for a given adUnit or set of adUnits.
   * @param  {(string|string[])} adUnitCode adUnitCode or array of adUnitCodes
   * @param  {(Array|undefined)} bids - The received bids, defaulting to the result of getBidsReceived().
   * @param  {function(Array<Object>): Array<Object>} [winReducer = getHighestCpm] - reducer method
   * @param  {function(Array<Object>): Array<Object>} [winSorter = sortByHighestCpm] - sorter method
   * @return {Array<Object>} - An array of winning bids.
   */
  targeting.getWinningBids = function (adUnitCode, bids) {
    let winReducer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _utils_reducers_js__WEBPACK_IMPORTED_MODULE_6__.getHighestCpm;
    let winSorter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _utils_js__WEBPACK_IMPORTED_MODULE_2__.sortByHighestCpm;
    const bidsReceived = bids || getBidsReceived(winReducer, winSorter);
    const adUnitCodes = getAdUnitCodes(adUnitCode);
    return bidsReceived.filter(bid => adUnitCodes.includes(bid.adUnitCode)).filter(bid => _bidderSettings_js__WEBPACK_IMPORTED_MODULE_7__.bidderSettings.get(bid.bidderCode, 'allowZeroCpmBids') === true ? bid.cpm >= 0 : bid.cpm > 0).map(bid => bid.adUnitCode).filter(_utils_js__WEBPACK_IMPORTED_MODULE_2__.uniques).map(adUnitCode => bidsReceived.filter(bid => bid.adUnitCode === adUnitCode ? bid : null).reduce(_utils_reducers_js__WEBPACK_IMPORTED_MODULE_6__.getHighestCpm));
  };

  /**
   * @param  {(string|string[])} adUnitCodes adUnitCode or array of adUnitCodes
   * Sets targeting for AST
   */
  targeting.setTargetingForAst = function (adUnitCodes) {
    let astTargeting = targeting.getAllTargeting(adUnitCodes);
    try {
      targeting.resetPresetTargetingAST(adUnitCodes);
    } catch (e) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)('unable to reset targeting for AST' + e);
    }
    Object.keys(astTargeting).forEach(targetId => Object.keys(astTargeting[targetId]).forEach(key => {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.logMessage)(`Attempting to set targeting for targetId: ${targetId} key: ${key} value: ${astTargeting[targetId][key]}`);
      // setKeywords supports string and array as value
      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isStr)(astTargeting[targetId][key]) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(astTargeting[targetId][key])) {
        let keywordsObj = {};
        let regex = /pt[0-9]/;
        if (key.search(regex) < 0) {
          keywordsObj[key.toUpperCase()] = astTargeting[targetId][key];
        } else {
          // pt${n} keys should not be uppercased
          keywordsObj[key] = astTargeting[targetId][key];
        }
        window.apntag.setKeywords(targetId, keywordsObj, {
          overrideKeyValue: true
        });
      }
    }));
  };

  /**
   * Get targeting key value pairs for winning bid.
   * @param {Array<Object>} bidsReceived code array
   * @param {string[]} adUnitCodes code array
   * @return {targetingArray} winning bids targeting
   */
  function getWinningBidTargeting(bidsReceived, adUnitCodes) {
    let winners = targeting.getWinningBids(adUnitCodes, bidsReceived);
    let standardKeys = getStandardKeys();
    winners = winners.map(winner => {
      return {
        [winner.adUnitCode]: Object.keys(winner.adserverTargeting).filter(key => typeof winner.sendStandardTargeting === 'undefined' || winner.sendStandardTargeting || standardKeys.indexOf(key) === -1).reduce((acc, key) => {
          const targetingValue = [winner.adserverTargeting[key]];
          const targeting = {
            [key.substring(0, MAX_DFP_KEYLENGTH)]: targetingValue
          };
          if (key === _constants_js__WEBPACK_IMPORTED_MODULE_0__.TARGETING_KEYS.DEAL) {
            const bidderCodeTargetingKey = `${key}_${winner.bidderCode}`.substring(0, MAX_DFP_KEYLENGTH);
            const bidderCodeTargeting = {
              [bidderCodeTargetingKey]: targetingValue
            };
            return [...acc, targeting, bidderCodeTargeting];
          }
          return [...acc, targeting];
        }, [])
      };
    });
    return winners;
  }
  function getStandardKeys() {
    return auctionManager.getStandardBidderAdServerTargeting() // in case using a custom standard key set
    .map(targeting => targeting.key).concat(TARGETING_KEYS_ARR).filter(_utils_js__WEBPACK_IMPORTED_MODULE_2__.uniques); // standard keys defined in the library.
  }
  function getCustomKeys() {
    let standardKeys = getStandardKeys();
    if (true) {
      standardKeys = standardKeys.concat(_native_js__WEBPACK_IMPORTED_MODULE_5__.NATIVE_TARGETING_KEYS);
    }
    return function (key) {
      return standardKeys.indexOf(key) === -1;
    };
  }

  /**
   * Get custom targeting key value pairs for bids.
   * @param {Array<Object>} bidsSorted code array
   * @param {Object} customKeysByUnit code array
   * @return {targetingArray} bids with custom targeting defined in bidderSettings
   */
  function getCustomBidTargeting(bidsSorted, customKeysByUnit) {
    return bidsSorted.reduce((acc, bid) => {
      const newBid = Object.assign({}, bid);
      const customKeysForUnit = customKeysByUnit[newBid.adUnitCode];
      const targeting = [];
      if (customKeysForUnit) {
        Object.keys(customKeysForUnit).forEach(key => {
          if (key && customKeysForUnit[key]) targeting.push({
            [key]: customKeysForUnit[key]
          });
        });
      }
      acc.push({
        [newBid.adUnitCode]: targeting
      });
      return acc;
    }, []);
  }
  function getTargetingMap(bid, keys) {
    return keys.reduce((targeting, key) => {
      const value = bid.adserverTargeting[key];
      if (value) {
        targeting.push({
          [`${key}_${bid.bidderCode}`.substring(0, MAX_DFP_KEYLENGTH)]: [bid.adserverTargeting[key]]
        });
      }
      return targeting;
    }, []);
  }
  function getAdUnitTargeting(adUnitCodes) {
    function getTargetingObj(adUnit) {
      return adUnit?.[_constants_js__WEBPACK_IMPORTED_MODULE_0__.JSON_MAPPING.ADSERVER_TARGETING];
    }
    function getTargetingValues(adUnit) {
      const aut = getTargetingObj(adUnit);
      return Object.keys(aut).map(function (key) {
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isStr)(aut[key])) aut[key] = aut[key].split(',').map(s => s.trim());
        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(aut[key])) aut[key] = [aut[key]];
        return {
          [key]: aut[key]
        };
      });
    }
    return auctionManager.getAdUnits().filter(adUnit => adUnitCodes.includes(adUnit.code) && getTargetingObj(adUnit)).reduce((result, adUnit) => {
      const targetingValues = getTargetingValues(adUnit);
      if (targetingValues) result.push({
        [adUnit.code]: targetingValues
      });
      return result;
    }, []);
  }
  targeting.isApntagDefined = function () {
    if (window.apntag && (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isFn)(window.apntag.setKeywords)) {
      return true;
    }
  };
  return targeting;
}
const targeting = newTargeting(_auctionManager_js__WEBPACK_IMPORTED_MODULE_11__.auctionManager);

/***/ }),

/***/ "./src/userSync.js":
/*!*************************!*\
  !*** ./src/userSync.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   USERSYNC_DEFAULT_CONFIG: () => (/* binding */ USERSYNC_DEFAULT_CONFIG),
/* harmony export */   userSync: () => (/* binding */ userSync)
/* harmony export */ });
/* unused harmony export newUserSync */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ "./src/config.js");
/* harmony import */ var _storageManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./storageManager.js */ "./src/storageManager.js");
/* harmony import */ var _activities_rules_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./activities/rules.js */ "./src/activities/rules.js");
/* harmony import */ var _activities_activities_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./activities/activities.js */ "./src/activities/activities.js");
/* harmony import */ var _activities_params_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./activities/params.js */ "./src/activities/params.js");
/* harmony import */ var _activities_modules_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./activities/modules.js */ "./src/activities/modules.js");
/* harmony import */ var _activities_activityParams_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./activities/activityParams.js */ "./src/activities/activityParams.js");








const USERSYNC_DEFAULT_CONFIG = {
  syncEnabled: true,
  filterSettings: {
    image: {
      bidders: '*',
      filter: 'include'
    }
  },
  syncsPerBidder: 5,
  syncDelay: 3000,
  auctionDelay: 500
};

// Set userSync default values
_config_js__WEBPACK_IMPORTED_MODULE_0__.config.setDefaults({
  'userSync': (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.deepClone)(USERSYNC_DEFAULT_CONFIG)
});
const storage = (0,_storageManager_js__WEBPACK_IMPORTED_MODULE_2__.getCoreStorageManager)('usersync');

/**
 * Factory function which creates a new UserSyncPool.
 *
 * @param {} deps Configuration options and dependencies which the
 *   UserSync object needs in order to behave properly.
 */
function newUserSync(deps) {
  let publicApi = {};
  // A queue of user syncs for each adapter
  // Let getDefaultQueue() set the defaults
  let queue = getDefaultQueue();

  // Whether or not user syncs have been trigger on this page load for a specific bidder
  let hasFiredBidder = new Set();
  // How many bids for each adapter
  let numAdapterBids = {};

  // for now - default both to false in case filterSettings config is absent/misconfigured
  let permittedPixels = {
    image: true,
    iframe: false
  };

  // Use what is in config by default
  let usConfig = deps.config;
  // Update if it's (re)set
  _config_js__WEBPACK_IMPORTED_MODULE_0__.config.getConfig('userSync', conf => {
    // Added this logic for https://github.com/prebid/Prebid.js/issues/4864
    // if userSync.filterSettings does not contain image/all configs, merge in default image config to ensure image pixels are fired
    if (conf.userSync) {
      let fs = conf.userSync.filterSettings;
      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(fs)) {
        if (!fs.image && !fs.all) {
          conf.userSync.filterSettings.image = {
            bidders: '*',
            filter: 'include'
          };
        }
      }
    }
    usConfig = Object.assign(usConfig, conf.userSync);
  });
  deps.regRule(_activities_activities_js__WEBPACK_IMPORTED_MODULE_3__.ACTIVITY_SYNC_USER, 'userSync config', params => {
    if (!usConfig.syncEnabled) {
      return {
        allow: false,
        reason: 'syncs are disabled'
      };
    }
    if (params[_activities_params_js__WEBPACK_IMPORTED_MODULE_4__.ACTIVITY_PARAM_COMPONENT_TYPE] === _activities_modules_js__WEBPACK_IMPORTED_MODULE_5__.MODULE_TYPE_BIDDER) {
      const syncType = params[_activities_params_js__WEBPACK_IMPORTED_MODULE_4__.ACTIVITY_PARAM_SYNC_TYPE];
      const bidder = params[_activities_params_js__WEBPACK_IMPORTED_MODULE_4__.ACTIVITY_PARAM_COMPONENT_NAME];
      if (!publicApi.canBidderRegisterSync(syncType, bidder)) {
        return {
          allow: false,
          reason: `${syncType} syncs are not enabled for ${bidder}`
        };
      }
    }
  });

  /**
   * @function getDefaultQueue
   * @summary Returns the default empty queue
   * @private
   * @return {object} A queue with no syncs
   */
  function getDefaultQueue() {
    return {
      image: [],
      iframe: []
    };
  }

  /**
   * @function fireSyncs
   * @summary Trigger all user syncs in the queue
   * @private
   */
  function fireSyncs() {
    if (!usConfig.syncEnabled || !deps.browserSupportsCookies) {
      return;
    }
    try {
      // Iframe syncs
      loadIframes();
      // Image pixels
      fireImagePixels();
    } catch (e) {
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)('Error firing user syncs', e);
    }
    // Reset the user sync queue
    queue = getDefaultQueue();
  }
  function forEachFire(queue, fn) {
    // Randomize the order of the pixels before firing
    // This is to avoid giving any bidder who has registered multiple syncs
    // any preferential treatment and balancing them out
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.shuffle)(queue).forEach(fn);
  }

  /**
   * @function fireImagePixels
   * @summary Loops through user sync pixels and fires each one
   * @private
   */
  function fireImagePixels() {
    if (!permittedPixels.image) {
      return;
    }
    forEachFire(queue.image, sync => {
      let [bidderName, trackingPixelUrl] = sync;
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logMessage)(`Invoking image pixel user sync for bidder: ${bidderName}`);
      // Create image object and add the src url
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.triggerPixel)(trackingPixelUrl);
    });
  }

  /**
   * @function loadIframes
   * @summary Loops through iframe syncs and loads an iframe element into the page
   * @private
   */
  function loadIframes() {
    if (!permittedPixels.iframe) {
      return;
    }
    forEachFire(queue.iframe, sync => {
      let [bidderName, iframeUrl] = sync;
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logMessage)(`Invoking iframe user sync for bidder: ${bidderName}`);
      // Insert iframe into DOM
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.insertUserSyncIframe)(iframeUrl);
      // for a bidder, if iframe sync is present then remove image pixel
      removeImagePixelsForBidder(queue, bidderName);
    });
  }
  function removeImagePixelsForBidder(queue, iframeSyncBidderName) {
    queue.image = queue.image.filter(imageSync => {
      let imageSyncBidderName = imageSync[0];
      return imageSyncBidderName !== iframeSyncBidderName;
    });
  }

  /**
   * @function incrementAdapterBids
   * @summary Increment the count of user syncs queue for the adapter
   * @private
   * @param {object} numAdapterBids The object contain counts for all adapters
   * @param {string} bidder The name of the bidder adding a sync
   * @returns {object} The updated version of numAdapterBids
   */
  function incrementAdapterBids(numAdapterBids, bidder) {
    if (!numAdapterBids[bidder]) {
      numAdapterBids[bidder] = 1;
    } else {
      numAdapterBids[bidder] += 1;
    }
    return numAdapterBids;
  }

  /**
   * @function registerSync
   * @summary Add sync for this bidder to a queue to be fired later
   * @public
   * @param {string} type The type of the sync including image, iframe
   * @param {string} bidder The name of the adapter. e.g. "rubicon"
   * @param {string} url Either the pixel url or iframe url depending on the type
   * @example <caption>Using Image Sync</caption>
   * // registerSync(type, adapter, pixelUrl)
   * userSync.registerSync('image', 'rubicon', 'http://example.com/pixel')
   */
  publicApi.registerSync = (type, bidder, url) => {
    if (hasFiredBidder.has(bidder)) {
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logMessage)(`already fired syncs for "${bidder}", ignoring registerSync call`);
    }
    if (!usConfig.syncEnabled || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(queue[type])) {
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`User sync type "${type}" not supported`);
    }
    if (!bidder) {
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Bidder is required for registering sync`);
    }
    if (usConfig.syncsPerBidder !== 0 && Number(numAdapterBids[bidder]) >= usConfig.syncsPerBidder) {
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Number of user syncs exceeded for "${bidder}"`);
    }
    if (deps.isAllowed(_activities_activities_js__WEBPACK_IMPORTED_MODULE_3__.ACTIVITY_SYNC_USER, (0,_activities_activityParams_js__WEBPACK_IMPORTED_MODULE_6__.activityParams)(_activities_modules_js__WEBPACK_IMPORTED_MODULE_5__.MODULE_TYPE_BIDDER, bidder, {
      [_activities_params_js__WEBPACK_IMPORTED_MODULE_4__.ACTIVITY_PARAM_SYNC_TYPE]: type,
      [_activities_params_js__WEBPACK_IMPORTED_MODULE_4__.ACTIVITY_PARAM_SYNC_URL]: url
    }))) {
      // the bidder's pixel has passed all checks and is allowed to register
      queue[type].push([bidder, url]);
      numAdapterBids = incrementAdapterBids(numAdapterBids, bidder);
    }
  };

  /**
   * Mark a bidder as done with its user syncs - no more will be accepted from them in this session.
   * @param {string} bidderCode
   */
  publicApi.bidderDone = hasFiredBidder.add.bind(hasFiredBidder);

  /**
   * @function shouldBidderBeBlocked
   * @summary Check filterSettings logic to determine if the bidder should be prevented from registering their userSync tracker
   * @private
   * @param {string} type The type of the sync; either image or iframe
   * @param {string} bidder The name of the adapter. e.g. "rubicon"
   * @returns {boolean} true => bidder is not allowed to register; false => bidder can register
   */
  function shouldBidderBeBlocked(type, bidder) {
    let filterConfig = usConfig.filterSettings;

    // apply the filter check if the config object is there (eg filterSettings.iframe exists) and if the config object is properly setup
    if (isFilterConfigValid(filterConfig, type)) {
      permittedPixels[type] = true;
      let activeConfig = filterConfig.all ? filterConfig.all : filterConfig[type];
      let biddersToFilter = activeConfig.bidders === '*' ? [bidder] : activeConfig.bidders;
      let filterType = activeConfig.filter || 'include'; // set default if undefined

      // return true if the bidder is either: not part of the include (ie outside the whitelist) or part of the exclude (ie inside the blacklist)
      const checkForFiltering = {
        'include': (bidders, bidder) => !bidders.includes(bidder),
        'exclude': (bidders, bidder) => bidders.includes(bidder)
      };
      return checkForFiltering[filterType](biddersToFilter, bidder);
    }
    return !permittedPixels[type];
  }

  /**
   * @function isFilterConfigValid
   * @summary Check if the filterSettings object in the userSync config is setup properly
   * @private
   * @param {object} filterConfig sub-config object taken from filterSettings
   * @param {string} type The type of the sync; either image or iframe
   * @returns {boolean} true => config is setup correctly, false => setup incorrectly or filterConfig[type] is not present
   */
  function isFilterConfigValid(filterConfig, type) {
    if (filterConfig.all && filterConfig[type]) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Detected presence of the "filterSettings.all" and "filterSettings.${type}" in userSync config.  You cannot mix "all" with "iframe/image" configs; they are mutually exclusive.`);
      return false;
    }
    let activeConfig = filterConfig.all ? filterConfig.all : filterConfig[type];
    let activeConfigName = filterConfig.all ? 'all' : type;

    // if current pixel type isn't part of the config's logic, skip rest of the config checks...
    // we return false to skip subsequent filter checks in shouldBidderBeBlocked() function
    if (!activeConfig) {
      return false;
    }
    let filterField = activeConfig.filter;
    let biddersField = activeConfig.bidders;
    if (filterField && filterField !== 'include' && filterField !== 'exclude') {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`UserSync "filterSettings.${activeConfigName}.filter" setting '${filterField}' is not a valid option; use either 'include' or 'exclude'.`);
      return false;
    }
    if (biddersField !== '*' && !(Array.isArray(biddersField) && biddersField.length > 0 && biddersField.every(bidderInList => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isStr)(bidderInList) && bidderInList !== '*'))) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Detected an invalid setup in userSync "filterSettings.${activeConfigName}.bidders"; use either '*' (to represent all bidders) or an array of bidders.`);
      return false;
    }
    return true;
  }

  /**
   * @function syncUsers
   * @summary Trigger all the user syncs based on publisher-defined timeout
   * @public
   * @param {number} timeout The delay in ms before syncing data - default 0
   */
  publicApi.syncUsers = function () {
    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (timeout) {
      return setTimeout(fireSyncs, Number(timeout));
    }
    fireSyncs();
  };

  /**
   * @function triggerUserSyncs
   * @summary A `syncUsers` wrapper for determining if enableOverride has been turned on
   * @public
   */
  publicApi.triggerUserSyncs = () => {
    if (usConfig.enableOverride) {
      publicApi.syncUsers();
    }
  };
  publicApi.canBidderRegisterSync = (type, bidder) => {
    if (usConfig.filterSettings) {
      if (shouldBidderBeBlocked(type, bidder)) {
        return false;
      }
    }
    return true;
  };
  return publicApi;
}
const userSync = newUserSync(Object.defineProperties({
  config: _config_js__WEBPACK_IMPORTED_MODULE_0__.config.getConfig('userSync'),
  isAllowed: _activities_rules_js__WEBPACK_IMPORTED_MODULE_7__.isActivityAllowed,
  regRule: _activities_rules_js__WEBPACK_IMPORTED_MODULE_7__.registerActivityControl
}, {
  browserSupportsCookies: {
    get: function () {
      // call storage lazily to give time for consent data to be available
      return !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isSafariBrowser)() && storage.cookiesAreEnabled();
    }
  }
}));

/**
 * @typedef {Object} UserSyncConfig
 *
 * @property {boolean} enableOverride
 * @property {boolean} syncEnabled
 * @property {number} syncsPerBidder
 * @property {string[]} enabledBidders
 * @property {Object} filterSettings
 */

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _each: () => (/* binding */ _each),
/* harmony export */   _setEventEmitter: () => (/* binding */ _setEventEmitter),
/* harmony export */   binarySearch: () => (/* binding */ binarySearch),
/* harmony export */   buildUrl: () => (/* binding */ buildUrl),
/* harmony export */   checkCookieSupport: () => (/* binding */ checkCookieSupport),
/* harmony export */   compareCodeAndSlot: () => (/* binding */ compareCodeAndSlot),
/* harmony export */   compressDataWithGZip: () => (/* binding */ compressDataWithGZip),
/* harmony export */   createIframe: () => (/* binding */ createIframe),
/* harmony export */   createInvisibleIframe: () => (/* binding */ createInvisibleIframe),
/* harmony export */   createTrackPixelHtml: () => (/* binding */ createTrackPixelHtml),
/* harmony export */   cyrb53Hash: () => (/* binding */ cyrb53Hash),
/* harmony export */   debugTurnedOn: () => (/* binding */ debugTurnedOn),
/* harmony export */   deepClone: () => (/* binding */ deepClone),
/* harmony export */   deepEqual: () => (/* binding */ deepEqual),
/* harmony export */   delayExecution: () => (/* binding */ delayExecution),
/* harmony export */   encodeMacroURI: () => (/* binding */ encodeMacroURI),
/* harmony export */   flatten: () => (/* binding */ flatten),
/* harmony export */   formatQS: () => (/* binding */ formatQS),
/* harmony export */   generateUUID: () => (/* binding */ generateUUID),
/* harmony export */   getBidIdParameter: () => (/* binding */ getBidIdParameter),
/* harmony export */   getBidRequest: () => (/* binding */ getBidRequest),
/* harmony export */   getBidderCodes: () => (/* binding */ getBidderCodes),
/* harmony export */   getDNT: () => (/* binding */ getDNT),
/* harmony export */   getDefinedParams: () => (/* binding */ getDefinedParams),
/* harmony export */   getDocument: () => (/* binding */ getDocument),
/* harmony export */   getParameterByName: () => (/* binding */ getParameterByName),
/* harmony export */   getPerformanceNow: () => (/* binding */ getPerformanceNow),
/* harmony export */   getUniqueIdentifierStr: () => (/* binding */ getUniqueIdentifierStr),
/* harmony export */   getUserConfiguredParams: () => (/* binding */ getUserConfiguredParams),
/* harmony export */   getWinDimensions: () => (/* binding */ getWinDimensions),
/* harmony export */   getWindowSelf: () => (/* binding */ getWindowSelf),
/* harmony export */   getWindowTop: () => (/* binding */ getWindowTop),
/* harmony export */   groupBy: () => (/* binding */ groupBy),
/* harmony export */   hasDeviceAccess: () => (/* binding */ hasDeviceAccess),
/* harmony export */   hasNonSerializableProperty: () => (/* binding */ hasNonSerializableProperty),
/* harmony export */   inIframe: () => (/* binding */ inIframe),
/* harmony export */   insertElement: () => (/* binding */ insertElement),
/* harmony export */   insertHtmlIntoIframe: () => (/* binding */ insertHtmlIntoIframe),
/* harmony export */   insertUserSyncIframe: () => (/* binding */ insertUserSyncIframe),
/* harmony export */   internal: () => (/* binding */ internal),
/* harmony export */   isAdUnitCodeMatchingSlot: () => (/* binding */ isAdUnitCodeMatchingSlot),
/* harmony export */   isApnGetTagDefined: () => (/* binding */ isApnGetTagDefined),
/* harmony export */   isArray: () => (/* binding */ isArray),
/* harmony export */   isArrayOfNums: () => (/* binding */ isArrayOfNums),
/* harmony export */   isBoolean: () => (/* binding */ isBoolean),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isEmptyStr: () => (/* binding */ isEmptyStr),
/* harmony export */   isFn: () => (/* binding */ isFn),
/* harmony export */   isGptPubadsDefined: () => (/* binding */ isGptPubadsDefined),
/* harmony export */   isGzipCompressionSupported: () => (/* binding */ isGzipCompressionSupported),
/* harmony export */   isInteger: () => (/* binding */ isInteger),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),
/* harmony export */   isSafariBrowser: () => (/* binding */ isSafariBrowser),
/* harmony export */   isStr: () => (/* binding */ isStr),
/* harmony export */   isValidMediaTypes: () => (/* binding */ isValidMediaTypes),
/* harmony export */   logError: () => (/* binding */ logError),
/* harmony export */   logInfo: () => (/* binding */ logInfo),
/* harmony export */   logMessage: () => (/* binding */ logMessage),
/* harmony export */   logWarn: () => (/* binding */ logWarn),
/* harmony export */   memoize: () => (/* binding */ memoize),
/* harmony export */   mergeDeep: () => (/* binding */ mergeDeep),
/* harmony export */   parseGPTSingleSizeArray: () => (/* binding */ parseGPTSingleSizeArray),
/* harmony export */   parseQueryStringParameters: () => (/* binding */ parseQueryStringParameters),
/* harmony export */   parseSizesInput: () => (/* binding */ parseSizesInput),
/* harmony export */   parseUrl: () => (/* binding */ parseUrl),
/* harmony export */   pick: () => (/* binding */ pick),
/* harmony export */   prefixLog: () => (/* binding */ prefixLog),
/* harmony export */   replaceMacros: () => (/* binding */ replaceMacros),
/* harmony export */   safeJSONParse: () => (/* binding */ safeJSONParse),
/* harmony export */   setScriptAttributes: () => (/* binding */ setScriptAttributes),
/* harmony export */   shuffle: () => (/* binding */ shuffle),
/* harmony export */   sizeTupleToRtbSize: () => (/* binding */ sizeTupleToRtbSize),
/* harmony export */   sizeTupleToSizeString: () => (/* binding */ sizeTupleToSizeString),
/* harmony export */   sizesToSizeTuples: () => (/* binding */ sizesToSizeTuples),
/* harmony export */   sortByHighestCpm: () => (/* binding */ sortByHighestCpm),
/* harmony export */   timestamp: () => (/* binding */ timestamp),
/* harmony export */   transformAdServerTargetingObj: () => (/* binding */ transformAdServerTargetingObj),
/* harmony export */   triggerPixel: () => (/* binding */ triggerPixel),
/* harmony export */   uniques: () => (/* binding */ uniques),
/* harmony export */   unsupportedBidderMessage: () => (/* binding */ unsupportedBidderMessage)
/* harmony export */ });
/* unused harmony exports resetWinDimensions, getPrebidInternal, parseGPTSingleSizeArrayToRtbSize, getWindowLocation, canAccessWindowTop, hasConsoleLogger, isA, contains, _map, waitForElementToLoad, createTrackPixelIframeHtml, getValue, isSafeFrameWindow, getSafeframeGeometry, replaceAuctionPrice, replaceClickThrough, getDomLoadingDuration, cleanObj, parseQS, safeJSONEncode, getUnixTimestampFromNow, convertObjectToArray, setOnAny, extractDomainFromHost, triggerNurlWithCpm */
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config.js */ "./src/config.js");
/* harmony import */ var klona_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! klona/json */ "./node_modules/klona/json/index.mjs");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ "./src/constants.js");
/* harmony import */ var _utils_promise_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var dlv_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! dlv/index.js */ "./node_modules/dlv/index.js");








var tStr = 'String';
var tFn = 'Function';
var tNumb = 'Number';
var tObject = 'Object';
var tBoolean = 'Boolean';
var toString = Object.prototype.toString;
let consoleExists = Boolean(window.console);
let consoleLogExists = Boolean(consoleExists && window.console.log);
let consoleInfoExists = Boolean(consoleExists && window.console.info);
let consoleWarnExists = Boolean(consoleExists && window.console.warn);
let consoleErrorExists = Boolean(consoleExists && window.console.error);
let eventEmitter;
let windowDimensions;
const pbjsInstance = (0,_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__.getGlobal)();
function _setEventEmitter(emitFn) {
  // called from events.js - this hoop is to avoid circular imports
  eventEmitter = emitFn;
}
function emitEvent() {
  if (eventEmitter != null) {
    eventEmitter(...arguments);
  }
}
const getWinDimensions = function () {
  let lastCheckTimestamp;
  const CHECK_INTERVAL_MS = 20;
  return () => {
    if (!windowDimensions || !lastCheckTimestamp || Date.now() - lastCheckTimestamp > CHECK_INTERVAL_MS) {
      internal.resetWinDimensions();
      lastCheckTimestamp = Date.now();
    }
    return windowDimensions;
  };
}();
function resetWinDimensions() {
  const top = canAccessWindowTop() ? internal.getWindowTop() : internal.getWindowSelf();
  windowDimensions = {
    screen: {
      width: top.screen?.width,
      height: top.screen?.height,
      availWidth: top.screen?.availWidth,
      availHeight: top.screen?.availHeight,
      colorDepth: top.screen?.colorDepth
    },
    innerHeight: top.innerHeight,
    innerWidth: top.innerWidth,
    outerWidth: top.outerWidth,
    outerHeight: top.outerHeight,
    visualViewport: {
      height: top.visualViewport?.height,
      width: top.visualViewport?.width
    },
    document: {
      documentElement: {
        clientWidth: top.document?.documentElement?.clientWidth,
        clientHeight: top.document?.documentElement?.clientHeight,
        scrollTop: top.document?.documentElement?.scrollTop,
        scrollLeft: top.document?.documentElement?.scrollLeft
      },
      body: {
        scrollTop: document.body?.scrollTop,
        scrollLeft: document.body?.scrollLeft,
        clientWidth: document.body?.clientWidth,
        clientHeight: document.body?.clientHeight
      }
    }
  };
}

// this allows stubbing of utility functions that are used internally by other utility functions
const internal = {
  checkCookieSupport,
  createTrackPixelIframeHtml,
  getWindowSelf,
  getWindowTop,
  canAccessWindowTop,
  getWindowLocation,
  insertUserSyncIframe,
  insertElement,
  isFn,
  triggerPixel,
  logError,
  logWarn,
  logMessage,
  logInfo,
  parseQS,
  formatQS,
  deepEqual,
  resetWinDimensions
};
let prebidInternal = {};
/**
 * Returns object that is used as internal prebid namespace
 */
function getPrebidInternal() {
  return prebidInternal;
}

/* utility method to get incremental integer starting from 1 */
var getIncrementalInteger = function () {
  var count = 0;
  return function () {
    count++;
    return count;
  };
}();

// generate a random string (to be used as a dynamic JSONP callback)
function getUniqueIdentifierStr() {
  return getIncrementalInteger() + Math.random().toString(16).substr(2);
}

/**
 * Returns a random v4 UUID of the form xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx,
 * where each x is replaced with a random hexadecimal digit from 0 to f,
 * and y is replaced with a random hexadecimal digit from 8 to b.
 * https://gist.github.com/jed/982883 via node-uuid
 */
function generateUUID(placeholder) {
  return placeholder ? (placeholder ^ _getRandomData() >> placeholder / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, generateUUID);
}

/**
 * Returns random data using the Crypto API if available and Math.random if not
 * Method is from https://gist.github.com/jed/982883 like generateUUID, direct link https://gist.github.com/jed/982883#gistcomment-45104
 */
function _getRandomData() {
  if (window && window.crypto && window.crypto.getRandomValues) {
    return crypto.getRandomValues(new Uint8Array(1))[0] % 16;
  } else {
    return Math.random() * 16;
  }
}
function getBidIdParameter(key, paramsObj) {
  return paramsObj?.[key] || '';
}

// parse a query string object passed in bid params
// bid params should be an object such as {key: "value", key1 : "value1"}
// aliases to formatQS
function parseQueryStringParameters(queryObj) {
  let result = '';
  for (var k in queryObj) {
    if (queryObj.hasOwnProperty(k)) {
      result += k + '=' + encodeURIComponent(queryObj[k]) + '&';
    }
  }
  result = result.replace(/&$/, '');
  return result;
}

// transform an AdServer targeting bids into a query string to send to the adserver
function transformAdServerTargetingObj(targeting) {
  // we expect to receive targeting for a single slot at a time
  if (targeting && Object.getOwnPropertyNames(targeting).length > 0) {
    return Object.keys(targeting).map(key => `${key}=${encodeURIComponent(targeting[key])}`).join('&');
  } else {
    return '';
  }
}

/**
 * Parse a GPT-Style general size Array like `[[300, 250]]` or `"300x250,970x90"` into an array of width, height tuples `[[300, 250]]` or '[[300,250], [970,90]]'
 */
function sizesToSizeTuples(sizes) {
  if (typeof sizes === 'string') {
    // multiple sizes will be comma-separated
    return sizes.split(/\s*,\s*/).map(sz => sz.match(/^(\d+)x(\d+)$/i)).filter(match => match).map(_ref => {
      let [_, w, h] = _ref;
      return [parseInt(w, 10), parseInt(h, 10)];
    });
  } else if (Array.isArray(sizes)) {
    if (isValidGPTSingleSize(sizes)) {
      return [sizes];
    }
    return sizes.filter(isValidGPTSingleSize);
  }
  return [];
}

/**
 * Parse a GPT-Style general size Array like `[[300, 250]]` or `"300x250,970x90"` into an array of sizes `["300x250"]` or '['300x250', '970x90']'
 * @param  {(Array.<number[]>|Array.<number>)} sizeObj Input array or double array [300,250] or [[300,250], [728,90]]
 * @return {Array.<string>}  Array of strings like `["300x250"]` or `["300x250", "728x90"]`
 */
function parseSizesInput(sizeObj) {
  return sizesToSizeTuples(sizeObj).map(sizeTupleToSizeString);
}
function sizeTupleToSizeString(size) {
  return size[0] + 'x' + size[1];
}

// Parse a GPT style single size array, (i.e [300, 250])
// into an AppNexus style string, (i.e. 300x250)
function parseGPTSingleSizeArray(singleSize) {
  if (isValidGPTSingleSize(singleSize)) {
    return sizeTupleToSizeString(singleSize);
  }
}
function sizeTupleToRtbSize(size) {
  return {
    w: size[0],
    h: size[1]
  };
}

// Parse a GPT style single size array, (i.e [300, 250])
// into OpenRTB-compatible (imp.banner.w/h, imp.banner.format.w/h, imp.video.w/h) object(i.e. {w:300, h:250})
function parseGPTSingleSizeArrayToRtbSize(singleSize) {
  if (isValidGPTSingleSize(singleSize)) {
    return sizeTupleToRtbSize(singleSize);
  }
}
function isValidGPTSingleSize(singleSize) {
  // if we aren't exactly 2 items in this array, it is invalid
  return isArray(singleSize) && singleSize.length === 2 && !isNaN(singleSize[0]) && !isNaN(singleSize[1]);
}
function getWindowTop() {
  return window.top;
}
function getWindowSelf() {
  return window.self;
}
function getWindowLocation() {
  return window.location;
}
function getDocument() {
  return document;
}
function canAccessWindowTop() {
  try {
    if (internal.getWindowTop().location.href) {
      return true;
    }
  } catch (e) {
    return false;
  }
}

/**
 * Wrappers to console.(log | info | warn | error). Takes N arguments, the same as the native methods
 */
function logMessage() {
  if (debugTurnedOn() && consoleLogExists) {
    // eslint-disable-next-line no-console
    console.log.apply(console, decorateLog(arguments, 'MESSAGE:'));
  }
}
function logInfo() {
  if (debugTurnedOn() && consoleInfoExists) {
    // eslint-disable-next-line no-console
    console.info.apply(console, decorateLog(arguments, 'INFO:'));
  }
}
function logWarn() {
  if (debugTurnedOn() && consoleWarnExists) {
    // eslint-disable-next-line no-console
    console.warn.apply(console, decorateLog(arguments, 'WARNING:'));
  }
  emitEvent(_constants_js__WEBPACK_IMPORTED_MODULE_1__.EVENTS.AUCTION_DEBUG, {
    type: 'WARNING',
    arguments: arguments
  });
}
function logError() {
  if (debugTurnedOn() && consoleErrorExists) {
    // eslint-disable-next-line no-console
    console.error.apply(console, decorateLog(arguments, 'ERROR:'));
  }
  emitEvent(_constants_js__WEBPACK_IMPORTED_MODULE_1__.EVENTS.AUCTION_DEBUG, {
    type: 'ERROR',
    arguments: arguments
  });
}
function prefixLog(prefix) {
  function decorate(fn) {
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      fn(prefix, ...args);
    };
  }
  return {
    logError: decorate(logError),
    logWarn: decorate(logWarn),
    logMessage: decorate(logMessage),
    logInfo: decorate(logInfo)
  };
}
function decorateLog(args, prefix) {
  args = [].slice.call(args);
  let bidder = _config_js__WEBPACK_IMPORTED_MODULE_2__.config.getCurrentBidder();
  prefix && args.unshift(prefix);
  if (bidder) {
    args.unshift(label('#aaa'));
  }
  args.unshift(label('#3b88c3'));
  args.unshift('%cPrebid' + (bidder ? `%c${bidder}` : ''));
  return args;
  function label(color) {
    return `display: inline-block; color: #fff; background: ${color}; padding: 1px 4px; border-radius: 3px;`;
  }
}
function hasConsoleLogger() {
  return consoleLogExists;
}
function debugTurnedOn() {
  return !!_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('debug');
}
const createIframe = (() => {
  const DEFAULTS = {
    border: '0px',
    hspace: '0',
    vspace: '0',
    marginWidth: '0',
    marginHeight: '0',
    scrolling: 'no',
    frameBorder: '0',
    allowtransparency: 'true'
  };
  return function (doc, attrs) {
    let style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const f = doc.createElement('iframe');
    Object.assign(f, Object.assign({}, DEFAULTS, attrs));
    Object.assign(f.style, style);
    return f;
  };
})();
function createInvisibleIframe() {
  return createIframe(document, {
    id: getUniqueIdentifierStr(),
    width: 0,
    height: 0,
    src: 'about:blank'
  }, {
    display: 'none',
    height: '0px',
    width: '0px',
    border: '0px'
  });
}

/*
 *   Check if a given parameter name exists in query string
 *   and if it does return the value
 */
function getParameterByName(name) {
  return parseQS(getWindowLocation().search)[name] || '';
}

/**
 * Return if the object is of the
 * given type.
 * @param {*} object to test
 * @param {String} _t type string (e.g., Array)
 * @return {Boolean} if object is of type _t
 */
function isA(object, _t) {
  return toString.call(object) === '[object ' + _t + ']';
}
function isFn(object) {
  return isA(object, tFn);
}
function isStr(object) {
  return isA(object, tStr);
}
const isArray = Array.isArray.bind(Array);
function isNumber(object) {
  return isA(object, tNumb);
}
function isPlainObject(object) {
  return isA(object, tObject);
}
function isBoolean(object) {
  return isA(object, tBoolean);
}

/**
 * Return if the object is "empty";
 * this includes falsey, no keys, or no items at indices
 * @param {*} object object to test
 * @return {Boolean} if object is empty
 */
function isEmpty(object) {
  if (!object) return true;
  if (isArray(object) || isStr(object)) {
    return !(object.length > 0);
  }
  return Object.keys(object).length <= 0;
}

/**
 * Return if string is empty, null, or undefined
 * @param str string to test
 * @returns {boolean} if string is empty
 */
function isEmptyStr(str) {
  return isStr(str) && (!str || str.length === 0);
}

/**
 * Iterate object with the function
 * falls back to es5 `forEach`
 * @param {Array|Object} object
 * @param {Function} fn - The function to execute for each element. It receives three arguments: value, key, and the original object.
 * @returns {void}
 */
function _each(object, fn) {
  if (isFn(object?.forEach)) return object.forEach(fn, this);
  Object.entries(object || {}).forEach(_ref2 => {
    let [k, v] = _ref2;
    return fn.call(this, v, k);
  });
}
function contains(a, obj) {
  return isFn(a?.includes) && a.includes(obj);
}

/**
 * Map an array or object into another array
 * given a function
 * @param {Array|Object} object
 * @param {Function} callback - The function to execute for each element. It receives three arguments: value, key, and the original object.
 * @return {Array}
 */
function _map(object, callback) {
  if (isFn(object?.map)) return object.map(callback);
  return Object.entries(object || {}).map(_ref3 => {
    let [k, v] = _ref3;
    return callback(v, k, object);
  });
}

/*
* Inserts an element(elm) as targets child, by default as first child
* @param {HTMLElement} elm
* @param {HTMLElement} [doc]
* @param {HTMLElement} [target]
* @param {Boolean} [asLastChildChild]
* @return {HTML Element}
*/
function insertElement(elm, doc, target, asLastChildChild) {
  doc = doc || document;
  let parentEl;
  if (target) {
    parentEl = doc.getElementsByTagName(target);
  } else {
    parentEl = doc.getElementsByTagName('head');
  }
  try {
    parentEl = parentEl.length ? parentEl : doc.getElementsByTagName('body');
    if (parentEl.length) {
      parentEl = parentEl[0];
      let insertBeforeEl = asLastChildChild ? null : parentEl.firstChild;
      return parentEl.insertBefore(elm, insertBeforeEl);
    }
  } catch (e) {}
}

/**
 * Returns a promise that completes when the given element triggers a 'load' or 'error' DOM event, or when
 * `timeout` milliseconds have elapsed.
 *
 * @param {HTMLElement} element
 * @param {Number} [timeout]
 * @returns {Promise}
 */
function waitForElementToLoad(element, timeout) {
  let timer = null;
  return new _utils_promise_js__WEBPACK_IMPORTED_MODULE_3__.PbPromise(resolve => {
    const onLoad = function () {
      element.removeEventListener('load', onLoad);
      element.removeEventListener('error', onLoad);
      if (timer != null) {
        window.clearTimeout(timer);
      }
      resolve();
    };
    element.addEventListener('load', onLoad);
    element.addEventListener('error', onLoad);
    if (timeout != null) {
      timer = window.setTimeout(onLoad, timeout);
    }
  });
}

/**
 * Inserts an image pixel with the specified `url` for cookie sync
 * @param {string} url URL string of the image pixel to load
 * @param  {function} [done] an optional exit callback, used when this usersync pixel is added during an async process
 * @param  {Number} [timeout] an optional timeout in milliseconds for the image to load before calling `done`
 */
function triggerPixel(url, done, timeout) {
  const img = new Image();
  if (done && internal.isFn(done)) {
    waitForElementToLoad(img, timeout).then(done);
  }
  img.src = url;
}

/**
 * Inserts an empty iframe with the specified `html`, primarily used for tracking purposes
 * (though could be for other purposes)
 * @param {string} htmlCode snippet of HTML code used for tracking purposes
 */
function insertHtmlIntoIframe(htmlCode) {
  if (!htmlCode) {
    return;
  }
  const iframe = createInvisibleIframe();
  internal.insertElement(iframe, document, 'body');
  (doc => {
    doc.open();
    doc.write(htmlCode);
    doc.close();
  })(iframe.contentWindow.document);
}

/**
 * Inserts empty iframe with the specified `url` for cookie sync
 * @param  {string} url URL to be requested
 * @param  {function} [done] an optional exit callback, used when this usersync pixel is added during an async process
 * @param  {Number} [timeout] an optional timeout in milliseconds for the iframe to load before calling `done`
 */
function insertUserSyncIframe(url, done, timeout) {
  let iframeHtml = internal.createTrackPixelIframeHtml(url, false, 'allow-scripts allow-same-origin');
  let div = document.createElement('div');
  div.innerHTML = iframeHtml;
  let iframe = div.firstChild;
  if (done && internal.isFn(done)) {
    waitForElementToLoad(iframe, timeout).then(done);
  }
  internal.insertElement(iframe, document, 'html', true);
}

/**
 * Creates a snippet of HTML that retrieves the specified `url`
 * @param  {string} url URL to be requested
 * @param encode
 * @return {string}     HTML snippet that contains the img src = set to `url`
 */
function createTrackPixelHtml(url) {
  let encode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : encodeURI;
  if (!url) {
    return '';
  }
  let escapedUrl = encode(url);
  let img = '<div style="position:absolute;left:0px;top:0px;visibility:hidden;">';
  img += '<img src="' + escapedUrl + '"></div>';
  return img;
}
;

/**
 * encodeURI, but preserves macros of the form '${MACRO}' (e.g. '${AUCTION_PRICE}')
 * @param url
 * @return {string}
 */
function encodeMacroURI(url) {
  const macros = Array.from(url.matchAll(/\$({[^}]+})/g)).map(match => match[1]);
  return macros.reduce((str, macro) => {
    return str.replace('$' + encodeURIComponent(macro), '$' + macro);
  }, encodeURI(url));
}

/**
 * Creates a snippet of Iframe HTML that retrieves the specified `url`
 * @param  {string} url plain URL to be requested
 * @param  {string} encodeUri boolean if URL should be encoded before inserted. Defaults to true
 * @param  {string} sandbox string if provided the sandbox attribute will be included with the given value
 * @return {string}     HTML snippet that contains the iframe src = set to `url`
 */
function createTrackPixelIframeHtml(url) {
  let encodeUri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  let sandbox = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  if (!url) {
    return '';
  }
  if (encodeUri) {
    url = encodeURI(url);
  }
  if (sandbox) {
    sandbox = `sandbox="${sandbox}"`;
  }
  return `<iframe ${sandbox} id="${getUniqueIdentifierStr()}"
      frameborder="0"
      allowtransparency="true"
      marginheight="0" marginwidth="0"
      width="0" hspace="0" vspace="0" height="0"
      style="height:0px;width:0px;display:none;"
      scrolling="no"
      src="${url}">
    </iframe>`;
}
function uniques(value, index, arry) {
  return arry.indexOf(value) === index;
}
function flatten(a, b) {
  return a.concat(b);
}
function getBidRequest(id, bidderRequests) {
  if (!id) {
    return;
  }
  return bidderRequests.flatMap(br => br.bids).find(bid => ['bidId', 'adId', 'bid_id'].some(prop => bid[prop] === id));
}
function getValue(obj, key) {
  return obj[key];
}
function getBidderCodes() {
  let adUnits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : pbjsInstance.adUnits;
  // this could memoize adUnits
  return adUnits.map(unit => unit.bids.map(bid => bid.bidder).reduce(flatten, [])).reduce(flatten, []).filter(bidder => typeof bidder !== 'undefined').filter(uniques);
}
function isGptPubadsDefined() {
  if (window.googletag && isFn(window.googletag.pubads) && isFn(window.googletag.pubads().getSlots)) {
    return true;
  }
}
function isApnGetTagDefined() {
  if (window.apntag && isFn(window.apntag.getTag)) {
    return true;
  }
}
const sortByHighestCpm = (a, b) => {
  return b.cpm - a.cpm;
};

/**
 * Fisher–Yates shuffle
 * http://stackoverflow.com/a/6274398
 * https://bost.ocks.org/mike/shuffle/
 * istanbul ignore next
 */
function shuffle(array) {
  let counter = array.length;

  // while there are elements in the array
  while (counter > 0) {
    // pick a random index
    let index = Math.floor(Math.random() * counter);

    // decrease counter by 1
    counter--;

    // and swap the last element with it
    let temp = array[counter];
    array[counter] = array[index];
    array[index] = temp;
  }
  return array;
}
function deepClone(obj) {
  return (0,klona_json__WEBPACK_IMPORTED_MODULE_4__.klona)(obj) || {};
}
function inIframe() {
  try {
    return internal.getWindowSelf() !== internal.getWindowTop();
  } catch (e) {
    return true;
  }
}

/**
 * https://iabtechlab.com/wp-content/uploads/2016/03/SafeFrames_v1.1_final.pdf
 */
function isSafeFrameWindow() {
  if (!inIframe()) {
    return false;
  }
  const ws = internal.getWindowSelf();
  return !!(ws.$sf && ws.$sf.ext);
}

/**
 * Returns the result of calling the function $sf.ext.geom() if it exists
 * @see https://iabtechlab.com/wp-content/uploads/2016/03/SafeFrames_v1.1_final.pdf — 5.4 Function $sf.ext.geom
 * @returns {Object | undefined} geometric information about the container
 */
function getSafeframeGeometry() {
  try {
    const ws = getWindowSelf();
    return typeof ws.$sf.ext.geom === 'function' ? ws.$sf.ext.geom() : undefined;
  } catch (e) {
    logError('Error getting SafeFrame geometry', e);
    return undefined;
  }
}
function isSafariBrowser() {
  return /^((?!chrome|android|crios|fxios).)*safari/i.test(navigator.userAgent);
}
function replaceMacros(str, subs) {
  if (!str) return;
  return Object.entries(subs).reduce((str, _ref4) => {
    let [key, val] = _ref4;
    return str.replace(new RegExp('\\$\\{' + key + '\\}', 'g'), val || '');
  }, str);
}
function replaceAuctionPrice(str, cpm) {
  return replaceMacros(str, {
    AUCTION_PRICE: cpm
  });
}
function replaceClickThrough(str, clicktag) {
  if (!str || !clicktag || typeof clicktag !== 'string') return;
  return str.replace(/\${CLICKTHROUGH}/g, clicktag);
}
function timestamp() {
  return new Date().getTime();
}

/**
 * The returned value represents the time elapsed since the time origin. @see https://developer.mozilla.org/en-US/docs/Web/API/Performance/now
 * @returns {number}
 */
function getPerformanceNow() {
  return window.performance && window.performance.now && window.performance.now() || 0;
}

/**
 * Retuns the difference between `timing.domLoading` and `timing.navigationStart`.
 * This function uses the deprecated `Performance.timing` API and should be removed in future.
 * It has not been updated yet because it is still used in some modules.
 * @deprecated
 * @param {Window} w The window object used to perform the api call. default to window.self
 * @returns {number}
 */
function getDomLoadingDuration(w) {
  let domLoadingDuration = -1;
  w = w || getWindowSelf();
  const performance = w.performance;
  if (w.performance?.timing) {
    if (w.performance.timing.navigationStart > 0) {
      const val = performance.timing.domLoading - performance.timing.navigationStart;
      if (val > 0) {
        domLoadingDuration = val;
      }
    }
  }
  return domLoadingDuration;
}

/**
 * When the deviceAccess flag config option is false, no cookies should be read or set
 * @returns {boolean}
 */
function hasDeviceAccess() {
  return _config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('deviceAccess') !== false;
}

/**
 * @returns {(boolean|undefined)}
 */
function checkCookieSupport() {
  // eslint-disable-next-line no-restricted-properties
  if (window.navigator.cookieEnabled || !!document.cookie.length) {
    return true;
  }
}

/**
 * Given a function, return a function which only executes the original after
 * it's been called numRequiredCalls times.
 *
 * Note that the arguments from the previous calls will *not* be forwarded to the original function.
 * Only the final call's arguments matter.
 *
 * @param {function} func The function which should be executed, once the returned function has been executed
 *   numRequiredCalls times.
 * @param {number} numRequiredCalls The number of times which the returned function needs to be called before
 *   func is.
 */
function delayExecution(func, numRequiredCalls) {
  if (numRequiredCalls < 1) {
    throw new Error(`numRequiredCalls must be a positive number. Got ${numRequiredCalls}`);
  }
  let numCalls = 0;
  return function () {
    numCalls++;
    if (numCalls === numRequiredCalls) {
      func.apply(this, arguments);
    }
  };
}

/**
 * https://stackoverflow.com/a/34890276/428704
 * @param {Array} xs
 * @param {string} key
 * @returns {Object} {${key_value}: ${groupByArray}, key_value: {groupByArray}}
 */
function groupBy(xs, key) {
  return xs.reduce(function (rv, x) {
    (rv[x[key]] = rv[x[key]] || []).push(x);
    return rv;
  }, {});
}

/**
 * Build an object consisting of only defined parameters to avoid creating an
 * object with defined keys and undefined values.
 * @param {Object} object The object to pick defined params out of
 * @param {string[]} params An array of strings representing properties to look for in the object
 * @returns {Object} An object containing all the specified values that are defined
 */
function getDefinedParams(object, params) {
  return params.filter(param => object[param]).reduce((bid, param) => Object.assign(bid, {
    [param]: object[param]
  }), {});
}

/**
 * @typedef {Object} MediaTypes
 * @property {Object} banner banner configuration
 * @property {Object} native native configuration
 * @property {Object} video video configuration
 */

/**
 * Validates an adunit's `mediaTypes` parameter
 * @param {MediaTypes} mediaTypes mediaTypes parameter to validate
 * @return {boolean} If object is valid
 */
function isValidMediaTypes(mediaTypes) {
  const SUPPORTED_MEDIA_TYPES = ['banner', 'native', 'video'];
  const SUPPORTED_STREAM_TYPES = ['instream', 'outstream', 'adpod'];
  const types = Object.keys(mediaTypes);
  if (!types.every(type => SUPPORTED_MEDIA_TYPES.includes(type))) {
    return false;
  }
  if ( true && mediaTypes.video && mediaTypes.video.context) {
    return SUPPORTED_STREAM_TYPES.includes(mediaTypes.video.context);
  }
  return true;
}

/**
 * Returns user configured bidder params from adunit
 * @param {Object} adUnits
 * @param {string} adUnitCode code
 * @param {string} bidder code
 * @return {Array} user configured param for the given bidder adunit configuration
 */
function getUserConfiguredParams(adUnits, adUnitCode, bidder) {
  return adUnits.filter(adUnit => adUnit.code === adUnitCode).flatMap(adUnit => adUnit.bids).filter(bidderData => bidderData.bidder === bidder).map(bidderData => bidderData.params || {});
}

/**
 * Returns Do Not Track state
 */
function getDNT() {
  return navigator.doNotTrack === '1' || window.doNotTrack === '1' || navigator.msDoNotTrack === '1' || navigator.doNotTrack === 'yes';
}
const compareCodeAndSlot = (slot, adUnitCode) => slot.getAdUnitPath() === adUnitCode || slot.getSlotElementId() === adUnitCode;

/**
 * Returns filter function to match adUnitCode in slot
 * @param {Object} slot GoogleTag slot
 * @return {function} filter function
 */
function isAdUnitCodeMatchingSlot(slot) {
  return adUnitCode => compareCodeAndSlot(slot, adUnitCode);
}

/**
 * Constructs warning message for when unsupported bidders are dropped from an adunit
 * @param {Object} adUnit ad unit from which the bidder is being dropped
 * @param {string} bidder bidder code that is not compatible with the adUnit
 * @return {string} warning message to display when condition is met
 */
function unsupportedBidderMessage(adUnit, bidder) {
  const mediaType = Object.keys(adUnit.mediaTypes || {
    'banner': 'banner'
  }).join(', ');
  return `
    ${adUnit.code} is a ${mediaType} ad unit
    containing bidders that don't support ${mediaType}: ${bidder}.
    This bidder won't fetch demand.
  `;
}

/**
 * Checks input is integer or not
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
 * @param {*} value
 */
const isInteger = Number.isInteger.bind(Number);

/**
 * Returns a new object with undefined properties removed from given object
 * @param obj the object to clean
 */
function cleanObj(obj) {
  return Object.fromEntries(Object.entries(obj).filter(_ref5 => {
    let [_, v] = _ref5;
    return typeof v !== 'undefined';
  }));
}

/**
 * Create a new object with selected properties.  Also allows property renaming and transform functions.
 * @param obj the original object
 * @param properties An array of desired properties
 */
function pick(obj, properties) {
  if (typeof obj !== 'object') {
    return {};
  }
  return properties.reduce((newObj, prop, i) => {
    if (typeof prop === 'function') {
      return newObj;
    }
    let newProp = prop;
    let match = prop.match(/^(.+?)\sas\s(.+?)$/i);
    if (match) {
      prop = match[1];
      newProp = match[2];
    }
    let value = obj[prop];
    if (typeof properties[i + 1] === 'function') {
      value = properties[i + 1](value, newObj);
    }
    if (typeof value !== 'undefined') {
      newObj[newProp] = value;
    }
    return newObj;
  }, {});
}
function isArrayOfNums(val, size) {
  return isArray(val) && (size ? val.length === size : true) && val.every(v => isInteger(v));
}
function parseQS(query) {
  return !query ? {} : query.replace(/^\?/, '').split('&').reduce((acc, criteria) => {
    let [k, v] = criteria.split('=');
    if (/\[\]$/.test(k)) {
      k = k.replace('[]', '');
      acc[k] = acc[k] || [];
      acc[k].push(v);
    } else {
      acc[k] = v || '';
    }
    return acc;
  }, {});
}
function formatQS(query) {
  return Object.keys(query).map(k => Array.isArray(query[k]) ? query[k].map(v => `${k}[]=${v}`).join('&') : `${k}=${query[k]}`).join('&');
}
function parseUrl(url, options) {
  let parsed = document.createElement('a');
  if (options && 'noDecodeWholeURL' in options && options.noDecodeWholeURL) {
    parsed.href = url;
  } else {
    parsed.href = decodeURIComponent(url);
  }
  // in window.location 'search' is string, not object
  let qsAsString = options && 'decodeSearchAsString' in options && options.decodeSearchAsString;
  return {
    href: parsed.href,
    protocol: (parsed.protocol || '').replace(/:$/, ''),
    hostname: parsed.hostname,
    port: +parsed.port,
    pathname: parsed.pathname.replace(/^(?!\/)/, '/'),
    search: qsAsString ? parsed.search : internal.parseQS(parsed.search || ''),
    hash: (parsed.hash || '').replace(/^#/, ''),
    host: parsed.host || window.location.host
  };
}
function buildUrl(obj) {
  return (obj.protocol || 'http') + '://' + (obj.host || obj.hostname + (obj.port ? `:${obj.port}` : '')) + (obj.pathname || '') + (obj.search ? `?${internal.formatQS(obj.search || '')}` : '') + (obj.hash ? `#${obj.hash}` : '');
}

/**
 * This function deeply compares two objects checking for their equivalence.
 * @param {Object} obj1
 * @param {Object} obj2
 * @param {Object} [options] - Options for comparison.
 * @param {boolean} [options.checkTypes=false] - If set, two objects with identical properties but different constructors will *not* be considered equivalent.
 * @returns {boolean} - Returns `true` if the objects are equivalent, `false` otherwise.
 */
function deepEqual(obj1, obj2) {
  let {
    checkTypes = false
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // Quick reference check
  if (obj1 === obj2) return true;

  // If either is null or not an object, do a direct equality check
  if (typeof obj1 !== 'object' || obj1 === null || typeof obj2 !== 'object' || obj2 === null) {
    return false;
  }
  // Cache the Array checks
  const isArr1 = Array.isArray(obj1);
  const isArr2 = Array.isArray(obj2);
  // Special case: both are arrays
  if (isArr1 && isArr2) {
    if (obj1.length !== obj2.length) return false;
    for (let i = 0; i < obj1.length; i++) {
      if (!deepEqual(obj1[i], obj2[i], {
        checkTypes
      })) {
        return false;
      }
    }
    return true;
  } else if (isArr1 || isArr2) {
    return false;
  }

  // If we’re checking types, compare constructors (e.g., plain object vs. Date)
  if (checkTypes && obj1.constructor !== obj2.constructor) {
    return false;
  }

  // Compare object keys. Cache keys for both to avoid repeated calls.
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  if (keys1.length !== keys2.length) return false;
  for (const key of keys1) {
    // If `obj2` doesn't have this key or sub-values aren't equal, bail out.
    if (!Object.prototype.hasOwnProperty.call(obj2, key)) {
      return false;
    }
    if (!deepEqual(obj1[key], obj2[key], {
      checkTypes
    })) {
      return false;
    }
  }
  return true;
}
function mergeDeep(target) {
  for (let i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); i++) {
    const source = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];
    if (!isPlainObject(source)) {
      continue;
    }
    mergeDeepHelper(target, source);
  }
  return target;
}
function mergeDeepHelper(target, source) {
  // quick check
  if (!isPlainObject(target) || !isPlainObject(source)) {
    return;
  }
  const keys = Object.keys(source);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (key === '__proto__' || key === 'constructor') {
      continue;
    }
    const val = source[key];
    if (isPlainObject(val)) {
      if (!target[key]) {
        target[key] = {};
      }
      mergeDeepHelper(target[key], val);
    } else if (Array.isArray(val)) {
      if (!Array.isArray(target[key])) {
        target[key] = [...val];
      } else {
        // deduplicate
        val.forEach(obj => {
          if (!target[key].some(item => deepEqual(item, obj))) {
            target[key].push(obj);
          }
        });
      }
    } else {
      // direct assignment
      target[key] = val;
    }
  }
}

/**
 * returns a hash of a string using a fast algorithm
 * source: https://stackoverflow.com/a/52171480/845390
 * @param str
 * @param seed (optional)
 * @returns {string}
 */
function cyrb53Hash(str) {
  let seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // IE doesn't support imul
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul#Polyfill
  let imul = function (opA, opB) {
    if (isFn(Math.imul)) {
      return Math.imul(opA, opB);
    } else {
      opB |= 0; // ensure that opB is an integer. opA will automatically be coerced.
      // floating points give us 53 bits of precision to work with plus 1 sign bit
      // automatically handled for our convienence:
      // 1. 0x003fffff /*opA & 0x000fffff*/ * 0x7fffffff /*opB*/ = 0x1fffff7fc00001
      //    0x1fffff7fc00001 < Number.MAX_SAFE_INTEGER /*0x1fffffffffffff*/
      var result = (opA & 0x003fffff) * opB;
      // 2. We can remove an integer coersion from the statement above because:
      //    0x1fffff7fc00001 + 0xffc00000 = 0x1fffffff800001
      //    0x1fffffff800001 < Number.MAX_SAFE_INTEGER /*0x1fffffffffffff*/
      if (opA & 0xffc00000) result += (opA & 0xffc00000) * opB | 0;
      return result | 0;
    }
  };
  let h1 = 0xdeadbeef ^ seed;
  let h2 = 0x41c6ce57 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h1 = imul(h1 ^ ch, 2654435761);
    h2 = imul(h2 ^ ch, 1597334677);
  }
  h1 = imul(h1 ^ h1 >>> 16, 2246822507) ^ imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = imul(h2 ^ h2 >>> 16, 2246822507) ^ imul(h1 ^ h1 >>> 13, 3266489909);
  return (4294967296 * (2097151 & h2) + (h1 >>> 0)).toString();
}

/**
 * returns the result of `JSON.parse(data)`, or undefined if that throws an error.
 * @param data
 * @returns {any}
 */
function safeJSONParse(data) {
  try {
    return JSON.parse(data);
  } catch (e) {}
}
function safeJSONEncode(data) {
  try {
    return JSON.stringify(data);
  } catch (e) {
    return '';
  }
}

/**
 * Returns a memoized version of `fn`.
 *
 * @param fn
 * @param key cache key generator, invoked with the same arguments passed to `fn`.
 *        By default, the first argument is used as key.
 * @return {function(): any}
 */
function memoize(fn) {
  let key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (arg) {
    return arg;
  };
  const cache = new Map();
  const memoized = function () {
    const cacheKey = key.apply(this, arguments);
    if (!cache.has(cacheKey)) {
      cache.set(cacheKey, fn.apply(this, arguments));
    }
    return cache.get(cacheKey);
  };
  memoized.clear = cache.clear.bind(cache);
  return memoized;
}

/**
 * Returns a Unix timestamp for given time value and unit.
 * @param {number} timeValue numeric value, defaults to 0 (which means now)
 * @param {string} timeUnit defaults to days (or 'd'), use 'm' for minutes. Any parameter that isn't 'd' or 'm' will return Date.now().
 * @returns {number}
 */
function getUnixTimestampFromNow() {
  let timeValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  let timeUnit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'd';
  const acceptableUnits = ['m', 'd'];
  if (acceptableUnits.indexOf(timeUnit) < 0) {
    return Date.now();
  }
  const multiplication = timeValue / (timeUnit === 'm' ? 1440 : 1);
  return Date.now() + (timeValue && timeValue > 0 ? 1000 * 60 * 60 * 24 * multiplication : 0);
}

/**
 * Converts given object into an array, so {key: 1, anotherKey: 'fred', third: ['fred']} is turned
 * into [{key: 1}, {anotherKey: 'fred'}, {third: ['fred']}]
 * @param {Object} obj the object
 * @returns {Array}
 */
function convertObjectToArray(obj) {
  return Object.keys(obj).map(key => {
    return {
      [key]: obj[key]
    };
  });
}

/**
 * Sets dataset attributes on a script
 * @param {HTMLScriptElement} script
 * @param {object} attributes
 */
function setScriptAttributes(script, attributes) {
  Object.entries(attributes).forEach(_ref6 => {
    let [k, v] = _ref6;
    return script.setAttribute(k, v);
  });
}

/**
 * Perform a binary search for `el` on an ordered array `arr`.
 *
 * @returns the lowest nonnegative integer I that satisfies:
 *   key(arr[i]) >= key(el) for each i between I and arr.length
 *
 *   (if one or more matches are found for `el`, returns the index of the first;
 *   if the element is not found, return the index of the first element that's greater;
 *   if no greater element exists, return `arr.length`)
 */
function binarySearch(arr, el) {
  let key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : el => el;
  let left = 0;
  let right = arr.length && arr.length - 1;
  const target = key(el);
  while (right - left > 1) {
    const middle = left + Math.round((right - left) / 2);
    if (target > key(arr[middle])) {
      left = middle;
    } else {
      right = middle;
    }
  }
  while (arr.length > left && target > key(arr[left])) {
    left++;
  }
  return left;
}

/**
 * Checks if an object has non-serializable properties.
 * Non-serializable properties are functions and RegExp objects.
 *
 * @param {Object} obj - The object to check.
 * @param {Set} checkedObjects - A set of properties that have already been checked.
 * @returns {boolean} - Returns true if the object has non-serializable properties, false otherwise.
 */
function hasNonSerializableProperty(obj) {
  let checkedObjects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
  for (const key in obj) {
    const value = obj[key];
    const type = typeof value;
    if (value === undefined || type === 'function' || type === 'symbol' || value instanceof RegExp || value instanceof Map || value instanceof Set || value instanceof Date || value !== null && type === 'object' && value.hasOwnProperty('toJSON')) {
      return true;
    }
    if (value !== null && type === 'object' && value.constructor === Object) {
      if (checkedObjects.has(value)) {
        // circular reference, means we have a non-serializable property
        return true;
      }
      checkedObjects.add(value);
      if (hasNonSerializableProperty(value, checkedObjects)) {
        return true;
      }
    }
  }
  return false;
}

/**
 * Returns the value of a nested property in an array of objects.
 *
 * @param {Array} collection - Array of objects.
 * @param {String} key - Key of nested property.
 * @returns {any|undefined} - Value of nested property.
 */
function setOnAny(collection, key) {
  for (let i = 0, result; i < collection.length; i++) {
    result = (0,dlv_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])(collection[i], key);
    if (result) {
      return result;
    }
  }
  return undefined;
}
function extractDomainFromHost(pageHost) {
  let domain = null;
  try {
    let domains = /[-\w]+\.([-\w]+|[-\w]{3,}|[-\w]{1,3}\.[-\w]{2})$/i.exec(pageHost);
    if (domains != null && domains.length > 0) {
      domain = domains[0];
      for (let i = 1; i < domains.length; i++) {
        if (domains[i].length > domain.length) {
          domain = domains[i];
        }
      }
    }
  } catch (e) {
    domain = null;
  }
  return domain;
}
function triggerNurlWithCpm(bid, cpm) {
  if (isStr(bid.nurl) && bid.nurl !== '') {
    bid.nurl = bid.nurl.replace(/\${AUCTION_PRICE}/, cpm);
    triggerPixel(bid.nurl);
  }
}

// To ensure that isGzipCompressionSupported() doesn’t become an overhead, we have used memoization to cache the result after the first execution.
// This way, even if the function is called multiple times, it will only perform the actual check once and return the cached result in subsequent calls.
const isGzipCompressionSupported = function () {
  let cachedResult; // Store the result

  return function () {
    if (cachedResult !== undefined) {
      return cachedResult; // Return cached result if already computed
    }
    try {
      if (typeof window.CompressionStream === 'undefined') {
        cachedResult = false;
      } else {
        (() => new window.CompressionStream('gzip'))();
        cachedResult = true;
      }
    } catch (error) {
      cachedResult = false;
    }
    return cachedResult;
  };
}();

// Make sure to use isGzipCompressionSupported before calling this function
async function compressDataWithGZip(data) {
  if (typeof data !== 'string') {
    // TextEncoder (below) expects a string
    data = JSON.stringify(data);
  }
  const encoder = new TextEncoder();
  const encodedData = encoder.encode(data);
  const compressedStream = new Blob([encodedData]).stream().pipeThrough(new window.CompressionStream('gzip'));
  const compressedBlob = await new Response(compressedStream).blob();
  const compressedArrayBuffer = await compressedBlob.arrayBuffer();
  return new Uint8Array(compressedArrayBuffer);
}

/***/ }),

/***/ "./src/utils/cpm.js":
/*!**************************!*\
  !*** ./src/utils/cpm.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   adjustCpm: () => (/* binding */ adjustCpm)
/* harmony export */ });
/* harmony import */ var _auctionManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../auctionManager.js */ "./src/auctionManager.js");
/* harmony import */ var _bidderSettings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bidderSettings.js */ "./src/bidderSettings.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ "./src/utils.js");



function adjustCpm(cpm, bidResponse, bidRequest) {
  let {
    index = _auctionManager_js__WEBPACK_IMPORTED_MODULE_0__.auctionManager.index,
    bs = _bidderSettings_js__WEBPACK_IMPORTED_MODULE_1__.bidderSettings
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  bidRequest = bidRequest || index.getBidRequest(bidResponse);
  const adapterCode = bidResponse?.adapterCode;
  const bidderCode = bidResponse?.bidderCode || bidRequest?.bidder;
  const adjustAlternateBids = bs.get(bidResponse?.adapterCode, 'adjustAlternateBids');
  const bidCpmAdjustment = bs.getOwn(bidderCode, 'bidCpmAdjustment') || bs.get(adjustAlternateBids ? adapterCode : bidderCode, 'bidCpmAdjustment');
  if (bidCpmAdjustment && typeof bidCpmAdjustment === 'function') {
    try {
      return bidCpmAdjustment(cpm, Object.assign({}, bidResponse), bidRequest);
    } catch (e) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)('Error during bid adjustment', e);
    }
  }
  return cpm;
}

/***/ }),

/***/ "./src/utils/focusTimeout.js":
/*!***********************************!*\
  !*** ./src/utils/focusTimeout.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setFocusTimeout: () => (/* binding */ setFocusTimeout)
/* harmony export */ });
/* unused harmony export reset */
let outOfFocusStart = null; // enforce null otherwise it could be undefined and the callback wouldn't execute
let timeOutOfFocus = 0;
let suspendedTimeouts = [];
function trackTimeOutOfFocus() {
  if (document.hidden) {
    outOfFocusStart = Date.now();
  } else {
    timeOutOfFocus += Date.now() - (outOfFocusStart ?? 0); // when the page is loaded in hidden state outOfFocusStart is undefined, which results in timeoutOffset being NaN
    outOfFocusStart = null;
    suspendedTimeouts.forEach(_ref => {
      let {
        callback,
        startTime,
        setTimerId
      } = _ref;
      return setTimerId(setFocusTimeout(callback, timeOutOfFocus - startTime)());
    });
    suspendedTimeouts = [];
  }
}
document.addEventListener('visibilitychange', trackTimeOutOfFocus);
function reset() {
  outOfFocusStart = null;
  timeOutOfFocus = 0;
  suspendedTimeouts = [];
  document.removeEventListener('visibilitychange', trackTimeOutOfFocus);
  document.addEventListener('visibilitychange', trackTimeOutOfFocus);
}

/**
 * Wraps native setTimeout function in order to count time only when page is focused
 *
 * @param {function(): void} [callback] - A function that will be invoked after the passed time
 * @param {number} [milliseconds] - Minimum duration (in milliseconds) that the callback will be executed after
 * @returns {function(): number} - Getter function for current timer id
 */
function setFocusTimeout(callback, milliseconds) {
  const startTime = timeOutOfFocus;
  let timerId = setTimeout(() => {
    if (timeOutOfFocus === startTime && outOfFocusStart == null) {
      callback();
    } else if (outOfFocusStart != null) {
      // case when timeout ended during page is out of focus
      suspendedTimeouts.push({
        callback,
        startTime,
        setTimerId(newId) {
          timerId = newId;
        }
      });
    } else {
      timerId = setFocusTimeout(callback, timeOutOfFocus - startTime)();
    }
  }, milliseconds);
  return () => timerId;
}

/***/ }),

/***/ "./src/utils/gdpr.js":
/*!***************************!*\
  !*** ./src/utils/gdpr.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hasPurpose1Consent: () => (/* binding */ hasPurpose1Consent)
/* harmony export */ });
/**
 * Check if GDPR purpose 1 consent was given.
 *
 * @param gdprConsent GDPR consent data
 * @returns {boolean} true if the gdprConsent is null-y; or GDPR does not apply; or if purpose 1 consent was given.
 */
function hasPurpose1Consent(gdprConsent) {
  if (gdprConsent?.gdprApplies) {
    return gdprConsent?.vendorData?.purpose?.consents?.[1] === true;
  }
  return true;
}

/***/ }),

/***/ "./src/utils/ipUtils.js":
/*!******************************!*\
  !*** ./src/utils/ipUtils.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   scrubIPv4: () => (/* binding */ scrubIPv4),
/* harmony export */   scrubIPv6: () => (/* binding */ scrubIPv6)
/* harmony export */ });
function scrubIPv4(ip) {
  if (!ip) {
    return null;
  }
  const ones = 24;
  let ipParts = ip.split('.').map(Number);
  if (ipParts.length != 4) {
    return null;
  }
  let mask = [];
  for (let i = 0; i < 4; i++) {
    let n = Math.max(0, Math.min(8, ones - i * 8));
    mask.push(0xff << 8 - n & 0xff);
  }
  let maskedIP = ipParts.map((part, i) => part & mask[i]);
  return maskedIP.join('.');
}
function scrubIPv6(ip) {
  if (!ip) {
    return null;
  }
  const ones = 64;
  let ipParts = ip.split(':').map(part => parseInt(part, 16));
  ipParts = ipParts.map(part => isNaN(part) ? 0 : part);
  while (ipParts.length < 8) {
    ipParts.push(0);
  }
  if (ipParts.length != 8) {
    return null;
  }
  let mask = [];
  for (let i = 0; i < 8; i++) {
    let n = Math.max(0, Math.min(16, ones - i * 16));
    mask.push(0xffff << 16 - n & 0xffff);
  }
  let maskedIP = ipParts.map((part, i) => part & mask[i]);
  return maskedIP.map(part => part.toString(16)).join(':');
}

/***/ }),

/***/ "./src/utils/perfMetrics.js":
/*!**********************************!*\
  !*** ./src/utils/perfMetrics.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   newMetrics: () => (/* binding */ newMetrics),
/* harmony export */   timedAuctionHook: () => (/* binding */ timedAuctionHook),
/* harmony export */   timedBidResponseHook: () => (/* binding */ timedBidResponseHook),
/* harmony export */   useMetrics: () => (/* binding */ useMetrics)
/* harmony export */ });
/* unused harmony exports CONFIG_TOGGLE, metricsFactory, hookTimer */
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config.js */ "./src/config.js");

const CONFIG_TOGGLE = 'performanceMetrics';
const getTime = window.performance && window.performance.now ? () => window.performance.now() : () => Date.now();
const NODES = new WeakMap();
function metricsFactory() {
  let {
    now = getTime,
    mkNode = makeNode,
    mkTimer = makeTimer,
    mkRenamer = rename => rename,
    nodes = NODES
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function newMetrics() {
    function makeMetrics(self) {
      let rename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : n => ({
        forEach(fn) {
          fn(n);
        }
      });
      rename = mkRenamer(rename);
      function accessor(slot) {
        return function (name) {
          return self.dfWalk({
            visit(edge, node) {
              const obj = node[slot];
              if (obj.hasOwnProperty(name)) {
                return obj[name];
              }
            }
          });
        };
      }
      const getTimestamp = accessor('timestamps');

      /**
       * Register a metric.
       *
       * @param name metric name
       * @param value metric valiue
       */
      function setMetric(name, value) {
        const names = rename(name);
        self.dfWalk({
          follow(inEdge, outEdge) {
            return outEdge.propagate && (!inEdge || !inEdge.stopPropagation);
          },
          visit(edge, node) {
            names.forEach(name => {
              if (edge == null) {
                node.metrics[name] = value;
              } else {
                if (!node.groups.hasOwnProperty(name)) {
                  node.groups[name] = [];
                }
                node.groups[name].push(value);
              }
            });
          }
        });
      }

      /**
       * Mark the current time as a checkpoint with the given name, to be referenced later
       * by `timeSince` or `timeBetween`.
       *
       * @param name checkpoint name
       */
      function checkpoint(name) {
        self.timestamps[name] = now();
      }

      /**
       * Get the tame passed since `checkpoint`, and optionally save it as a metric.
       *
       * @param {string} checkpoint checkpoint name
       * @param {string} [metric] - The name of the metric to save. Optional.
       * @returns {number|null} - The time in milliseconds between now and the checkpoint, or `null` if the checkpoint is not found.
       */
      function timeSince(checkpoint, metric) {
        const ts = getTimestamp(checkpoint);
        const elapsed = ts != null ? now() - ts : null;
        if (metric != null) {
          setMetric(metric, elapsed);
        }
        return elapsed;
      }

      /**
       * Get the time passed between `startCheckpoint` and `endCheckpoint`, optionally saving it as a metric.
       *
       * @param {string} startCheckpoint - The name of the starting checkpoint.
       * @param {string} endCheckpoint - The name of the ending checkpoint.
       * @param {string} [metric] - The name of the metric to save. Optional.
       * @returns {number|null} - The time in milliseconds between `startCheckpoint` and `endCheckpoint`, or `null` if either checkpoint is not found.
       */
      function timeBetween(startCheckpoint, endCheckpoint, metric) {
        const start = getTimestamp(startCheckpoint);
        const end = getTimestamp(endCheckpoint);
        const elapsed = start != null && end != null ? end - start : null;
        if (metric != null) {
          setMetric(metric, elapsed);
        }
        return elapsed;
      }

      /**
       * A function that, when called, stops a time measure and saves it as a metric.
       *
       * @typedef {function(): void} MetricsTimer
       * @template {function} F
       * @property {function(F): F} stopBefore returns a wrapper around the given function that begins by
       *   stopping this time measure.
       * @property {function(F): F} stopAfter returns a wrapper around the given function that ends by
       *   stopping this time measure.
       */

      /**
       * Start measuring a time metric with the given name.
       *
       * @param name metric name
       * @return {MetricsTimer}
       */
      function startTiming(name) {
        return mkTimer(now, val => setMetric(name, val));
      }

      /**
       * Run fn and measure the time spent in it.
       *
       * @template T
       * @param name the name to use for the measured time metric
       * @param {function(): T} fn
       * @return {T} the return value of `fn`
       */
      function measureTime(name, fn) {
        return startTiming(name).stopAfter(fn)();
      }

      /**
       * @typedef {Function} HookFn
       * @property {(function(T): void)} bail
       *
       * @template T
       * @typedef {HookFn} TimedHookFn
       * @property {(function(): void)} stopTiming
       * @property {T} untimed
       */

      /**
       * Convenience method for measuring time spent in a `.before` or `.after` hook.
       *
       * @template T
       * @param {string} name - The metric name.
       * @param {HookFn} next - The hook's `next` (first) argument.
       * @param {function(TimedHookFn): T} fn - A function that will be run immediately; it takes `next`,
       *    where both `next` and `next.bail` automatically
       *    call `stopTiming` before continuing with the original hook.
       * @return {T} - The return value of `fn`.
       */
      function measureHookTime(name, next, fn) {
        const stopTiming = startTiming(name);
        return fn(function (orig) {
          const next = stopTiming.stopBefore(orig);
          next.bail = orig.bail && stopTiming.stopBefore(orig.bail);
          next.stopTiming = stopTiming;
          next.untimed = orig;
          return next;
        }(next));
      }

      /**
       * Get all registered metrics.
       * @return {{}}
       */
      function getMetrics() {
        let result = {};
        self.dfWalk({
          visit(edge, node) {
            result = Object.assign({}, !edge || edge.includeGroups ? node.groups : null, node.metrics, result);
          }
        });
        return result;
      }

      /**
       * Create and return a new metrics object that starts as a view on all metrics registered here,
       * and - by default - also propagates all new metrics here.
       *
       * Propagated metrics are grouped together, and intended for repeated operations. For example, with the following:
       *
       * ```
       * const metrics = newMetrics();
       * const requests = metrics.measureTime('buildRequests', buildRequests)
       * requests.forEach((req) => {
       *   const requestMetrics = metrics.fork();
       *   requestMetrics.measureTime('processRequest', () => processRequest(req);
       * })
       * ```
       *
       * if `buildRequests` takes 10ms and returns 3 objects, which respectively take 100, 200, and 300ms in `processRequest`, then
       * the final `metrics.getMetrics()` would be:
       *
       * ```
       * {
       *    buildRequests: 10,
       *    processRequest: [100, 200, 300]
       * }
       * ```
       *
       * while the inner `requestMetrics.getMetrics()` would be:
       *
       * ```
       * {
       *   buildRequests: 10,
       *   processRequest: 100 // or 200 for the 2nd loop, etc
       * }
       * ```
       *
       *
       * @param {Object} [options={}] - Options for forking the metrics.
       * @param {boolean} [options.propagate=true] - If false, the forked metrics will not be propagated here.
       * @param {boolean} [options.stopPropagation=false] - If true, propagation from the new metrics is stopped here, instead of
       *   continuing up the chain (if for example these metrics were themselves created through `.fork()`).
       * @param {boolean} [options.includeGroups=false] - If true, the forked metrics will also replicate metrics that were propagated
       *   here from elsewhere. For example:
       *   ```
       *   const metrics = newMetrics();
       *   const op1 = metrics.fork();
       *   const withoutGroups = metrics.fork();
       *   const withGroups = metrics.fork({includeGroups: true});
       *   op1.setMetric('foo', 'bar');
       *   withoutGroups.getMetrics() // {}
       *   withGroups.getMetrics() // {foo: ['bar']}
       *   ```
       * @returns {Object} - The new metrics object.
       */
      function fork() {
        let {
          propagate = true,
          stopPropagation = false,
          includeGroups = false
        } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return makeMetrics(mkNode([[self, {
          propagate,
          stopPropagation,
          includeGroups
        }]]), rename);
      }

      /**
       * Join `otherMetrics` with these; all metrics from `otherMetrics` will (by default) be propagated here,
       * and all metrics from here will be included in `otherMetrics`.
       *
       * `propagate`, `stopPropagation` and `includeGroups` have the same semantics as in `.fork()`.
       */
      function join(otherMetrics) {
        let {
          propagate = true,
          stopPropagation = false,
          includeGroups = false
        } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const other = nodes.get(otherMetrics);
        if (other != null) {
          other.addParent(self, {
            propagate,
            stopPropagation,
            includeGroups
          });
        }
      }

      /**
       * return a version of these metrics where all new metrics are renamed according to `renameFn`.
       *
       * @param {function(String): Array[String]} renameFn
       */
      function renameWith(renameFn) {
        return makeMetrics(self, renameFn);
      }

      /**
       * Create a new metrics object that uses the same propagation and renaming rules as this one.
       */
      function newMetrics() {
        return makeMetrics(self.newSibling(), rename);
      }
      const metrics = {
        startTiming,
        measureTime,
        measureHookTime,
        checkpoint,
        timeSince,
        timeBetween,
        setMetric,
        getMetrics,
        fork,
        join,
        newMetrics,
        renameWith,
        toJSON() {
          return getMetrics();
        }
      };
      nodes.set(metrics, self);
      return metrics;
    }
    return makeMetrics(mkNode([]));
  };
}
function wrapFn(fn, before, after) {
  return function () {
    before && before();
    try {
      return fn.apply(this, arguments);
    } finally {
      after && after();
    }
  };
}
function makeTimer(now, cb) {
  const start = now();
  let done = false;
  function stopTiming() {
    if (!done) {
      cb(now() - start);
      done = true;
    }
  }
  stopTiming.stopBefore = fn => wrapFn(fn, stopTiming);
  stopTiming.stopAfter = fn => wrapFn(fn, null, stopTiming);
  return stopTiming;
}
function makeNode(parents) {
  return {
    metrics: {},
    timestamps: {},
    groups: {},
    addParent(node, edge) {
      parents.push([node, edge]);
    },
    newSibling() {
      return makeNode(parents.slice());
    },
    dfWalk() {
      let {
        visit,
        follow = () => true,
        visited = new Set(),
        inEdge
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let res;
      if (!visited.has(this)) {
        visited.add(this);
        res = visit(inEdge, this);
        if (res != null) return res;
        for (const [parent, outEdge] of parents) {
          if (follow(inEdge, outEdge)) {
            res = parent.dfWalk({
              visit,
              follow,
              visited,
              inEdge: outEdge
            });
            if (res != null) return res;
          }
        }
      }
    }
  };
}
const nullMetrics = (() => {
  const nop = function () {};
  const empty = () => ({});
  const none = {
    forEach: nop
  };
  const nullTimer = () => null;
  nullTimer.stopBefore = fn => fn;
  nullTimer.stopAfter = fn => fn;
  const nullNode = Object.defineProperties({
    dfWalk: nop,
    newSibling: () => nullNode,
    addParent: nop
  }, Object.fromEntries(['metrics', 'timestamps', 'groups'].map(prop => [prop, {
    get: empty
  }])));
  return metricsFactory({
    now: () => 0,
    mkNode: () => nullNode,
    mkRenamer: () => () => none,
    mkTimer: () => nullTimer,
    nodes: {
      get: nop,
      set: nop
    }
  })();
})();
let enabled = true;
_config_js__WEBPACK_IMPORTED_MODULE_0__.config.getConfig(CONFIG_TOGGLE, cfg => {
  enabled = !!cfg[CONFIG_TOGGLE];
});

/**
 * convenience fallback function for metrics that may be undefined, especially during tests.
 */
function useMetrics(metrics) {
  return enabled && metrics || nullMetrics;
}
const newMetrics = (() => {
  const makeMetrics = metricsFactory();
  return function () {
    return enabled ? makeMetrics() : nullMetrics;
  };
})();
function hookTimer(prefix, getMetrics) {
  return function (name, hookFn) {
    return function (next) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      const that = this;
      return useMetrics(getMetrics.apply(that, args)).measureHookTime(prefix + name, next, function (next) {
        return hookFn.call(that, next, ...args);
      });
    };
  };
}
const timedAuctionHook = hookTimer('requestBids.', req => req.metrics);
const timedBidResponseHook = hookTimer('addBidResponse.', (_, bid) => bid.metrics);

/***/ }),

/***/ "./src/utils/prerendering.js":
/*!***********************************!*\
  !*** ./src/utils/prerendering.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   delayIfPrerendering: () => (/* binding */ delayIfPrerendering)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./src/utils.js");


/**
 * Returns a wrapper around fn that delays execution until the page if activated, if it was prerendered and isDelayEnabled returns true.
 * https://developer.chrome.com/docs/web-platform/prerender-pages
 */
function delayIfPrerendering(isDelayEnabled, fn) {
  return function () {
    if (document.prerendering && isDelayEnabled()) {
      const that = this;
      const args = Array.from(arguments);
      return new Promise(resolve => {
        document.addEventListener('prerenderingchange', () => {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logInfo)(`Auctions were suspended while page was prerendering`);
          resolve(fn.apply(that, args));
        }, {
          once: true
        });
      });
    } else {
      return Promise.resolve(fn.apply(this, arguments));
    }
  };
}

/***/ }),

/***/ "./src/utils/promise.js":
/*!******************************!*\
  !*** ./src/utils/promise.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PbPromise: () => (/* binding */ PbPromise),
/* harmony export */   defer: () => (/* binding */ defer),
/* harmony export */   delay: () => (/* binding */ delay)
/* harmony export */ });
/* unused harmony export pbSetTimeout */
/* harmony import */ var _libraries_greedy_greedyPromise_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../libraries/greedy/greedyPromise.js */ "./libraries/greedy/greedyPromise.js");
/* harmony import */ var _prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../prebidGlobal.js */ "./src/prebidGlobal.js");


const pbSetTimeout = (0,_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__.getGlobal)().setTimeout ?? ( true ? _libraries_greedy_greedyPromise_js__WEBPACK_IMPORTED_MODULE_1__.greedySetTimeout : 0);
const PbPromise = (0,_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__.getGlobal)().Promise ?? ( true ? _libraries_greedy_greedyPromise_js__WEBPACK_IMPORTED_MODULE_1__.GreedyPromise : 0);
function delay() {
  let delayMs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return new PbPromise(resolve => {
    pbSetTimeout(resolve, delayMs);
  });
}

/**
 * @returns a {promise, resolve, reject} trio where `promise` is resolved by calling `resolve` or `reject`.
 */
function defer() {
  let {
    promiseFactory = resolver => new PbPromise(resolver)
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  function invoker(delegate) {
    return val => delegate(val);
  }
  let resolveFn, rejectFn;
  return {
    promise: promiseFactory((resolve, reject) => {
      resolveFn = resolve;
      rejectFn = reject;
    }),
    resolve: invoker(resolveFn),
    reject: invoker(rejectFn)
  };
}

/***/ }),

/***/ "./src/utils/reducers.js":
/*!*******************************!*\
  !*** ./src/utils/reducers.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getHighestCpm: () => (/* binding */ getHighestCpm),
/* harmony export */   getOldestHighestCpmBid: () => (/* binding */ getOldestHighestCpmBid),
/* harmony export */   keyCompare: () => (/* binding */ keyCompare),
/* harmony export */   maximum: () => (/* binding */ maximum),
/* harmony export */   minimum: () => (/* binding */ minimum)
/* harmony export */ });
/* unused harmony exports simpleCompare, reverseCompare, tiebreakCompare, getLatestHighestCpmBid */
function simpleCompare(a, b) {
  if (a === b) return 0;
  return a < b ? -1 : 1;
}
function keyCompare() {
  let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : item => item;
  return (a, b) => simpleCompare(key(a), key(b));
}
function reverseCompare() {
  let compare = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : simpleCompare;
  return (a, b) => -compare(a, b) || 0;
}
function tiebreakCompare() {
  for (var _len = arguments.length, compares = new Array(_len), _key = 0; _key < _len; _key++) {
    compares[_key] = arguments[_key];
  }
  return function (a, b) {
    for (const cmp of compares) {
      const val = cmp(a, b);
      if (val !== 0) return val;
    }
    return 0;
  };
}
function minimum() {
  let compare = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : simpleCompare;
  return (min, item) => compare(item, min) < 0 ? item : min;
}
function maximum() {
  let compare = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : simpleCompare;
  return minimum(reverseCompare(compare));
}
const cpmCompare = keyCompare(bid => bid.cpm);
const timestampCompare = keyCompare(bid => bid.responseTimestamp);

// This function will get highest cpm value bid, in case of tie it will return the bid with lowest timeToRespond
const getHighestCpm = maximum(tiebreakCompare(cpmCompare, reverseCompare(keyCompare(bid => bid.timeToRespond))));

// This function will get the oldest hightest cpm value bid, in case of tie it will return the bid which came in first
// Use case for tie: https://github.com/prebid/Prebid.js/issues/2448
const getOldestHighestCpmBid = maximum(tiebreakCompare(cpmCompare, reverseCompare(timestampCompare)));

// This function will get the latest hightest cpm value bid, in case of tie it will return the bid which came in last
// Use case for tie: https://github.com/prebid/Prebid.js/issues/2539
const getLatestHighestCpmBid = maximum(tiebreakCompare(cpmCompare, timestampCompare));

/***/ }),

/***/ "./src/utils/ttlCollection.js":
/*!************************************!*\
  !*** ./src/utils/ttlCollection.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ttlCollection: () => (/* binding */ ttlCollection)
/* harmony export */ });
/* harmony import */ var _promise_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./promise.js */ "./src/utils/promise.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./src/utils.js");
/* harmony import */ var _focusTimeout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./focusTimeout.js */ "./src/utils/focusTimeout.js");




/**
 * Create a set-like collection that automatically forgets items after a certain time.
 *
 * @param {Object} [options={}] - Optional settings
 * @param {function(*): (number|Promise<number>)} [options.startTime=timestamp] - A function taking an item added to this collection,
 *   and returning (a promise to) a timestamp to be used as the starting time for the item
 *   (the item will be dropped after `ttl(item)` milliseconds have elapsed since this timestamp).
 *   Defaults to the time the item was added to the collection.
 * @param {function(*): (number|void|Promise<number|void>)} [options.ttl=() => null] - A function taking an item added to this collection,
 *   and returning (a promise to) the duration (in milliseconds) the item should be kept in it.
 *   May return null to indicate that the item should be persisted indefinitely.
 * @param {boolean} [options.monotonic=false] - Set to true for better performance, but only if, given any two items A and B in this collection:
 *   if A was added before B, then:
 *     - startTime(A) + ttl(A) <= startTime(B) + ttl(B)
 *     - Promise.all([startTime(A), ttl(A)]) never resolves later than Promise.all([startTime(B), ttl(B)])
 * @param {number} [options.slack=5000] - Maximum duration (in milliseconds) that an item is allowed to persist
 *   once past its TTL. This is also roughly the interval between "garbage collection" sweeps.
 * @returns {Object} A set-like collection with automatic TTL expiration.
 * @returns {function(*): void} return.add - Add an item to the collection.
 * @returns {function(): void} return.clear - Clear the collection.
 * @returns {function(): Array<*>} return.toArray - Get all the items in the collection, in insertion order.
 * @returns {function(): void} return.refresh - Refresh the TTL for each item in the collection.
 * @returns {(function(function(*): void): function(): void)} return.onExpiry - Register a callback to be run when an item has expired and is about to be
 *   removed from the collection. Returns an un-registration function
 */
function ttlCollection() {
  let {
    startTime = _utils_js__WEBPACK_IMPORTED_MODULE_0__.timestamp,
    ttl = () => null,
    monotonic = false,
    slack = 5000
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const items = new Map();
  const callbacks = [];
  const pendingPurge = [];
  const markForPurge = monotonic ? entry => pendingPurge.push(entry) : entry => pendingPurge.splice((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.binarySearch)(pendingPurge, entry, el => el.expiry), 0, entry);
  let nextPurge, task;
  function reschedulePurge() {
    task && clearTimeout(task);
    if (pendingPurge.length > 0) {
      const now = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.timestamp)();
      nextPurge = Math.max(now, pendingPurge[0].expiry + slack);
      task = (0,_focusTimeout_js__WEBPACK_IMPORTED_MODULE_1__.setFocusTimeout)(() => {
        const now = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.timestamp)();
        let cnt = 0;
        for (const entry of pendingPurge) {
          if (entry.expiry > now) break;
          callbacks.forEach(cb => {
            try {
              cb(entry.item);
            } catch (e) {
              (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError)(e);
            }
          });
          items.delete(entry.item);
          cnt++;
        }
        pendingPurge.splice(0, cnt);
        task = null;
        reschedulePurge();
      }, nextPurge - now);
    } else {
      task = null;
    }
  }
  function mkEntry(item) {
    const values = {};
    const thisCohort = currentCohort;
    let expiry;
    function update() {
      if (thisCohort === currentCohort && values.start != null && values.delta != null) {
        expiry = values.start + values.delta;
        markForPurge(entry);
        if (task == null || nextPurge > expiry + slack) {
          reschedulePurge();
        }
      }
    }
    const [init, refresh] = Object.entries({
      start: startTime,
      delta: ttl
    }).map(_ref => {
      let [field, getter] = _ref;
      let currentCall;
      return function () {
        const thisCall = currentCall = {};
        _promise_js__WEBPACK_IMPORTED_MODULE_2__.PbPromise.resolve(getter(item)).then(val => {
          if (thisCall === currentCall) {
            values[field] = val;
            update();
          }
        });
      };
    });
    const entry = {
      item,
      refresh,
      get expiry() {
        return expiry;
      }
    };
    init();
    refresh();
    return entry;
  }
  let currentCohort = {};
  return {
    [Symbol.iterator]: () => items.keys(),
    /**
     * Add an item to this collection.
     * @param item
     */
    add(item) {
      !items.has(item) && items.set(item, mkEntry(item));
    },
    /**
     * Clear this collection.
     */
    clear() {
      pendingPurge.length = 0;
      reschedulePurge();
      items.clear();
      currentCohort = {};
    },
    /**
     * @returns {[]} all the items in this collection, in insertion order.
     */
    toArray() {
      return Array.from(items.keys());
    },
    /**
     * Refresh the TTL for each item in this collection.
     */
    refresh() {
      pendingPurge.length = 0;
      reschedulePurge();
      for (const entry of items.values()) {
        entry.refresh();
      }
    },
    /**
     * Register a callback to be run when an item has expired and is about to be
     * removed the from the collection.
     * @param cb a callback that takes the expired item as argument
     * @return an unregistration function.
     */
    onExpiry(cb) {
      callbacks.push(cb);
      return () => {
        const idx = callbacks.indexOf(cb);
        if (idx >= 0) {
          callbacks.splice(idx, 1);
        }
      };
    }
  };
}

/***/ }),

/***/ "./src/video.js":
/*!**********************!*\
  !*** ./src/video.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   INSTREAM: () => (/* binding */ INSTREAM),
/* harmony export */   ORTB_VIDEO_PARAMS: () => (/* binding */ ORTB_VIDEO_PARAMS),
/* harmony export */   OUTSTREAM: () => (/* binding */ OUTSTREAM),
/* harmony export */   checkVideoBidSetup: () => (/* binding */ checkVideoBidSetup),
/* harmony export */   fillVideoDefaults: () => (/* binding */ fillVideoDefaults),
/* harmony export */   isValidVideoBid: () => (/* binding */ isValidVideoBid),
/* harmony export */   validateOrtbVideoFields: () => (/* binding */ validateOrtbVideoFields)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _hook_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hook.js */ "./src/hook.js");
/* harmony import */ var _auctionManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./auctionManager.js */ "./src/auctionManager.js");




const OUTSTREAM = 'outstream';
const INSTREAM = 'instream';

/**
 * List of OpenRTB 2.x video object properties with simple validators.
 * Not included: `companionad`, `durfloors`, `ext`
 * reference: https://github.com/InteractiveAdvertisingBureau/openrtb2.x/blob/main/2.6.md
 */
const ORTB_VIDEO_PARAMS = new Map([['mimes', value => Array.isArray(value) && value.length > 0 && value.every(v => typeof v === 'string')], ['minduration', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['maxduration', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['startdelay', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['maxseq', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['poddur', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['protocols', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isArrayOfNums], ['w', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['h', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['podid', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr], ['podseq', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['rqddurs', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isArrayOfNums], ['placement', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger],
// deprecated, see plcmt
['plcmt', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['linearity', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['skip', value => [1, 0].includes(value)], ['skipmin', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['skipafter', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['sequence', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger],
// deprecated
['slotinpod', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['mincpmpersec', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isNumber], ['battr', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isArrayOfNums], ['maxextended', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['minbitrate', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['maxbitrate', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['boxingallowed', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['playbackmethod', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isArrayOfNums], ['playbackend', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['delivery', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isArrayOfNums], ['pos', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger], ['api', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isArrayOfNums], ['companiontype', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isArrayOfNums], ['poddedupe', _utils_js__WEBPACK_IMPORTED_MODULE_0__.isArrayOfNums]]);
function fillVideoDefaults(adUnit) {
  const video = adUnit?.mediaTypes?.video;
  if (video != null && video.plcmt == null) {
    if (video.context === OUTSTREAM || [2, 3, 4].includes(video.placement)) {
      video.plcmt = 4;
    } else if (video.context !== OUTSTREAM && [2, 6].includes(video.playbackmethod)) {
      video.plcmt = 2;
    }
  }
}

/**
 * validateOrtbVideoFields mutates the `adUnit.mediaTypes.video` object by removing invalid ortb properties (default).
 * The onInvalidParam callback can be used to handle invalid properties differently.
 * Other properties are ignored and kept as is.
 *
 * @param {Object} adUnit - The adUnit object.
 * @param {Function} onInvalidParam - The callback function to be called with key, value, and adUnit.
 * @returns {void}
 */
function validateOrtbVideoFields(adUnit, onInvalidParam) {
  const videoParams = adUnit?.mediaTypes?.video;
  if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(videoParams)) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)(`validateOrtbVideoFields: videoParams must be an object.`);
    return;
  }
  if (videoParams != null) {
    Object.entries(videoParams).forEach(_ref => {
      let [key, value] = _ref;
      if (!ORTB_VIDEO_PARAMS.has(key)) {
        return;
      }
      const isValid = ORTB_VIDEO_PARAMS.get(key)(value);
      if (!isValid) {
        if (typeof onInvalidParam === 'function') {
          onInvalidParam(key, value, adUnit);
        } else {
          delete videoParams[key];
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)(`Invalid prop in adUnit "${adUnit.code}": Invalid value for mediaTypes.video.${key} ORTB property. The property has been removed.`);
        }
      }
    });
  }
}

/**
 * @typedef {object} VideoBid
 * @property {string} adId id of the bid
 */

/**
 * Validate that the assets required for video context are present on the bid
 * @param {VideoBid} bid Video bid to validate
 * @param {Object} [options] - Options object
 * @param {Object} [options.index=auctionManager.index] - Index object, defaulting to `auctionManager.index`
 * @return {Boolean} If object is valid
 */
function isValidVideoBid(bid) {
  let {
    index = _auctionManager_js__WEBPACK_IMPORTED_MODULE_1__.auctionManager.index
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const videoMediaType = index.getMediaTypes(bid)?.video;
  const context = videoMediaType && videoMediaType?.context;
  const useCacheKey = videoMediaType && videoMediaType?.useCacheKey;
  const adUnit = index.getAdUnit(bid);

  // if context not defined assume default 'instream' for video bids
  // instream bids require a vast url or vast xml content
  return checkVideoBidSetup(bid, adUnit, videoMediaType, context, useCacheKey);
}
const checkVideoBidSetup = (0,_hook_js__WEBPACK_IMPORTED_MODULE_2__.hook)('sync', function (bid, adUnit, videoMediaType, context, useCacheKey) {
  if (videoMediaType && (useCacheKey || context !== OUTSTREAM)) {
    // xml-only video bids require a prebid cache url
    const {
      url,
      useLocal
    } = _src_config_js__WEBPACK_IMPORTED_MODULE_3__.config.getConfig('cache') || {};
    if (!url && !useLocal && bid.vastXml && !bid.vastUrl) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError)(`
        This bid contains only vastXml and will not work when a prebid cache url is not specified.
        Try enabling either prebid cache with pbjs.setConfig({ cache: {url: "..."} });
        or local cache with pbjs.setConfig({ cache: { useLocal: true }});
      `);
      return false;
    }
    return !!(bid.vastUrl || bid.vastXml);
  }

  // outstream bids require a renderer on the bid or pub-defined on adunit
  if (context === OUTSTREAM && !useCacheKey) {
    return !!(bid.renderer || adUnit && adUnit.renderer || videoMediaType.renderer);
  }
  return true;
}, 'checkVideoBidSetup');

/***/ }),

/***/ "./src/videoCache.js":
/*!***************************!*\
  !*** ./src/videoCache.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   batchAndStore: () => (/* binding */ batchAndStore),
/* harmony export */   store: () => (/* binding */ store),
/* harmony export */   storeLocally: () => (/* binding */ storeLocally),
/* harmony export */   vastLocalCache: () => (/* binding */ vastLocalCache)
/* harmony export */ });
/* unused harmony exports getCacheUrl, _internal, storeBatch, batchingCache */
/* harmony import */ var _ajax_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ajax.js */ "./src/ajax.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config.js */ "./src/config.js");
/* harmony import */ var _auctionManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./auctionManager.js */ "./src/auctionManager.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ "./src/utils.js");
/* harmony import */ var _auction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./auction.js */ "./src/auction.js");
/**
 * This module interacts with the server used to cache video ad content to be restored later.
 * At a high level, the expected workflow goes like this:
 *
 *   - Request video ads from Bidders
 *   - Generate IDs for each valid bid, and cache the key/value pair on the server.
 *   - Return these IDs so that publishers can use them to fetch the bids later.
 *
 * This trickery helps integrate with ad servers, which set character limits on request params.
 */







/**
 * Might be useful to be configurable in the future
 * Depending on publisher needs
 */
const ttlBufferInSeconds = 15;
const vastLocalCache = new Map();

/**
 * @typedef {object} CacheableUrlBid
 * @property {string} vastUrl A URL which loads some valid VAST XML.
 */

/**
 * @typedef {object} CacheablePayloadBid
 * @property {string} vastXml Some VAST XML which loads an ad in a video player.
 */

/**
 * A CacheableBid describes the types which the videoCache can store.
 *
 * @typedef {CacheableUrlBid|CacheablePayloadBid} CacheableBid
 */

/**
 * Function which wraps a URI that serves VAST XML, so that it can be loaded.
 *
 * @param {string} uri The URI where the VAST content can be found.
 * @param {(string|string[])} impTrackerURLs An impression tracker URL for the delivery of the video ad
 * @return A VAST URL which loads XML from the given URI.
 */
function wrapURI(uri, impTrackerURLs) {
  impTrackerURLs = impTrackerURLs && (Array.isArray(impTrackerURLs) ? impTrackerURLs : [impTrackerURLs]);
  // Technically, this is vulnerable to cross-script injection by sketchy vastUrl bids.
  // We could make sure it's a valid URI... but since we're loading VAST XML from the
  // URL they provide anyway, that's probably not a big deal.
  let impressions = impTrackerURLs ? impTrackerURLs.map(trk => `<Impression><![CDATA[${trk}]]></Impression>`).join('') : '';
  return `<VAST version="3.0">
    <Ad>
      <Wrapper>
        <AdSystem>prebid.org wrapper</AdSystem>
        <VASTAdTagURI><![CDATA[${uri}]]></VASTAdTagURI>
        ${impressions}
        <Creatives></Creatives>
      </Wrapper>
    </Ad>
  </VAST>`;
}

/**
 * Wraps a bid in the format expected by the prebid-server endpoints, or returns null if
 * the bid can't be converted cleanly.
 *
 * @param {CacheableBid} bid
 * @param {Object} [options] - Options object.
 * @param {Object} [options.index=auctionManager.index] - Index object, defaulting to `auctionManager.index`.
 * @return {Object|null} - The payload to be sent to the prebid-server endpoints, or null if the bid can't be converted cleanly.
 */
function toStorageRequest(bid) {
  let {
    index = _auctionManager_js__WEBPACK_IMPORTED_MODULE_0__.auctionManager.index
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const vastValue = getVastXml(bid);
  const auction = index.getAuction(bid);
  const ttlWithBuffer = Number(bid.ttl) + ttlBufferInSeconds;
  let payload = {
    type: 'xml',
    value: vastValue,
    ttlseconds: ttlWithBuffer
  };
  if (_config_js__WEBPACK_IMPORTED_MODULE_1__.config.getConfig('cache.vasttrack')) {
    payload.bidder = bid.bidder;
    payload.bidid = bid.requestId;
    payload.aid = bid.auctionId;
  }
  if (auction != null) {
    payload.timestamp = auction.getAuctionStart();
  }
  if (typeof bid.customCacheKey === 'string' && bid.customCacheKey !== '') {
    payload.key = bid.customCacheKey;
  }
  return payload;
}

/**
 * A function which should be called with the results of the storage operation.
 *
 * @callback videoCacheStoreCallback
 *
 * @param {Error} [error] The error, if one occurred.
 * @param {?string[]} uuids An array of unique IDs. The array will have one element for each bid we were asked
 *   to store. It may include null elements if some of the bids were malformed, or an error occurred.
 *   Each non-null element in this array is a valid input into the retrieve function, which will fetch
 *   some VAST XML which can be used to render this bid's ad.
 */

/**
 * A function which bridges the APIs between the videoCacheStoreCallback and our ajax function's API.
 *
 * @param {videoCacheStoreCallback} done A callback to the "store" function.
 * @return {Function} A callback which interprets the cache server's responses, and makes up the right
 *   arguments for our callback.
 */
function shimStorageCallback(done) {
  return {
    success: function (responseBody) {
      let ids;
      try {
        ids = JSON.parse(responseBody).responses;
      } catch (e) {
        done(e, []);
        return;
      }
      if (ids) {
        done(null, ids);
      } else {
        done(new Error("The cache server didn't respond with a responses property."), []);
      }
    },
    error: function (statusText, responseBody) {
      done(new Error(`Error storing video ad in the cache: ${statusText}: ${JSON.stringify(responseBody)}`), []);
    }
  };
}
function getVastXml(bid) {
  return bid.vastXml ? bid.vastXml : wrapURI(bid.vastUrl, bid.vastImpUrl);
}
;

/**
 * If the given bid is for a Video ad, generate a unique ID and cache it somewhere server-side.
 *
 * @param {CacheableBid[]} bids A list of bid objects which should be cached.
 * @param {videoCacheStoreCallback} [done] An optional callback which should be executed after
 * the data has been stored in the cache.
 */
function store(bids, done) {
  let getAjax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _ajax_js__WEBPACK_IMPORTED_MODULE_2__.ajaxBuilder;
  const requestData = {
    puts: bids.map(toStorageRequest)
  };
  const ajax = getAjax(_config_js__WEBPACK_IMPORTED_MODULE_1__.config.getConfig('cache.timeout'));
  ajax(_config_js__WEBPACK_IMPORTED_MODULE_1__.config.getConfig('cache.url'), shimStorageCallback(done), JSON.stringify(requestData), {
    contentType: 'text/plain',
    withCredentials: true
  });
}
function getCacheUrl(id) {
  return `${_config_js__WEBPACK_IMPORTED_MODULE_1__.config.getConfig('cache.url')}?uuid=${id}`;
}
const storeLocally = bid => {
  const vastXml = getVastXml(bid);
  const bidVastUrl = URL.createObjectURL(new Blob([vastXml], {
    type: 'text/xml'
  }));
  assignVastUrlAndCacheId(bid, bidVastUrl);
  vastLocalCache.set(bid.videoCacheKey, bidVastUrl);
};
const assignVastUrlAndCacheId = (bid, vastUrl, videoCacheKey) => {
  bid.videoCacheKey = videoCacheKey || (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.generateUUID)();
  if (!bid.vastUrl) {
    bid.vastUrl = vastUrl;
  }
};
const _internal = {
  store
};
function storeBatch(batch) {
  const bids = batch.map(entry => entry.bidResponse);
  function err(msg) {
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`Failed to save to the video cache: ${msg}. Video bids will be discarded:`, bids);
  }
  _internal.store(bids, function (error, cacheIds) {
    if (error) {
      err(error);
    } else if (batch.length !== cacheIds.length) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`expected ${batch.length} cache IDs, got ${cacheIds.length} instead`);
    } else {
      cacheIds.forEach((cacheId, i) => {
        const {
          auctionInstance,
          bidResponse,
          afterBidAdded
        } = batch[i];
        if (cacheId.uuid === '') {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(`Supplied video cache key was already in use by Prebid Cache; caching attempt was rejected. Video bid must be discarded.`);
        } else {
          assignVastUrlAndCacheId(bidResponse, getCacheUrl(cacheId.uuid), cacheId.uuid);
          (0,_auction_js__WEBPACK_IMPORTED_MODULE_4__.addBidToAuction)(auctionInstance, bidResponse);
          afterBidAdded();
        }
      });
    }
  });
}
;
let batchSize, batchTimeout, cleanupHandler;
if (true) {
  _config_js__WEBPACK_IMPORTED_MODULE_1__.config.getConfig('cache', _ref => {
    let {
      cache
    } = _ref;
    batchSize = typeof cache.batchSize === 'number' && cache.batchSize > 0 ? cache.batchSize : 1;
    batchTimeout = typeof cache.batchTimeout === 'number' && cache.batchTimeout > 0 ? cache.batchTimeout : 0;

    // removing blobs that are not going to be used
    if (cache.useLocal && !cleanupHandler) {
      cleanupHandler = _auctionManager_js__WEBPACK_IMPORTED_MODULE_0__.auctionManager.onExpiry(auction => {
        auction.getBidsReceived().forEach(bid => {
          const vastUrl = vastLocalCache.get(bid.videoCacheKey);
          if (vastUrl && vastUrl.startsWith('blob')) {
            URL.revokeObjectURL(vastUrl);
          }
          vastLocalCache.delete(bid.videoCacheKey);
        });
      });
    }
  });
}
const batchingCache = function () {
  let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : setTimeout;
  let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : storeBatch;
  let batches = [[]];
  let debouncing = false;
  const noTimeout = cb => cb();
  return function (auctionInstance, bidResponse, afterBidAdded) {
    const batchFunc = batchTimeout > 0 ? timeout : noTimeout;
    if (batches[batches.length - 1].length >= batchSize) {
      batches.push([]);
    }
    batches[batches.length - 1].push({
      auctionInstance,
      bidResponse,
      afterBidAdded
    });
    if (!debouncing) {
      debouncing = true;
      batchFunc(() => {
        batches.forEach(cache);
        batches = [[]];
        debouncing = false;
      }, batchTimeout);
    }
  };
};
const batchAndStore = batchingCache();

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["viewport"],{

/***/ "./libraries/viewport/viewport.js":
/*!****************************************!*\
  !*** ./libraries/viewport/viewport.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getViewportSize: () => (/* binding */ getViewportSize)
/* harmony export */ });
/* unused harmony export getViewportCoordinates */
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");

function getViewportCoordinates() {
  try {
    const win = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.getWindowTop)();
    let {
      scrollY: top,
      scrollX: left
    } = win;
    const {
      height: innerHeight,
      width: innerWidth
    } = getViewportSize();
    return {
      top,
      right: left + innerWidth,
      bottom: top + innerHeight,
      left
    };
  } catch (e) {
    return {};
  }
}
function getViewportSize() {
  const windowDimensions = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.getWinDimensions)();
  try {
    const innerHeight = windowDimensions.innerHeight || windowDimensions.document.documentElement.clientHeight || windowDimensions.document.body.clientHeight || 0;
    const innerWidth = windowDimensions.innerWidth || windowDimensions.document.documentElement.clientWidth || windowDimensions.document.body.clientWidth || 0;
    return {
      width: innerWidth,
      height: innerHeight
    };
  } catch (e) {
    return {};
  }
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["greedy"],{

/***/ "./libraries/greedy/greedyPromise.js":
/*!*******************************************!*\
  !*** ./libraries/greedy/greedyPromise.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GreedyPromise: () => (/* binding */ GreedyPromise),
/* harmony export */   greedySetTimeout: () => (/* binding */ greedySetTimeout)
/* harmony export */ });
const SUCCESS = 0;
const FAIL = 1;

/**
 * A version of Promise that runs callbacks synchronously when it can (i.e. after it's been fulfilled or rejected).
 */
class GreedyPromise {
  #result;
  #callbacks;
  constructor(resolver) {
    if (typeof resolver !== 'function') {
      throw new Error('resolver not a function');
    }
    const result = [];
    const callbacks = [];
    let [resolve, reject] = [SUCCESS, FAIL].map(type => {
      return function (value) {
        if (type === SUCCESS && typeof value?.then === 'function') {
          value.then(resolve, reject);
        } else if (!result.length) {
          result.push(type, value);
          while (callbacks.length) callbacks.shift()();
        }
      };
    });
    try {
      resolver(resolve, reject);
    } catch (e) {
      reject(e);
    }
    this.#result = result;
    this.#callbacks = callbacks;
  }
  then(onSuccess, onError) {
    const result = this.#result;
    return new this.constructor((resolve, reject) => {
      const continuation = () => {
        let value = result[1];
        let [handler, resolveFn] = result[0] === SUCCESS ? [onSuccess, resolve] : [onError, reject];
        if (typeof handler === 'function') {
          try {
            value = handler(value);
          } catch (e) {
            reject(e);
            return;
          }
          resolveFn = resolve;
        }
        resolveFn(value);
      };
      result.length ? continuation() : this.#callbacks.push(continuation);
    });
  }
  catch(onError) {
    return this.then(null, onError);
  }
  finally(onFinally) {
    let val;
    return this.then(v => {
      val = v;
      return onFinally();
    }, e => {
      val = this.constructor.reject(e);
      return onFinally();
    }).then(() => val);
  }
  static #collect(promises, collector, done) {
    let cnt = promises.length;
    function clt() {
      collector.apply(this, arguments);
      if (--cnt <= 0 && done) done();
    }
    promises.length === 0 && done ? done() : promises.forEach((p, i) => this.resolve(p).then(val => clt(true, val, i), err => clt(false, err, i)));
  }
  static race(promises) {
    return new this((resolve, reject) => {
      this.#collect(promises, (success, result) => success ? resolve(result) : reject(result));
    });
  }
  static all(promises) {
    return new this((resolve, reject) => {
      let res = [];
      this.#collect(promises, (success, val, i) => success ? res[i] = val : reject(val), () => resolve(res));
    });
  }
  static allSettled(promises) {
    return new this(resolve => {
      let res = [];
      this.#collect(promises, (success, val, i) => res[i] = success ? {
        status: 'fulfilled',
        value: val
      } : {
        status: 'rejected',
        reason: val
      }, () => resolve(res));
    });
  }
  static resolve(value) {
    return new this(resolve => resolve(value));
  }
  static reject(error) {
    return new this((resolve, reject) => reject(error));
  }
}
function greedySetTimeout(fn) {
  let delayMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  if (delayMs > 0) {
    return setTimeout(fn, delayMs);
  } else {
    fn();
  }
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["creative-renderer-display"],{

/***/ "./libraries/creative-renderer-display/renderer.js":
/*!*********************************************************!*\
  !*** ./libraries/creative-renderer-display/renderer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RENDERER: () => (/* binding */ RENDERER)
/* harmony export */ });
// this file is autogenerated, see creative/README.md
const RENDERER = "(()=>{\"use strict\";window.render=function({ad:e,adUrl:t,width:n,height:i,instl:d},{mkFrame:r},s){if(!e&&!t)throw{reason:\"noAd\",message:\"Missing ad markup or URL\"};{if(null==i){const e=s.document?.body;[e,e?.parentElement].filter((e=>null!=e?.style)).forEach((e=>e.style.height=\"100%\"))}const h=s.document,o={width:n??\"100%\",height:i??\"100%\"};if(t&&!e?o.src=t:o.srcdoc=e,h.body.appendChild(r(h,o)),d&&s.frameElement){const e=s.frameElement.style;e.width=n?`${n}px`:\"100vw\",e.height=i?`${i}px`:\"100vh\"}}}})();";

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["appnexusUtils"],{

/***/ "./libraries/appnexusUtils/anKeywords.js":
/*!***********************************************!*\
  !*** ./libraries/appnexusUtils/anKeywords.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertKeywordStringToANMap: () => (/* binding */ convertKeywordStringToANMap),
/* harmony export */   getANKewyordParamFromMaps: () => (/* binding */ getANKewyordParamFromMaps),
/* harmony export */   getANKeywordParam: () => (/* binding */ getANKeywordParam)
/* harmony export */ });
/* unused harmony exports transformBidderParamKeywords, getANMapFromOrtbKeywords, getANMapFromOrtbSegments */
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _keywords_keywords_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../keywords/keywords.js */ "./libraries/keywords/keywords.js");
/* harmony import */ var _src_fpd_oneClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/fpd/oneClient.js */ "./src/fpd/oneClient.js");



const ORTB_SEGTAX_KEY_MAP = {
  526: '1plusX',
  527: '1plusX',
  541: 'captify_segments',
  540: 'perid'
};
const ORTB_SEG_PATHS = ['user.data'].concat(_src_fpd_oneClient_js__WEBPACK_IMPORTED_MODULE_0__.CLIENT_SECTIONS.map(prefix => `${prefix}.content.data`));
function getValueString(param, val, defaultValue) {
  if (val === undefined || val === null) {
    return defaultValue;
  }
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isStr)(val)) {
    return val;
  }
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(val)) {
    return val.toString();
  }
  (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)('Unsuported type for param: ' + param + ' required type: String');
}

/**
 * Converts an object of arrays (either strings or numbers) into an array of objects containing key and value properties
 * normally read from bidder params
 * eg { foo: ['bar', 'baz'], fizz: ['buzz'] }
 * becomes [{ key: 'foo', value: ['bar', 'baz']}, {key: 'fizz', value: ['buzz']}]
 * @param {Object} keywords object of arrays representing keyvalue pairs
 * @param {string} paramName name of parent object (eg 'keywords') containing keyword data, used in error handling
 * @returns {Array<{key, value}>}
 */
function transformBidderParamKeywords(keywords) {
  let paramName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'keywords';
  const arrs = [];
  (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__._each)(keywords, (v, k) => {
    if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(v)) {
      let values = [];
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__._each)(v, val => {
        val = getValueString(paramName + '.' + k, val);
        if (val || val === '') {
          values.push(val);
        }
      });
      v = values;
    } else {
      v = getValueString(paramName + '.' + k, v);
      if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isStr)(v)) {
        v = [v];
      } else {
        return;
      } // unsuported types - don't send a key
    }
    v = v.filter(kw => kw !== '');
    const entry = {
      key: k
    };
    if (v.length > 0) {
      entry.value = v;
    }
    arrs.push(entry);
  });
  return arrs;
}

// converts a comma separated list of keywords into the standard keyword object format used in appnexus bid params
// 'genre=rock,genre=pop,pets=dog,music' goes to { 'genre': ['rock', 'pop'], 'pets': ['dog'], 'music': [''] }
function convertKeywordStringToANMap(keyStr) {
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isStr)(keyStr) && keyStr !== '') {
    // will split based on commas and will eat white space before/after the comma
    return convertKeywordsToANMap(keyStr.split(/\s*(?:,)\s*/));
  } else {
    return {};
  }
}

/**
 * @param {Array<String>} kwarray keywords as an array of strings
 * @return {{}} appnexus-style keyword map
 */
function convertKeywordsToANMap(kwarray) {
  const result = {};
  kwarray.forEach(kw => {
    // if = exists, then split
    if (kw.indexOf('=') !== -1) {
      let kwPair = kw.split('=');
      let key = kwPair[0];
      let val = kwPair[1];

      // then check for existing key in result > if so add value to the array > if not, add new key and create value array
      if (result.hasOwnProperty(key)) {
        result[key].push(val);
      } else {
        result[key] = [val];
      }
    } else {
      if (!result.hasOwnProperty(kw)) {
        result[kw] = [];
      }
    }
  });
  return result;
}

/**
 * @param ortb2
 * @return {{}} appnexus-style keyword map using all keywords contained in ortb2
 */
function getANMapFromOrtbKeywords(ortb2) {
  return convertKeywordsToANMap((0,_keywords_keywords_js__WEBPACK_IMPORTED_MODULE_2__.getAllOrtbKeywords)(ortb2));
}
function getANKewyordParamFromMaps() {
  for (var _len = arguments.length, anKeywordMaps = new Array(_len), _key = 0; _key < _len; _key++) {
    anKeywordMaps[_key] = arguments[_key];
  }
  return transformBidderParamKeywords((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeep)(...anKeywordMaps.map(kwMap => Object.fromEntries(Object.entries(kwMap || {}).map(_ref => {
    let [k, v] = _ref;
    return [k, (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(v) || (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isStr)(v) ? [v] : v];
  })))));
}
function getANKeywordParam(ortb2) {
  for (var _len2 = arguments.length, anKeywordsMaps = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    anKeywordsMaps[_key2 - 1] = arguments[_key2];
  }
  return getANKewyordParamFromMaps(getANMapFromOrtbKeywords(ortb2), getANMapFromOrtbSegments(ortb2), ...anKeywordsMaps);
}
function getANMapFromOrtbSegments(ortb2) {
  let ortbSegData = {};
  ORTB_SEG_PATHS.forEach(path => {
    let ortbSegsArrObj = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(ortb2, path) || [];
    ortbSegsArrObj.forEach(segObj => {
      // only read segment data from known sources
      const segtax = ORTB_SEGTAX_KEY_MAP[segObj?.ext?.segtax];
      if (segtax) {
        segObj.segment.forEach(seg => {
          // if source was in multiple locations of ortb or had multiple segments in same area, stack them together into an array
          if (ortbSegData[segtax]) {
            ortbSegData[segtax].push(seg.id);
          } else {
            ortbSegData[segtax] = [seg.id];
          }
        });
      }
    });
  });
  return ortbSegData;
}

/***/ }),

/***/ "./libraries/appnexusUtils/anUtils.js":
/*!********************************************!*\
  !*** ./libraries/appnexusUtils/anUtils.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appnexusAliases: () => (/* binding */ appnexusAliases),
/* harmony export */   convertCamelToUnderscore: () => (/* binding */ convertCamelToUnderscore),
/* harmony export */   fill: () => (/* binding */ fill)
/* harmony export */ });
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");
/**
 * Converts a string value in camel-case to underscore eg 'placementId' becomes 'placement_id'
 * @param {string} value string value to convert
 */

function convertCamelToUnderscore(value) {
  return value.replace(/(?:^|\.?)([A-Z])/g, function (x, y) {
    return '_' + y.toLowerCase();
  }).replace(/^_/, '');
}
const appnexusAliases = [{
  code: 'appnexusAst',
  gvlid: 32
}, {
  code: 'emxdigital',
  gvlid: 183
}, {
  code: 'emetriq',
  gvlid: 213
}, {
  code: 'pagescience',
  gvlid: 32
}, {
  code: 'gourmetads',
  gvlid: 32
}, {
  code: 'matomy',
  gvlid: 32
}, {
  code: 'featureforward',
  gvlid: 32
}, {
  code: 'oftmedia',
  gvlid: 32
}, {
  code: 'adasta',
  gvlid: 32
}, {
  code: 'beintoo',
  gvlid: 618
}, {
  code: 'projectagora',
  gvlid: 1032
}, {
  code: 'stailamedia',
  gvlid: 32
}, {
  code: 'uol',
  gvlid: 32
}, {
  code: 'adzymic',
  gvlid: 723
}];

/**
 * Creates an array of n length and fills each item with the given value
 */
function fill(value, length) {
  let newArray = [];
  for (let i = 0; i < length; i++) {
    let valueToPush = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) ? (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepClone)(value) : value;
    newArray.push(valueToPush);
  }
  return newArray;
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["transformParamsUtils"],{

/***/ "./libraries/transformParamsUtils/convertTypes.js":
/*!********************************************************!*\
  !*** ./libraries/transformParamsUtils/convertTypes.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertTypes: () => (/* binding */ convertTypes)
/* harmony export */ });
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");


/**
 * Try to convert a value to a type.
 * If it can't be done, the value will be returned.
 *
 * @param {string} typeToConvert The target type. e.g. "string", "number", etc.
 * @param {*} value The value to be converted into typeToConvert.
 */
function tryConvertType(typeToConvert, value) {
  if (typeToConvert === 'string') {
    return value && value.toString();
  } else if (typeToConvert === 'number') {
    return Number(value);
  } else {
    return value;
  }
}
function convertTypes(types, params) {
  Object.keys(types).forEach(key => {
    if (params[key]) {
      if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFn)(types[key])) {
        params[key] = types[key](params[key]);
      } else {
        params[key] = tryConvertType(types[key], params[key]);
      }

      // don't send invalid values
      if (isNaN(params[key])) {
        delete params.key;
      }
    }
  });
  return params;
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["keywords"],{

/***/ "./libraries/keywords/keywords.js":
/*!****************************************!*\
  !*** ./libraries/keywords/keywords.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getAllOrtbKeywords: () => (/* binding */ getAllOrtbKeywords)
/* harmony export */ });
/* unused harmony export mergeKeywords */
/* harmony import */ var _src_fpd_oneClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/fpd/oneClient.js */ "./src/fpd/oneClient.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/utils.js */ "./node_modules/dlv/index.js");


const ORTB_KEYWORDS_PATHS = ['user.keywords'].concat(_src_fpd_oneClient_js__WEBPACK_IMPORTED_MODULE_0__.CLIENT_SECTIONS.flatMap(prefix => ['keywords', 'content.keywords'].map(suffix => `${prefix}.${suffix}`)));

/**
 * @param commaSeparatedKeywords any number of either keyword arrays, or comma-separated keyword strings
 * @returns an array with all unique keywords contained across all inputs
 */
function mergeKeywords() {
  const keywords = new Set();
  for (var _len = arguments.length, commaSeparatedKeywords = new Array(_len), _key = 0; _key < _len; _key++) {
    commaSeparatedKeywords[_key] = arguments[_key];
  }
  commaSeparatedKeywords.filter(kwds => kwds).flatMap(kwds => Array.isArray(kwds) ? kwds : kwds.split(',')).map(kw => kw.replace(/^\s*/, '').replace(/\s*$/, '')).filter(kw => kw).forEach(kw => keywords.add(kw));
  return Array.from(keywords.keys());
}

/**
 * Get an array with all keywords contained in an ortb2 object.
 */
function getAllOrtbKeywords(ortb2) {
  for (var _len2 = arguments.length, extraCommaSeparatedKeywords = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    extraCommaSeparatedKeywords[_key2 - 1] = arguments[_key2];
  }
  return mergeKeywords(...ORTB_KEYWORDS_PATHS.map(path => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"])(ortb2, path)), ...extraCommaSeparatedKeywords);
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["chunk"],{

/***/ "./libraries/chunk/chunk.js":
/*!**********************************!*\
  !*** ./libraries/chunk/chunk.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   chunk: () => (/* binding */ chunk)
/* harmony export */ });
/**
 * http://npm.im/chunk
 * Returns an array with *size* chunks from given array
 *
 * Example:
 * ['a', 'b', 'c', 'd', 'e'] chunked by 2 =>
 * [['a', 'b'], ['c', 'd'], ['e']]
 */
function chunk(array, size) {
  let newArray = [];
  for (let i = 0; i < Math.ceil(array.length / size); i++) {
    let start = i * size;
    let end = start + size;
    newArray.push(array.slice(start, end));
  }
  return newArray;
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["categoryTranslationMapping"],{

/***/ "./libraries/categoryTranslationMapping/index.js":
/*!*******************************************************!*\
  !*** ./libraries/categoryTranslationMapping/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   APPNEXUS_CATEGORY_MAPPING: () => (/* binding */ APPNEXUS_CATEGORY_MAPPING)
/* harmony export */ });
/**
 * Provides mapping objects used by bidders for categoryTranslation type logic for Adpod feature
 */
const APPNEXUS_CATEGORY_MAPPING = {
  '1': 'IAB20-3',
  '2': 'IAB18-5',
  '3': 'IAB10-1',
  '4': 'IAB2-3',
  '5': 'IAB19-8',
  '6': 'IAB22-1',
  '7': 'IAB18-1',
  '8': 'IAB12-3',
  '9': 'IAB5-1',
  '10': 'IAB4-5',
  '11': 'IAB13-4',
  '12': 'IAB8-7',
  '13': 'IAB9-7',
  '14': 'IAB7-1',
  '15': 'IAB20-18',
  '16': 'IAB10-7',
  '17': 'IAB19-18',
  '18': 'IAB13-6',
  '19': 'IAB18-4',
  '20': 'IAB1-5',
  '21': 'IAB1-6',
  '22': 'IAB3-4',
  '23': 'IAB19-13',
  '24': 'IAB22-2',
  '25': 'IAB3-9',
  '26': 'IAB17-18',
  '27': 'IAB19-6',
  '28': 'IAB1-7',
  '29': 'IAB9-30',
  '30': 'IAB20-7',
  '31': 'IAB20-17',
  '32': 'IAB7-32',
  '33': 'IAB16-5',
  '34': 'IAB19-34',
  '35': 'IAB11-5',
  '36': 'IAB12-3',
  '37': 'IAB11-4',
  '38': 'IAB12-3',
  '39': 'IAB9-30',
  '41': 'IAB7-44',
  '42': 'IAB7-1',
  '43': 'IAB7-30',
  '50': 'IAB19-30',
  '51': 'IAB17-12',
  '52': 'IAB19-30',
  '53': 'IAB3-1',
  '55': 'IAB13-2',
  '56': 'IAB19-30',
  '57': 'IAB19-30',
  '58': 'IAB7-39',
  '59': 'IAB22-1',
  '60': 'IAB7-39',
  '61': 'IAB21-3',
  '62': 'IAB5-1',
  '63': 'IAB12-3',
  '64': 'IAB20-18',
  '65': 'IAB11-2',
  '66': 'IAB17-18',
  '67': 'IAB9-9',
  '68': 'IAB9-5',
  '69': 'IAB7-44',
  '71': 'IAB22-3',
  '73': 'IAB19-30',
  '74': 'IAB8-5',
  '78': 'IAB22-1',
  '85': 'IAB12-2',
  '86': 'IAB22-3',
  '87': 'IAB11-3',
  '112': 'IAB7-32',
  '113': 'IAB7-32',
  '114': 'IAB7-32',
  '115': 'IAB7-32',
  '118': 'IAB9-5',
  '119': 'IAB9-5',
  '120': 'IAB9-5',
  '121': 'IAB9-5',
  '122': 'IAB9-5',
  '123': 'IAB9-5',
  '124': 'IAB9-5',
  '125': 'IAB9-5',
  '126': 'IAB9-5',
  '127': 'IAB22-1',
  '132': 'IAB1-2',
  '133': 'IAB19-30',
  '137': 'IAB3-9',
  '138': 'IAB19-3',
  '140': 'IAB2-3',
  '141': 'IAB2-1',
  '142': 'IAB2-3',
  '143': 'IAB17-13',
  '166': 'IAB11-4',
  '175': 'IAB3-1',
  '176': 'IAB13-4',
  '182': 'IAB8-9',
  '183': 'IAB3-5'
};

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["cmp"],{

/***/ "./libraries/cmp/cmpClient.js":
/*!************************************!*\
  !*** ./libraries/cmp/cmpClient.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MODE_CALLBACK: () => (/* binding */ MODE_CALLBACK),
/* harmony export */   cmpClient: () => (/* binding */ cmpClient)
/* harmony export */ });
/* unused harmony exports MODE_MIXED, MODE_RETURN */
/* harmony import */ var _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/utils/promise.js */ "./src/utils/promise.js");


/**
 * @typedef {function} CMPClient
 *
 * @param {{}} params CMP parameters. Currently this is a subset of {command, callback, parameter, version}.
 * @param {boolean} once if true, discard cross-frame event listeners once a reply message is received.
 * @returns {Promise<*>} a promise to the API's "result" - see the `mode` argument to `cmpClient` on how that's determined.
 * @property {boolean} isDirect true if the CMP is directly accessible (no postMessage required)
 * @property {() => void} close close the client; currently, this just stops listening for cross-frame messages.
 */

const MODE_MIXED = 0;
const MODE_RETURN = 1;
const MODE_CALLBACK = 2;

/**
 * Returns a client function that can interface with a CMP regardless of where it's located.
 *
 * @param {object} obj
 * @param obj.apiName name of the CMP api, e.g. "__gpp"
 * @param [obj.apiVersion] CMP API version
 * @param [obj.apiArgs] names of the arguments taken by the api function, in order.
 * @param [obj.callbackArgs] names of the cross-frame response payload properties that should be passed as callback arguments, in order
 * @param [obj.mode] controls the callbacks passed to the underlying API, and how the promises returned by the client are resolved.
 *
 * The client behaves differently when it's provided a `callback` argument vs when it's not - for short, let's name these
 * cases "subscriptions" and "one-shot calls" respectively:
 *
 * With `mode: MODE_MIXED` (the default), promises returned on subscriptions are resolved to undefined when the callback
 * is first run (that is, the promise resolves when the CMP replies, but what it replies with is discarded and
 * left for the callback to deal with). For one-shot calls, the returned promise is resolved to the API's
 * return value when it's directly accessible, or with the result from the first (and, presumably, the only)
 * cross-frame reply when it's not;
 *
 * With `mode: MODE_RETURN`, the returned promise always resolves to the API's return value - which is taken to be undefined
 * when cross-frame;
 *
 * With `mode: MODE_CALLBACK`, the underlying API is expected to never directly return anything significant; instead,
 * it should always accept a callback and - for one-shot calls - invoke it only once with the result. The client will
 * automatically generate an appropriate callback for one-shot calls and use the result it's given to resolve
 * the returned promise. Subscriptions are treated in the same way as MODE_MIXED.
 *
 * @param win
 * @returns {CMPClient} CMP invocation function (or null if no CMP was found).
 */
function cmpClient(_ref) {
  let {
    apiName,
    apiVersion,
    apiArgs = ['command', 'callback', 'parameter', 'version'],
    callbackArgs = ['returnValue', 'success'],
    mode = MODE_MIXED
  } = _ref;
  let win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
  const cmpCallbacks = {};
  const callName = `${apiName}Call`;
  const cmpDataPkgName = `${apiName}Return`;
  function handleMessage(event) {
    const json = typeof event.data === 'string' && event.data.includes(cmpDataPkgName) ? JSON.parse(event.data) : event.data;
    if (json?.[cmpDataPkgName]?.callId) {
      const payload = json[cmpDataPkgName];
      if (cmpCallbacks.hasOwnProperty(payload.callId)) {
        cmpCallbacks[payload.callId](...callbackArgs.map(name => payload[name]));
      }
    }
  }
  function findCMP() {
    let f = win;
    let cmpFrame;
    let isDirect = false;
    while (f != null) {
      try {
        if (typeof f[apiName] === 'function') {
          cmpFrame = f;
          isDirect = true;
          break;
        }
      } catch (e) {}

      // need separate try/catch blocks due to the exception errors thrown when trying to check for a frame that doesn't exist in 3rd party env
      try {
        if (f.frames[`${apiName}Locator`]) {
          cmpFrame = f;
          break;
        }
      } catch (e) {}
      if (f === win.top) break;
      f = f.parent;
    }
    return [cmpFrame, isDirect];
  }
  const [cmpFrame, isDirect] = findCMP();
  if (!cmpFrame) {
    return;
  }
  function resolveParams(params) {
    params = Object.assign({
      version: apiVersion
    }, params);
    return apiArgs.map(arg => [arg, params[arg]]);
  }
  function wrapCallback(callback, resolve, reject, preamble) {
    const haveCb = typeof callback === 'function';
    return function (result, success) {
      preamble && preamble();
      if (mode !== MODE_RETURN) {
        const resolver = success == null || success ? resolve : reject;
        resolver(haveCb ? undefined : result);
      }
      haveCb && callback.apply(this, arguments);
    };
  }
  let client;
  if (isDirect) {
    client = function invokeCMPDirect() {
      let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_0__.PbPromise((resolve, reject) => {
        const ret = cmpFrame[apiName](...resolveParams({
          ...params,
          callback: params.callback || mode === MODE_CALLBACK ? wrapCallback(params.callback, resolve, reject) : undefined
        }).map(_ref2 => {
          let [_, val] = _ref2;
          return val;
        }));
        if (mode === MODE_RETURN || params.callback == null && mode === MODE_MIXED) {
          resolve(ret);
        }
      });
    };
  } else {
    win.addEventListener('message', handleMessage, false);
    client = function invokeCMPFrame(params) {
      let once = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return new _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_0__.PbPromise((resolve, reject) => {
        // call CMP via postMessage
        const callId = Math.random().toString();
        const msg = {
          [callName]: {
            ...Object.fromEntries(resolveParams(params).filter(_ref3 => {
              let [param] = _ref3;
              return param !== 'callback';
            })),
            callId: callId
          }
        };
        cmpCallbacks[callId] = wrapCallback(params?.callback, resolve, reject, (once || params?.callback == null) && (() => {
          delete cmpCallbacks[callId];
        }));
        cmpFrame.postMessage(msg, '*');
        if (mode === MODE_RETURN) resolve();
      });
    };
  }
  return Object.assign(client, {
    isDirect,
    close() {
      !isDirect && win.removeEventListener('message', handleMessage);
    }
  });
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["consentManagement"],{

/***/ "./libraries/consentManagement/cmUtils.js":
/*!************************************************!*\
  !*** ./libraries/consentManagement/cmUtils.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   configParser: () => (/* binding */ configParser)
/* harmony export */ });
/* unused harmony exports consentManagementHook, lookupConsentData */
/* harmony import */ var _src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/utils/perfMetrics.js */ "./src/utils/perfMetrics.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../src/utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _src_activities_params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/activities/params.js */ "./src/activities/params.js");






function consentManagementHook(name, loadConsentData) {
  const SEEN = new WeakSet();
  return (0,_src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_0__.timedAuctionHook)(name, function requestBidsHook(fn, reqBidsConfigObj) {
    return loadConsentData().then(_ref => {
      let {
        consentData,
        error
      } = _ref;
      if (error && (!consentData || !SEEN.has(error))) {
        SEEN.add(error);
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(error.message, ...(error.args || []));
      }
      fn.call(this, reqBidsConfigObj);
    }).catch(error => {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`${error?.message} Canceling auction as per consentManagement config.`, ...(error?.args || []));
      fn.stopTiming();
      if (typeof reqBidsConfigObj.bidsBackHandler === 'function') {
        reqBidsConfigObj.bidsBackHandler();
      } else {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)('Error executing bidsBackHandler');
      }
    });
  });
}

/**
 *
 * @typedef {Function} CmpLookupFn CMP lookup function. Should set up communication and keep consent data updated
 *   through consent data handlers' `setConsentData`.
 * @param {SetProvisionalConsent} setProvisionalConsent optionally, the function can call this with provisional consent
 *   data, which will be used if the lookup times out before "proper" consent data can be retrieved.
 * @returns {Promise<{void}>} a promise that resolves when the auction should be continued, or rejects if it should be canceled.
 *
 * @typedef {Function} SetProvisionalConsent
 * @param {*} provisionalConsent
 * @returns {void}
 */

/**
 * Look up consent data from CMP or config.
 *
 * @param {Object} options
 * @param {String} options.name e.g. 'GPP'. Used only for log messages.
 * @param {ConsentHandler} options.consentDataHandler consent data handler object (from src/consentHandler)
 * @param {CmpLookupFn} options.setupCmp
 * @param {Number?} options.cmpTimeout timeout (in ms) after which the auction should continue without consent data.
 * @param {Number?} options.actionTimeout timeout (in ms) from when provisional consent is available to when the auction should continue with it
 * @param {() => {}} options.getNullConsent consent data to use on timeout
 * @returns {Promise<{error: Error, consentData: {}}>}
 */
function lookupConsentData(_ref2) {
  let {
    name,
    consentDataHandler,
    setupCmp,
    cmpTimeout,
    actionTimeout,
    getNullConsent
  } = _ref2;
  consentDataHandler.enable();
  let timeoutHandle;
  return new Promise((resolve, reject) => {
    let provisionalConsent;
    let cmpLoaded = false;
    function setProvisionalConsent(consentData) {
      provisionalConsent = consentData;
      if (!cmpLoaded) {
        cmpLoaded = true;
        actionTimeout != null && resetTimeout(actionTimeout);
      }
    }
    function resetTimeout(timeout) {
      if (timeoutHandle != null) clearTimeout(timeoutHandle);
      if (timeout != null) {
        timeoutHandle = setTimeout(() => {
          const consentData = consentDataHandler.getConsentData() ?? (cmpLoaded ? provisionalConsent : getNullConsent());
          const message = `timeout waiting for ${cmpLoaded ? 'user action on CMP' : 'CMP to load'}`;
          consentDataHandler.setConsentData(consentData);
          resolve({
            consentData,
            error: new Error(`${name} ${message}`)
          });
        }, timeout);
      } else {
        timeoutHandle = null;
      }
    }
    setupCmp(setProvisionalConsent).then(() => resolve({
      consentData: consentDataHandler.getConsentData()
    }), reject);
    cmpTimeout != null && resetTimeout(cmpTimeout);
  }).finally(() => {
    timeoutHandle && clearTimeout(timeoutHandle);
  }).catch(e => {
    consentDataHandler.setConsentData(null);
    throw e;
  });
}
function configParser() {
  let {
    namespace,
    displayName,
    consentDataHandler,
    parseConsentData,
    getNullConsent,
    cmpHandlers,
    DEFAULT_CMP = 'iab',
    DEFAULT_CONSENT_TIMEOUT = 10000
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  function msg(message) {
    return `consentManagement.${namespace} ${message}`;
  }
  let requestBidsHook, cdLoader, staticConsentData;
  function attachActivityParams(next, params) {
    return next(Object.assign({
      [`${namespace}Consent`]: consentDataHandler.getConsentData()
    }, params));
  }
  function loadConsentData() {
    return cdLoader().then(_ref3 => {
      let {
        error
      } = _ref3;
      return {
        error,
        consentData: consentDataHandler.getConsentData()
      };
    });
  }
  function activate() {
    if (requestBidsHook == null) {
      requestBidsHook = consentManagementHook(namespace, () => cdLoader());
      (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_2__.getGlobal)().requestBids.before(requestBidsHook, 50);
      _src_activities_params_js__WEBPACK_IMPORTED_MODULE_3__.buildActivityParams.before(attachActivityParams);
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logInfo)(`${displayName} consentManagement module has been activated...`);
    }
  }
  function reset() {
    if (requestBidsHook != null) {
      (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_2__.getGlobal)().requestBids.getHooks({
        hook: requestBidsHook
      }).remove();
      _src_activities_params_js__WEBPACK_IMPORTED_MODULE_3__.buildActivityParams.getHooks({
        hook: attachActivityParams
      }).remove();
      requestBidsHook = null;
    }
  }
  return function getConsentConfig(config) {
    config = config?.[namespace];
    if (!config || typeof config !== 'object') {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(msg(`config not defined, exiting consent manager module`));
      reset();
      return {};
    }
    let cmpHandler;
    if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isStr)(config.cmpApi)) {
      cmpHandler = config.cmpApi;
    } else {
      cmpHandler = DEFAULT_CMP;
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logInfo)(msg(`config did not specify cmp.  Using system default setting (${DEFAULT_CMP}).`));
    }
    let cmpTimeout;
    if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(config.timeout)) {
      cmpTimeout = config.timeout;
    } else {
      cmpTimeout = DEFAULT_CONSENT_TIMEOUT;
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logInfo)(msg(`config did not specify timeout.  Using system default setting (${DEFAULT_CONSENT_TIMEOUT}).`));
    }
    const actionTimeout = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(config.actionTimeout) ? config.actionTimeout : null;
    let setupCmp;
    if (cmpHandler === 'static') {
      if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(config.consentData)) {
        staticConsentData = config.consentData;
        cmpTimeout = null;
        setupCmp = () => new _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_4__.PbPromise(resolve => resolve(consentDataHandler.setConsentData(parseConsentData(staticConsentData))));
      } else {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(msg(`config with cmpApi: 'static' did not specify consentData. No consents will be available to adapters.`));
      }
    } else if (!cmpHandlers.hasOwnProperty(cmpHandler)) {
      consentDataHandler.setConsentData(null);
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`${displayName} CMP framework (${cmpHandler}) is not a supported framework.  Aborting consentManagement module and resuming auction.`);
      setupCmp = () => _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_4__.PbPromise.resolve();
    } else {
      setupCmp = cmpHandlers[cmpHandler];
    }
    const lookup = () => lookupConsentData({
      name: displayName,
      consentDataHandler,
      setupCmp,
      cmpTimeout,
      actionTimeout,
      getNullConsent
    });
    cdLoader = (() => {
      let cd;
      return function () {
        if (cd == null) {
          cd = lookup().catch(err => {
            cd = null;
            throw err;
          });
        }
        return cd;
      };
    })();
    activate();
    return {
      cmpHandler,
      cmpTimeout,
      actionTimeout,
      staticConsentData,
      loadConsentData,
      requestBidsHook
    };
  };
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["ortbConverter"],{

/***/ "./libraries/ortbConverter/converter.js":
/*!**********************************************!*\
  !*** ./libraries/ortbConverter/converter.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultProcessors: () => (/* binding */ defaultProcessors),
/* harmony export */   ortbConverter: () => (/* binding */ ortbConverter)
/* harmony export */ });
/* harmony import */ var _lib_composer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/composer.js */ "./libraries/ortbConverter/lib/composer.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _processors_default_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./processors/default.js */ "./libraries/ortbConverter/processors/default.js");
/* harmony import */ var _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/pbjsORTB.js */ "./src/pbjsORTB.js");
/* harmony import */ var _lib_mergeProcessors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/mergeProcessors.js */ "./libraries/ortbConverter/lib/mergeProcessors.js");





function ortbConverter() {
  let {
    context: defaultContext = {},
    processors = defaultProcessors,
    overrides = {},
    imp,
    request,
    bidResponse,
    response
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const REQ_CTX = new WeakMap();
  function builder(slot, wrapperFn, builderFn, errorHandler) {
    let build;
    return function () {
      if (build == null) {
        build = function () {
          let delegate = builderFn.bind(this, (0,_lib_composer_js__WEBPACK_IMPORTED_MODULE_0__.compose)(processors()[slot] || {}, overrides[slot] || {}));
          if (wrapperFn) {
            delegate = wrapperFn.bind(this, delegate);
          }
          return function () {
            try {
              return delegate.apply(this, arguments);
            } catch (e) {
              errorHandler.call(this, e, ...arguments);
            }
          };
        }();
      }
      return build.apply(this, arguments);
    };
  }
  const buildImp = builder(_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_1__.IMP, imp, function (process, bidRequest, context) {
    const imp = {};
    process(imp, bidRequest, context);
    return imp;
  }, function (error, bidRequest, context) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)('Error while converting bidRequest to ORTB imp; request skipped.', {
      error,
      bidRequest,
      context
    });
  });
  const buildRequest = builder(_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_1__.REQUEST, request, function (process, imps, bidderRequest, context) {
    const ortbRequest = {
      imp: imps
    };
    process(ortbRequest, bidderRequest, context);
    return ortbRequest;
  }, function (error, imps, bidderRequest, context) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)('Error while converting to ORTB request', {
      error,
      imps,
      bidderRequest,
      context
    });
    throw error;
  });
  const buildBidResponse = builder(_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_1__.BID_RESPONSE, bidResponse, function (process, bid, context) {
    const bidResponse = {};
    process(bidResponse, bid, context);
    return bidResponse;
  }, function (error, bid, context) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)('Error while converting ORTB seatbid.bid to bidResponse; bid skipped.', {
      error,
      bid,
      context
    });
  });
  const buildResponse = builder(_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_1__.RESPONSE, response, function (process, bidResponses, ortbResponse, context) {
    const response = {
      bids: bidResponses
    };
    process(response, ortbResponse, context);
    return response;
  }, function (error, bidResponses, ortbResponse, context) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)('Error while converting from ORTB response', {
      error,
      bidResponses,
      ortbResponse,
      context
    });
    throw error;
  });
  return {
    toORTB(_ref) {
      let {
        bidderRequest,
        bidRequests,
        context = {}
      } = _ref;
      bidRequests = bidRequests || bidderRequest.bids;
      const ctx = {
        req: Object.assign({
          bidRequests
        }, defaultContext, context),
        imp: {}
      };
      ctx.req.impContext = ctx.imp;
      const imps = bidRequests.map(bidRequest => {
        const impContext = Object.assign({
          bidderRequest,
          reqContext: ctx.req
        }, defaultContext, context);
        const result = buildImp(bidRequest, impContext);
        if (result != null) {
          if (result.hasOwnProperty('id')) {
            Object.assign(impContext, {
              bidRequest,
              imp: result
            });
            ctx.imp[result.id] = impContext;
            return result;
          }
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)('Converted ORTB imp does not specify an id, ignoring bid request', bidRequest, result);
        }
      }).filter(Boolean);
      const request = buildRequest(imps, bidderRequest, ctx.req);
      ctx.req.bidderRequest = bidderRequest;
      if (request != null) {
        REQ_CTX.set(request, ctx);
      }
      return request;
    },
    fromORTB(_ref2) {
      let {
        request,
        response
      } = _ref2;
      const ctx = REQ_CTX.get(request);
      if (ctx == null) {
        throw new Error('ortbRequest passed to `fromORTB` must be the same object returned by `toORTB`');
      }
      function augmentContext(ctx) {
        let extraParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return Object.assign(ctx, {
          ortbRequest: request
        }, extraParams);
      }
      const impsById = Object.fromEntries((request.imp || []).map(imp => [imp.id, imp]));
      const bidResponses = (response.seatbid || []).flatMap(seatbid => (seatbid.bid || []).map(bid => {
        if (impsById.hasOwnProperty(bid.impid) && ctx.imp.hasOwnProperty(bid.impid)) {
          return buildBidResponse(bid, augmentContext(ctx.imp[bid.impid], {
            imp: impsById[bid.impid],
            seatbid,
            ortbResponse: response
          }));
        }
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)('ORTB response seatbid[].bid[].impid does not match any imp in request; ignoring bid', bid);
      })).filter(Boolean);
      return buildResponse(bidResponses, response, augmentContext(ctx.req));
    }
  };
}
const defaultProcessors = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.memoize)(() => (0,_lib_mergeProcessors_js__WEBPACK_IMPORTED_MODULE_3__.mergeProcessors)(_processors_default_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_PROCESSORS, (0,_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_1__.getProcessors)(_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT)));

/***/ }),

/***/ "./libraries/ortbConverter/lib/composer.js":
/*!*************************************************!*\
  !*** ./libraries/ortbConverter/lib/composer.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compose: () => (/* binding */ compose)
/* harmony export */ });
const SORTED = new WeakMap();

/**
 * @typedef {Object} Component
 * A component function, that can be composed with other compatible functions into one.
 * Compatible functions take the same arguments; return values are ignored.
 *
 * @property {function} fn the component function;
 * @property {number} priority determines the order in which this function will run when composed with others.
 */

/**
 *
 * @param {Object.<string, Component>} components - An object where keys are component names and values are components to compose.
 * @param {Object.<string, (function|boolean)>} overrides - A map from component names to functions that should override those components.
 * Override functions are replacements, except that they get the original function they are overriding as their first argument. If the override
 * is `false`, the component is disabled.
 *
 * @return {function} - A function that will run all components in order of priority, with functions from `overrides` taking
 * precedence over components that match names.
 */
function compose(components) {
  let overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!SORTED.has(components)) {
    const sorted = Object.entries(components);
    sorted.sort((a, b) => {
      a = a[1].priority || 0;
      b = b[1].priority || 0;
      return a === b ? 0 : a > b ? -1 : 1;
    });
    SORTED.set(components, sorted.map(_ref => {
      let [name, cmp] = _ref;
      return [name, cmp.fn];
    }));
  }
  const fns = SORTED.get(components).filter(_ref2 => {
    let [name] = _ref2;
    return !overrides.hasOwnProperty(name) || overrides[name];
  }).map(function (_ref3) {
    let [name, fn] = _ref3;
    return overrides.hasOwnProperty(name) ? overrides[name].bind(this, fn) : fn;
  });
  return function () {
    const args = Array.from(arguments);
    fns.forEach(fn => {
      fn.apply(this, args);
    });
  };
}

/***/ }),

/***/ "./libraries/ortbConverter/lib/mergeProcessors.js":
/*!********************************************************!*\
  !*** ./libraries/ortbConverter/lib/mergeProcessors.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mergeProcessors: () => (/* binding */ mergeProcessors)
/* harmony export */ });
/* harmony import */ var _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/pbjsORTB.js */ "./src/pbjsORTB.js");

function mergeProcessors() {
  for (var _len = arguments.length, processors = new Array(_len), _key = 0; _key < _len; _key++) {
    processors[_key] = arguments[_key];
  }
  const left = processors.shift();
  const right = processors.length > 1 ? mergeProcessors(...processors) : processors[0];
  return Object.fromEntries(_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_0__.PROCESSOR_TYPES.map(type => [type, Object.assign({}, left[type], right[type])]));
}

/***/ }),

/***/ "./libraries/ortbConverter/processors/banner.js":
/*!******************************************************!*\
  !*** ./libraries/ortbConverter/processors/banner.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bannerResponseProcessor: () => (/* binding */ bannerResponseProcessor),
/* harmony export */   fillBannerImp: () => (/* binding */ fillBannerImp)
/* harmony export */ });
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/mediaTypes.js */ "./src/mediaTypes.js");



/**
 * fill in a request `imp` with banner parameters from `bidRequest`.
 */
function fillBannerImp(imp, bidRequest, context) {
  if (context.mediaType && context.mediaType !== _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.BANNER) return;
  const bannerParams = bidRequest?.mediaTypes?.banner;
  if (bannerParams) {
    const banner = {
      topframe: (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.inIframe)() === true ? 0 : 1
    };
    if (bannerParams.sizes && bidRequest.ortb2Imp?.banner?.format == null) {
      banner.format = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.sizesToSizeTuples)(bannerParams.sizes).map(_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.sizeTupleToRtbSize);
    }
    if (bannerParams.hasOwnProperty('pos')) {
      banner.pos = bannerParams.pos;
    }
    imp.banner = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeep)(banner, imp.banner);
  }
}
function bannerResponseProcessor() {
  let {
    createPixel = url => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.createTrackPixelHtml)(decodeURIComponent(url), _src_utils_js__WEBPACK_IMPORTED_MODULE_1__.encodeMacroURI)
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function fillBannerResponse(bidResponse, bid) {
    if (bidResponse.mediaType === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.BANNER) {
      if (bid.adm && bid.nurl) {
        bidResponse.ad = createPixel(bid.nurl) + bid.adm;
      } else if (bid.adm) {
        bidResponse.ad = bid.adm;
      } else if (bid.nurl) {
        bidResponse.adUrl = bid.nurl;
      }
    }
  };
}

/***/ }),

/***/ "./libraries/ortbConverter/processors/default.js":
/*!*******************************************************!*\
  !*** ./libraries/ortbConverter/processors/default.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_PROCESSORS: () => (/* binding */ DEFAULT_PROCESSORS)
/* harmony export */ });
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _banner_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./banner.js */ "./libraries/ortbConverter/processors/banner.js");
/* harmony import */ var _video_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./video.js */ "./libraries/ortbConverter/processors/video.js");
/* harmony import */ var _mediaType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mediaType.js */ "./libraries/ortbConverter/processors/mediaType.js");
/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./native.js */ "./libraries/ortbConverter/processors/native.js");
/* harmony import */ var _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/pbjsORTB.js */ "./src/pbjsORTB.js");
/* harmony import */ var _src_fpd_oneClient_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/fpd/oneClient.js */ "./src/fpd/oneClient.js");







const DEFAULT_PROCESSORS = {
  [_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_0__.REQUEST]: {
    fpd: {
      // sets initial request to bidderRequest.ortb2
      priority: 99,
      fn(ortbRequest, bidderRequest) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeep)(ortbRequest, bidderRequest.ortb2);
      }
    },
    onlyOneClient: {
      // make sure only one of 'dooh', 'app', 'site' is set in request
      priority: -99,
      fn: (0,_src_fpd_oneClient_js__WEBPACK_IMPORTED_MODULE_2__.clientSectionChecker)('ORTB request')
    },
    props: {
      // sets request properties id, tmax, test
      fn(ortbRequest, bidderRequest) {
        Object.assign(ortbRequest, {
          id: ortbRequest.id || (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.generateUUID)(),
          test: ortbRequest.test || 0
        });
        const timeout = parseInt(bidderRequest.timeout, 10);
        if (!isNaN(timeout)) {
          ortbRequest.tmax = timeout;
        }
      }
    }
  },
  [_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_0__.IMP]: {
    fpd: {
      // sets initial imp to bidRequest.ortb2Imp
      priority: 99,
      fn(imp, bidRequest) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeep)(imp, bidRequest.ortb2Imp);
      }
    },
    id: {
      // sets imp.id
      fn(imp, bidRequest) {
        imp.id = bidRequest.bidId;
      }
    },
    banner: {
      // populates imp.banner
      fn: _banner_js__WEBPACK_IMPORTED_MODULE_3__.fillBannerImp
    },
    pbadslot: {
      // removes imp.ext.data.pbaslot if it's not a string
      // TODO: is this needed?
      fn(imp) {
        const pbadslot = imp.ext?.data?.pbadslot;
        if (!pbadslot || typeof pbadslot !== 'string') {
          delete imp.ext?.data?.pbadslot;
        }
      }
    },
    secure: {
      // should set imp.secure to 1 unless publisher has set it
      fn(imp, bidRequest) {
        imp.secure = imp.secure ?? 1;
      }
    }
  },
  [_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_0__.BID_RESPONSE]: {
    mediaType: {
      // sets bidResponse.mediaType from context.mediaType, falling back to seatbid.bid[].mtype
      priority: 99,
      fn: _mediaType_js__WEBPACK_IMPORTED_MODULE_4__.setResponseMediaType
    },
    banner: {
      // sets banner response attributes if bidResponse.mediaType === BANNER
      fn: (0,_banner_js__WEBPACK_IMPORTED_MODULE_3__.bannerResponseProcessor)()
    },
    props: {
      // sets base bidResponse properties common to all types of bids
      fn(bidResponse, bid, context) {
        Object.entries({
          requestId: context.bidRequest?.bidId,
          seatBidId: bid.id,
          cpm: bid.price,
          currency: context.ortbResponse.cur || context.currency,
          width: bid.w,
          height: bid.h,
          wratio: bid.wratio,
          hratio: bid.hratio,
          dealId: bid.dealid,
          creative_id: bid.crid,
          creativeId: bid.crid,
          burl: bid.burl,
          ttl: bid.exp || context.ttl,
          netRevenue: context.netRevenue
        }).filter(_ref => {
          let [k, v] = _ref;
          return typeof v !== 'undefined';
        }).forEach(_ref2 => {
          let [k, v] = _ref2;
          return bidResponse[k] = v;
        });
        if (!bidResponse.meta) {
          bidResponse.meta = {};
        }
        if (bid.adomain) {
          bidResponse.meta.advertiserDomains = bid.adomain;
        }
        if (bid.ext?.dsa) {
          bidResponse.meta.dsa = bid.ext.dsa;
        }
        if (bid.cat) {
          bidResponse.meta.primaryCatId = bid.cat[0];
          bidResponse.meta.secondaryCatIds = bid.cat.slice(1);
        }
        if (bid.attr) {
          bidResponse.meta.attr = bid.attr;
        }
        if (bid.ext?.eventtrackers) {
          bidResponse.eventtrackers = (bidResponse.eventtrackers ?? []).concat(bid.ext.eventtrackers);
        }
      }
    }
  }
};
if (true) {
  DEFAULT_PROCESSORS[_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_0__.IMP].native = {
    // populates imp.native
    fn: _native_js__WEBPACK_IMPORTED_MODULE_5__.fillNativeImp
  };
  DEFAULT_PROCESSORS[_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_0__.BID_RESPONSE].native = {
    // populates bidResponse.native if bidResponse.mediaType === NATIVE
    fn: _native_js__WEBPACK_IMPORTED_MODULE_5__.fillNativeResponse
  };
}
if (true) {
  DEFAULT_PROCESSORS[_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_0__.IMP].video = {
    // populates imp.video
    fn: _video_js__WEBPACK_IMPORTED_MODULE_6__.fillVideoImp
  };
  DEFAULT_PROCESSORS[_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_0__.BID_RESPONSE].video = {
    // sets video response attributes if bidResponse.mediaType === VIDEO
    fn: _video_js__WEBPACK_IMPORTED_MODULE_6__.fillVideoResponse
  };
}

/***/ }),

/***/ "./libraries/ortbConverter/processors/mediaType.js":
/*!*********************************************************!*\
  !*** ./libraries/ortbConverter/processors/mediaType.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ORTB_MTYPES: () => (/* binding */ ORTB_MTYPES),
/* harmony export */   setResponseMediaType: () => (/* binding */ setResponseMediaType)
/* harmony export */ });
/* harmony import */ var _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/mediaTypes.js */ "./src/mediaTypes.js");

const ORTB_MTYPES = {
  1: _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.BANNER,
  2: _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO,
  4: _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE
};

/**
 * Sets response mediaType, using ORTB 2.6 `seatbid.bid[].mtype`.
 *
 * Note that this will throw away bids if there is no `mtype` in the response.
 */
function setResponseMediaType(bidResponse, bid, context) {
  if (bidResponse.mediaType) return;
  const mediaType = context.mediaType;
  if (!mediaType && !ORTB_MTYPES.hasOwnProperty(bid.mtype)) {
    throw new Error('Cannot determine mediaType for response');
  }
  bidResponse.mediaType = mediaType || ORTB_MTYPES[bid.mtype];
}

/***/ }),

/***/ "./libraries/ortbConverter/processors/native.js":
/*!******************************************************!*\
  !*** ./libraries/ortbConverter/processors/native.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fillNativeImp: () => (/* binding */ fillNativeImp),
/* harmony export */   fillNativeResponse: () => (/* binding */ fillNativeResponse)
/* harmony export */ });
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/mediaTypes.js */ "./src/mediaTypes.js");


function fillNativeImp(imp, bidRequest, context) {
  if (context.mediaType && context.mediaType !== _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE) return;
  let nativeReq = bidRequest.nativeOrtbRequest;
  if (nativeReq) {
    nativeReq = Object.assign({}, context.nativeRequest, nativeReq);
    if (nativeReq.assets?.length) {
      imp.native = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeep)({}, {
        request: JSON.stringify(nativeReq),
        ver: nativeReq.ver
      }, imp.native);
    } else {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)('mediaTypes.native is set, but no assets were specified. Native request skipped.', bidRequest);
    }
  }
}
function fillNativeResponse(bidResponse, bid) {
  if (bidResponse.mediaType === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE) {
    let ortb;
    if (typeof bid.adm === 'string') {
      ortb = JSON.parse(bid.adm);
    } else {
      ortb = bid.adm;
    }
    if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(ortb) && Array.isArray(ortb.assets)) {
      bidResponse.native = {
        ortb
      };
    } else {
      throw new Error('ORTB native response contained no assets');
    }
  }
}

/***/ }),

/***/ "./libraries/ortbConverter/processors/video.js":
/*!*****************************************************!*\
  !*** ./libraries/ortbConverter/processors/video.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fillVideoImp: () => (/* binding */ fillVideoImp),
/* harmony export */   fillVideoResponse: () => (/* binding */ fillVideoResponse)
/* harmony export */ });
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/mediaTypes.js */ "./src/mediaTypes.js");
/* harmony import */ var _src_video_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/video.js */ "./src/video.js");



function fillVideoImp(imp, bidRequest, context) {
  if (context.mediaType && context.mediaType !== _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO) return;
  const videoParams = bidRequest?.mediaTypes?.video;
  if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(videoParams)) {
    const video = Object.fromEntries(
    // Parameters that share the same name & semantics between pbjs adUnits and imp.video
    Object.entries(videoParams).filter(_ref => {
      let [name] = _ref;
      return _src_video_js__WEBPACK_IMPORTED_MODULE_2__.ORTB_VIDEO_PARAMS.has(name);
    }));
    if (videoParams.playerSize) {
      const format = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.sizesToSizeTuples)(videoParams.playerSize).map(_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.sizeTupleToRtbSize);
      if (format.length > 1) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)('video request specifies more than one playerSize; all but the first will be ignored');
      }
      Object.assign(video, format[0]);
    }
    imp.video = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeep)(video, imp.video);
  }
}
function fillVideoResponse(bidResponse, seatbid, context) {
  if (bidResponse.mediaType === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO) {
    if (context?.imp?.video?.w && context?.imp?.video?.h) {
      [bidResponse.playerWidth, bidResponse.playerHeight] = [context.imp.video.w, context.imp.video.h];
    }
    if (seatbid.adm) {
      bidResponse.vastXml = seatbid.adm;
    }
    if (seatbid.nurl) {
      bidResponse.vastUrl = seatbid.nurl;
    }
  }
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["timeoutQueue"],{

/***/ "./libraries/timeoutQueue/timeoutQueue.js":
/*!************************************************!*\
  !*** ./libraries/timeoutQueue/timeoutQueue.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   timeoutQueue: () => (/* binding */ timeoutQueue)
/* harmony export */ });
function timeoutQueue() {
  const queue = [];
  return {
    submit(timeout, onResume, onTimeout) {
      const item = [onResume, setTimeout(() => {
        queue.splice(queue.indexOf(item), 1);
        onTimeout();
      }, timeout)];
      queue.push(item);
    },
    resume() {
      while (queue.length) {
        const [onResume, timerId] = queue.shift();
        clearTimeout(timerId);
        onResume();
      }
    }
  };
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["gptUtils"],{

/***/ "./libraries/gptUtils/gptUtils.js":
/*!****************************************!*\
  !*** ./libraries/gptUtils/gptUtils.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGptSlotInfoForAdUnitCode: () => (/* binding */ getGptSlotInfoForAdUnitCode),
/* harmony export */   getSegments: () => (/* binding */ getSegments),
/* harmony export */   getSignals: () => (/* binding */ getSignals),
/* harmony export */   taxonomies: () => (/* binding */ taxonomies)
/* harmony export */ });
/* unused harmony exports isSlotMatchingAdUnitCode, setKeyValue, getGptSlotForAdUnitCode, subscribeToGamEvent, subscribeToGamSlotRenderEndedEvent */
/* harmony import */ var _src_fpd_oneClient_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/fpd/oneClient.js */ "./src/fpd/oneClient.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/utils.js */ "./node_modules/dlv/index.js");



/**
 * Returns filter function to match adUnitCode in slot
 * @param {string} adUnitCode AdUnit code
 * @return {function} filter function
 */
function isSlotMatchingAdUnitCode(adUnitCode) {
  return slot => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.compareCodeAndSlot)(slot, adUnitCode);
}

/**
 * @summary Export a k-v pair to GAM
 */
function setKeyValue(key, value) {
  if (!key || typeof key !== 'string') return false;
  window.googletag = window.googletag || {
    cmd: []
  };
  window.googletag.cmd = window.googletag.cmd || [];
  window.googletag.cmd.push(() => {
    window.googletag.pubads().setTargeting(key, value);
  });
}

/**
 * @summary Uses the adUnit's code in order to find a matching gpt slot object on the page
 */
function getGptSlotForAdUnitCode(adUnitCode) {
  let matchingSlot;
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isGptPubadsDefined)()) {
    // find the first matching gpt slot on the page
    matchingSlot = window.googletag.pubads().getSlots().find(isSlotMatchingAdUnitCode(adUnitCode));
  }
  return matchingSlot;
}

/**
 * @summary Uses the adUnit's code in order to find a matching gptSlot on the page
 */
function getGptSlotInfoForAdUnitCode(adUnitCode) {
  const matchingSlot = getGptSlotForAdUnitCode(adUnitCode);
  if (matchingSlot) {
    return {
      gptSlot: matchingSlot.getAdUnitPath(),
      divId: matchingSlot.getSlotElementId()
    };
  }
  return {};
}
const taxonomies = ['IAB_AUDIENCE_1_1', 'IAB_CONTENT_2_2'];
function getSignals(fpd) {
  const signals = Object.entries({
    [taxonomies[0]]: getSegments(fpd, ['user.data'], 4),
    [taxonomies[1]]: getSegments(fpd, _src_fpd_oneClient_js__WEBPACK_IMPORTED_MODULE_1__.CLIENT_SECTIONS.map(section => `${section}.content.data`), 6)
  }).map(_ref => {
    let [taxonomy, values] = _ref;
    return values.length ? {
      taxonomy,
      values
    } : null;
  }).filter(ob => ob);
  return signals;
}
function getSegments(fpd, sections, segtax) {
  return sections.flatMap(section => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fpd, section) || []).filter(datum => datum.ext?.segtax === segtax).flatMap(datum => datum.segment?.map(seg => seg.id)).filter(ob => ob).filter(_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.uniques);
}

/**
 * Add an event listener on the given GAM event.
 * If GPT Pubads isn't defined, window.googletag is set to a new object.
 * @param {String} event
 * @param {Function} callback
 */
function subscribeToGamEvent(event, callback) {
  const register = () => window.googletag.pubads().addEventListener(event, callback);
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isGptPubadsDefined)()) {
    register();
    return;
  }
  window.googletag = window.googletag || {};
  window.googletag.cmd = window.googletag.cmd || [];
  window.googletag.cmd.push(register);
}

/**
 * @typedef {Object} Slot
 * @property {function(String): (String|null)} get
 * @property {function(): String} getAdUnitPath
 * @property {function(): String[]} getAttributeKeys
 * @property {function(): String[]} getCategoryExclusions
 * @property {function(String): String} getSlotElementId
 * @property {function(): String[]} getTargeting
 * @property {function(): String[]} getTargetingKeys
 * @see {@link https://developers.google.com/publisher-tag/reference#googletag.Slot GPT official docs}
 */

/**
 * @typedef {Object} SlotRenderEndedEvent
 * @property {(String|null)} advertiserId
 * @property {(String|null)} campaignId
 * @property {(String[]|null)} companyIds
 * @property {(Number|null)} creativeId
 * @property {(Number|null)} creativeTemplateId
 * @property {(Boolean)} isBackfill
 * @property {(Boolean)} isEmpty
 * @property {(Number[]|null)} labelIds
 * @property {(Number|null)} lineItemId
 * @property {(String)} serviceName
 * @property {(string|Number[]|null)} size
 * @property {(Slot)} slot
 * @property {(Boolean)} slotContentChanged
 * @property {(Number|null)} sourceAgnosticCreativeId
 * @property {(Number|null)} sourceAgnosticLineItemId
 * @property {(Number[]|null)} yieldGroupIds
 * @see {@link https://developers.google.com/publisher-tag/reference#googletag.events.SlotRenderEndedEvent GPT official docs}
 */

/**
 * @callback SlotRenderEndedEventCallback
 * @param {SlotRenderEndedEvent} event
 * @returns {void}
 */

/**
 * Add an event listener on the GAM event 'slotRenderEnded'.
 * @param {SlotRenderEndedEventCallback} callback
 */
function subscribeToGamSlotRenderEndedEvent(callback) {
  subscribeToGamEvent('slotRenderEnded', callback);
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["xmlUtils"],{

/***/ "./libraries/xmlUtils/xmlUtils.js":
/*!****************************************!*\
  !*** ./libraries/xmlUtils/xmlUtils.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ XMLUtil)
/* harmony export */ });
const XML_MIME_TYPE = 'application/xml';
function XMLUtil() {
  let parser;
  let serializer;
  function getParser() {
    if (!parser) {
      // DOMParser instantiation is costly; instantiate only once throughout Prebid lifecycle.
      parser = new DOMParser();
    }
    return parser;
  }
  function getSerializer() {
    if (!serializer) {
      // XMLSerializer instantiation is costly; instantiate only once throughout Prebid lifecycle.
      serializer = new XMLSerializer();
    }
    return serializer;
  }
  function parse(xmlString) {
    return getParser().parseFromString(xmlString, XML_MIME_TYPE);
  }
  function serialize(xmlDoc) {
    return getSerializer().serializeToString(xmlDoc);
  }
  return {
    parse,
    serialize
  };
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["dfpUtils"],{

/***/ "./libraries/dfpUtils/dfpUtils.js":
/*!****************************************!*\
  !*** ./libraries/dfpUtils/dfpUtils.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_DFP_PARAMS: () => (/* binding */ DEFAULT_DFP_PARAMS),
/* harmony export */   DFP_ENDPOINT: () => (/* binding */ DFP_ENDPOINT),
/* harmony export */   gdprParams: () => (/* binding */ gdprParams)
/* harmony export */ });
/* harmony import */ var _src_consentHandler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/consentHandler.js */ "./src/consentHandler.js");


/** Safe defaults which work on pretty much all video calls. */
const DEFAULT_DFP_PARAMS = {
  env: 'vp',
  gdfp_req: 1,
  output: 'vast',
  unviewed_position_start: 1
};
const DFP_ENDPOINT = {
  protocol: 'https',
  host: 'securepubads.g.doubleclick.net',
  pathname: '/gampad/ads'
};
function gdprParams() {
  const gdprConsent = _src_consentHandler_js__WEBPACK_IMPORTED_MODULE_0__.gdprDataHandler.getConsentData();
  const params = {};
  if (gdprConsent) {
    if (typeof gdprConsent.gdprApplies === 'boolean') {
      params.gdpr = Number(gdprConsent.gdprApplies);
    }
    if (gdprConsent.consentString) {
      params.gdpr_consent = gdprConsent.consentString;
    }
    if (gdprConsent.addtlConsent) {
      params.addtl_consent = gdprConsent.addtlConsent;
    }
  }
  return params;
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["mspa"],{

/***/ "./libraries/mspa/activityControls.js":
/*!********************************************!*\
  !*** ./libraries/mspa/activityControls.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setupRules: () => (/* binding */ setupRules)
/* harmony export */ });
/* unused harmony exports isBasicConsentDenied, sensitiveNoticeIs, isConsentDenied, isTransmitUfpdConsentDenied, isTransmitGeoConsentDenied, mspaRule */
/* harmony import */ var _src_activities_rules_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/activities/rules.js */ "./src/activities/rules.js");
/* harmony import */ var _src_activities_activities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/activities/activities.js */ "./src/activities/activities.js");
/* harmony import */ var _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/adapterManager.js */ "./src/consentHandler.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");





// default interpretation for MSPA consent(s):
// https://docs.prebid.org/features/mspa-usnat.html

const SENSITIVE_DATA_GEO = 7;
function isApplicable(val) {
  return val != null && val !== 0;
}
function isBasicConsentDenied(cd) {
  // service provider mode is always consent denied
  return ['MspaServiceProviderMode', 'Gpc'].some(prop => cd[prop] === 1) ||
  // you cannot consent to what you were not notified of
  cd.PersonalDataConsents === 2 ||
  // minors 13+ who have not given consent
  cd.KnownChildSensitiveDataConsents[0] === 1 ||
  // minors 16+ who have not given consent (added in usnat version 2)
  cd.KnownChildSensitiveDataConsents[2] === 1 ||
  // minors under 13 cannot consent
  isApplicable(cd.KnownChildSensitiveDataConsents[1]) ||
  // covered cannot be zero
  cd.MspaCoveredTransaction === 0;
}
function sensitiveNoticeIs(cd, value) {
  return ['SensitiveDataProcessingOptOutNotice', 'SensitiveDataLimitUseNotice'].some(prop => cd[prop] === value);
}
function isConsentDenied(cd) {
  return isBasicConsentDenied(cd) || ['Sale', 'Sharing', 'TargetedAdvertising'].some(scope => {
    const oo = cd[`${scope}OptOut`];
    const notice = cd[`${scope}OptOutNotice`];
    // user opted out
    return oo === 1 ||
    // opt-out notice was not given
    notice === 2 ||
    // do not trust CMP if it signals opt-in but no opt-out notice was given
    oo === 2 && notice === 0;
  }) ||
  // no sharing notice was given ...
  cd.SharingNotice === 2 ||
  // ... or the CMP says it was not applicable, while also claiming it got consent
  cd.SharingOptOut === 2 && cd.SharingNotice === 0;
}
const isTransmitUfpdConsentDenied = (() => {
  const sensitiveFlags = (() => {
    // deny anything that smells like: genetic, biometric, state/national ID, financial, union membership,
    // personal communication data, status as victim of crime (version 2), status as transgender/nonbinary (version 2)
    const cannotBeInScope = [6, 7, 9, 10, 12, 14, 16].map(el => --el);
    // require consent for everything else (except geo, which is treated separately)
    const allExceptGeo = Array.from(Array(16).keys()).filter(el => el !== SENSITIVE_DATA_GEO);
    const mustHaveConsent = allExceptGeo.filter(el => !cannotBeInScope.includes(el));
    return Object.fromEntries(Object.entries({
      1: 12,
      2: 16
    }).map(_ref => {
      let [version, cardinality] = _ref;
      const isInVersion = el => el < cardinality;
      return [version, {
        cannotBeInScope: cannotBeInScope.filter(isInVersion),
        allExceptGeo: allExceptGeo.filter(isInVersion),
        mustHaveConsent: mustHaveConsent.filter(isInVersion)
      }];
    }));
  })();
  return function (cd) {
    const {
      cannotBeInScope,
      mustHaveConsent,
      allExceptGeo
    } = sensitiveFlags[cd.Version];
    return isConsentDenied(cd) ||
    // no notice about sensitive data was given
    sensitiveNoticeIs(cd, 2) ||
    // extra-sensitive data is applicable
    cannotBeInScope.some(i => isApplicable(cd.SensitiveDataProcessing[i])) ||
    // user opted out for not-as-sensitive data
    mustHaveConsent.some(i => cd.SensitiveDataProcessing[i] === 1) ||
    // CMP says it has consent, but did not give notice about it
    sensitiveNoticeIs(cd, 0) && allExceptGeo.some(i => cd.SensitiveDataProcessing[i] === 2);
  };
})();
function isTransmitGeoConsentDenied(cd) {
  const geoConsent = cd.SensitiveDataProcessing[SENSITIVE_DATA_GEO];
  return geoConsent === 1 || isBasicConsentDenied(cd) ||
  // no sensitive data notice was given
  sensitiveNoticeIs(cd, 2) ||
  // do not trust CMP if it says it has consent for geo but didn't show a sensitive data notice
  sensitiveNoticeIs(cd, 0) && geoConsent === 2;
}
const CONSENT_RULES = {
  [_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_0__.ACTIVITY_SYNC_USER]: isConsentDenied,
  [_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_0__.ACTIVITY_ENRICH_EIDS]: isConsentDenied,
  [_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_0__.ACTIVITY_ENRICH_UFPD]: isTransmitUfpdConsentDenied,
  [_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_0__.ACTIVITY_TRANSMIT_PRECISE_GEO]: isTransmitGeoConsentDenied
};
function mspaRule(sids, getConsent, denies) {
  let applicableSids = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_1__.gppDataHandler.getConsentData()?.applicableSections;
  return function () {
    if (applicableSids().some(sid => sids.includes(sid))) {
      const consent = getConsent();
      if (consent == null) {
        return {
          allow: false,
          reason: 'consent data not available'
        };
      }
      if (![1, 2].includes(consent.Version)) {
        return {
          allow: false,
          reason: `unsupported consent specification version "${consent.Version}"`
        };
      }
      if (denies(consent)) {
        return {
          allow: false
        };
      }
    }
  };
}
function flatSection(subsections) {
  if (!Array.isArray(subsections)) return subsections;
  return subsections.reduceRight((subsection, consent) => {
    return Object.assign(consent, subsection);
  }, {});
}
function setupRules(api, sids) {
  let normalizeConsent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : c => c;
  let rules = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : CONSENT_RULES;
  let registerRule = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _src_activities_rules_js__WEBPACK_IMPORTED_MODULE_2__.registerActivityControl;
  let getConsentData = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : () => _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_1__.gppDataHandler.getConsentData();
  const unreg = [];
  const ruleName = `MSPA (GPP '${api}' for section${sids.length > 1 ? 's' : ''} ${sids.join(', ')})`;
  (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logInfo)(`Enabling activity controls for ${ruleName}`);
  Object.entries(rules).forEach(_ref2 => {
    let [activity, denies] = _ref2;
    unreg.push(registerRule(activity, ruleName, mspaRule(sids, () => normalizeConsent(flatSection(getConsentData()?.parsedSections?.[api])), denies, () => getConsentData()?.applicableSections || [])));
  });
  return () => unreg.forEach(ur => ur());
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["currencyUtils"],{

/***/ "./libraries/currencyUtils/currency.js":
/*!*********************************************!*\
  !*** ./libraries/currencyUtils/currency.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertCurrency: () => (/* binding */ convertCurrency),
/* harmony export */   currencyCompare: () => (/* binding */ currencyCompare)
/* harmony export */ });
/* unused harmony export currencyNormalizer */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_utils_reducers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/utils/reducers.js */ "./src/utils/reducers.js");



/**
 * Attempt to convert `amount` from the currency `fromCur` to the currency `toCur`.
 *
 * By default, when the conversion is not possible (currency module not present or
 * throwing errors), the amount is returned unchanged. This behavior can be
 * toggled off with bestEffort = false.
 */
function convertCurrency(amount, fromCur, toCur) {
  let bestEffort = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  if (fromCur === toCur) return amount;
  let result = amount;
  try {
    result = (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_0__.getGlobal)().convertCurrency(amount, fromCur, toCur);
  } catch (e) {
    if (!bestEffort) throw e;
  }
  return result;
}
function currencyNormalizer() {
  let toCurrency = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  let bestEffort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  let convert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : convertCurrency;
  return function (amount, currency) {
    if (toCurrency == null) toCurrency = currency;
    return convert(amount, currency, toCurrency, bestEffort);
  };
}
function currencyCompare() {
  let get = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : obj => [obj.cpm, obj.currency];
  let normalize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currencyNormalizer();
  return (0,_src_utils_reducers_js__WEBPACK_IMPORTED_MODULE_1__.keyCompare)(obj => normalize.apply(null, get(obj)));
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["weakStore"],{

/***/ "./libraries/weakStore/weakStore.js":
/*!******************************************!*\
  !*** ./libraries/weakStore/weakStore.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   auctionStore: () => (/* binding */ auctionStore)
/* harmony export */ });
/* unused harmony export weakStore */
/* harmony import */ var _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/auctionManager.js */ "./src/auctionManager.js");

function weakStore(get) {
  const store = new WeakMap();
  return function (id) {
    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const obj = get(id);
    if (obj == null) return;
    if (!store.has(obj)) {
      store.set(obj, init);
    }
    return store.get(obj);
  };
}
const auctionStore = () => weakStore(auctionId => _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_0__.auctionManager.index.getAuction({
  auctionId
}));

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["pbsExtensions"],{

/***/ "./libraries/pbsExtensions/pbsExtensions.js":
/*!**************************************************!*\
  !*** ./libraries/pbsExtensions/pbsExtensions.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pbsExtensions: () => (/* binding */ pbsExtensions)
/* harmony export */ });
/* harmony import */ var _ortbConverter_lib_mergeProcessors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ortbConverter/lib/mergeProcessors.js */ "./libraries/ortbConverter/lib/mergeProcessors.js");
/* harmony import */ var _processors_pbs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./processors/pbs.js */ "./libraries/pbsExtensions/processors/pbs.js");
/* harmony import */ var _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../src/pbjsORTB.js */ "./src/pbjsORTB.js");
/* harmony import */ var _ortbConverter_converter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ortbConverter/converter.js */ "./libraries/ortbConverter/converter.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");






/**
 * ORTB converter processor set that understands Prebid Server extensions.
 *
 * Pass this as the `processors` option to `ortbConverter` if your backend is a PBS instance.
 */
const pbsExtensions = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoize)(() => (0,_ortbConverter_lib_mergeProcessors_js__WEBPACK_IMPORTED_MODULE_1__.mergeProcessors)((0,_ortbConverter_converter_js__WEBPACK_IMPORTED_MODULE_2__.defaultProcessors)(), _processors_pbs_js__WEBPACK_IMPORTED_MODULE_3__.PBS_PROCESSORS, (0,_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_4__.getProcessors)(_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_4__.PBS)));

/***/ }),

/***/ "./libraries/pbsExtensions/processors/adUnitCode.js":
/*!**********************************************************!*\
  !*** ./libraries/pbsExtensions/processors/adUnitCode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setImpAdUnitCode: () => (/* binding */ setImpAdUnitCode)
/* harmony export */ });
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/utils.js */ "./node_modules/dset/dist/index.mjs");

function setImpAdUnitCode(imp, bidRequest) {
  const adUnitCode = bidRequest.adUnitCode;
  if (adUnitCode) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.dset)(imp, `ext.prebid.adunitcode`, adUnitCode);
  }
}

/***/ }),

/***/ "./libraries/pbsExtensions/processors/aliases.js":
/*!*******************************************************!*\
  !*** ./libraries/pbsExtensions/processors/aliases.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setRequestExtPrebidAliases: () => (/* binding */ setRequestExtPrebidAliases)
/* harmony export */ });
/* harmony import */ var _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/adapterManager.js */ "./src/adapterManager.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/config.js */ "./src/config.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/utils.js */ "./node_modules/dset/dist/index.mjs");



function setRequestExtPrebidAliases(ortbRequest, bidderRequest, context) {
  let {
    am = _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  if (am.aliasRegistry[bidderRequest.bidderCode]) {
    const bidder = am.bidderRegistry[bidderRequest.bidderCode];
    // adding alias only if alias source bidder exists and alias isn't configured to be standalone
    // pbs adapter
    if (!bidder || !bidder.getSpec().skipPbsAliasing) {
      // set alias
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.dset)(ortbRequest, `ext.prebid.aliases.${bidderRequest.bidderCode}`, am.aliasRegistry[bidderRequest.bidderCode]);

      // set alias gvlids if present also
      const gvlId = _src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig(`gvlMapping.${bidderRequest.bidderCode}`) || bidder?.getSpec?.().gvlid;
      if (gvlId) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.dset)(ortbRequest, `ext.prebid.aliasgvlids.${bidderRequest.bidderCode}`, gvlId);
      }
    }
  }
}

/***/ }),

/***/ "./libraries/pbsExtensions/processors/eventTrackers.js":
/*!*************************************************************!*\
  !*** ./libraries/pbsExtensions/processors/eventTrackers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addEventTrackers: () => (/* binding */ addEventTrackers)
/* harmony export */ });
/* harmony import */ var _src_eventTrackers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/eventTrackers.js */ "./src/eventTrackers.js");

function addEventTrackers(bidResponse, bid) {
  bidResponse.eventtrackers = bidResponse.eventtrackers || [];
  [[bid.burl, _src_eventTrackers_js__WEBPACK_IMPORTED_MODULE_0__.EVENT_TYPE_IMPRESSION],
  // core used to fire burl directly, but only for bids coming from PBS
  [bid?.ext?.prebid?.events?.win, _src_eventTrackers_js__WEBPACK_IMPORTED_MODULE_0__.EVENT_TYPE_WIN]].filter(_ref => {
    let [winUrl, type] = _ref;
    return winUrl && bidResponse.eventtrackers.find(_ref2 => {
      let {
        method,
        event,
        url
      } = _ref2;
      return event === type && method === _src_eventTrackers_js__WEBPACK_IMPORTED_MODULE_0__.TRACKER_METHOD_IMG && url === winUrl;
    }) == null;
  }).forEach(_ref3 => {
    let [url, event] = _ref3;
    bidResponse.eventtrackers.push({
      method: _src_eventTrackers_js__WEBPACK_IMPORTED_MODULE_0__.TRACKER_METHOD_IMG,
      event,
      url
    });
  });
}

/***/ }),

/***/ "./libraries/pbsExtensions/processors/mediaType.js":
/*!*********************************************************!*\
  !*** ./libraries/pbsExtensions/processors/mediaType.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SUPPORTED_MEDIA_TYPES: () => (/* binding */ SUPPORTED_MEDIA_TYPES),
/* harmony export */   extPrebidMediaType: () => (/* binding */ extPrebidMediaType)
/* harmony export */ });
/* harmony import */ var _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/mediaTypes.js */ "./src/mediaTypes.js");
/* harmony import */ var _ortbConverter_processors_mediaType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ortbConverter/processors/mediaType.js */ "./libraries/ortbConverter/processors/mediaType.js");


const SUPPORTED_MEDIA_TYPES = {
  // map from pbjs mediaType to its corresponding imp property
  [_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.BANNER]: 'banner',
  [_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE]: 'native',
  [_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO]: 'video'
};

/**
 * Sets bidResponse.mediaType, using ORTB 2.6 `seatbid.bid[].mtype`, falling back to `ext.prebid.type`, falling back to 'banner'.
 */
function extPrebidMediaType(bidResponse, bid, context) {
  let mediaType = context.mediaType;
  if (!mediaType) {
    mediaType = _ortbConverter_processors_mediaType_js__WEBPACK_IMPORTED_MODULE_1__.ORTB_MTYPES.hasOwnProperty(bid.mtype) ? _ortbConverter_processors_mediaType_js__WEBPACK_IMPORTED_MODULE_1__.ORTB_MTYPES[bid.mtype] : bid.ext?.prebid?.type;
    if (!SUPPORTED_MEDIA_TYPES.hasOwnProperty(mediaType)) {
      mediaType = _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.BANNER;
    }
  }
  bidResponse.mediaType = mediaType;
}

/***/ }),

/***/ "./libraries/pbsExtensions/processors/params.js":
/*!******************************************************!*\
  !*** ./libraries/pbsExtensions/processors/params.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setImpBidParams: () => (/* binding */ setImpBidParams)
/* harmony export */ });
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/utils.js */ "./node_modules/dset/dist/index.mjs");

function setImpBidParams(imp, bidRequest) {
  let params = bidRequest.params;
  if (params) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.dset)(imp, `ext.prebid.bidder.${bidRequest.bidder}`, params);
  }
}

/***/ }),

/***/ "./libraries/pbsExtensions/processors/pbs.js":
/*!***************************************************!*\
  !*** ./libraries/pbsExtensions/processors/pbs.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PBS_PROCESSORS: () => (/* binding */ PBS_PROCESSORS)
/* harmony export */ });
/* harmony import */ var _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/pbjsORTB.js */ "./src/pbjsORTB.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../src/utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _mediaType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mediaType.js */ "./libraries/pbsExtensions/processors/mediaType.js");
/* harmony import */ var _aliases_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./aliases.js */ "./libraries/pbsExtensions/processors/aliases.js");
/* harmony import */ var _params_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./params.js */ "./libraries/pbsExtensions/processors/params.js");
/* harmony import */ var _adUnitCode_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./adUnitCode.js */ "./libraries/pbsExtensions/processors/adUnitCode.js");
/* harmony import */ var _requestExtPrebid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./requestExtPrebid.js */ "./libraries/pbsExtensions/processors/requestExtPrebid.js");
/* harmony import */ var _video_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./video.js */ "./libraries/pbsExtensions/processors/video.js");
/* harmony import */ var _eventTrackers_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./eventTrackers.js */ "./libraries/pbsExtensions/processors/eventTrackers.js");









const PBS_PROCESSORS = {
  [_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_0__.REQUEST]: {
    extPrebid: {
      // set request.ext.prebid.auctiontimestamp, .debug and .targeting
      fn: _requestExtPrebid_js__WEBPACK_IMPORTED_MODULE_1__.setRequestExtPrebid
    },
    extPrebidChannel: {
      // sets request.ext.prebid.channel
      fn: _requestExtPrebid_js__WEBPACK_IMPORTED_MODULE_1__.setRequestExtPrebidChannel
    },
    extPrebidAliases: {
      // sets ext.prebid.aliases
      fn: _aliases_js__WEBPACK_IMPORTED_MODULE_2__.setRequestExtPrebidAliases
    }
  },
  [_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_0__.IMP]: {
    params: {
      // sets bid ext.prebid.bidder.[bidderCode] with bidRequest.params, passed through transformBidParams if necessary
      fn: _params_js__WEBPACK_IMPORTED_MODULE_3__.setImpBidParams
    },
    adUnitCode: {
      // sets bid ext.prebid.adunitcode
      fn: _adUnitCode_js__WEBPACK_IMPORTED_MODULE_4__.setImpAdUnitCode
    }
  },
  [_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_0__.BID_RESPONSE]: {
    mediaType: {
      // sets bidResponse.mediaType according to context.mediaType, falling back to imp.ext.prebid.type
      fn: _mediaType_js__WEBPACK_IMPORTED_MODULE_5__.extPrebidMediaType,
      priority: 99
    },
    videoCache: {
      // sets response video attributes; in addition, looks at ext.prebid.cache and .targeting to set video cache key and URL
      fn: _video_js__WEBPACK_IMPORTED_MODULE_6__.setBidResponseVideoCache,
      priority: -10 // after 'video'
    },
    bidderCode: {
      // sets bidderCode from on seatbid.seat
      fn(bidResponse, bid, context) {
        bidResponse.bidderCode = context.seatbid.seat;
        bidResponse.adapterCode = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__["default"])(bid, 'ext.prebid.meta.adaptercode') || context.bidRequest?.bidder || bidResponse.bidderCode;
      }
    },
    pbsBidId: {
      // sets bidResponse.pbsBidId from ext.prebid.bidid
      fn(bidResponse, bid) {
        const bidId = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__["default"])(bid, 'ext.prebid.bidid');
        if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_8__.isStr)(bidId)) {
          bidResponse.pbsBidId = bidId;
        }
      }
    },
    adserverTargeting: {
      // sets bidResponse.adserverTargeting from ext.prebid.targeting
      fn(bidResponse, bid) {
        const targeting = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__["default"])(bid, 'ext.prebid.targeting');
        if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_8__.isPlainObject)(targeting)) {
          bidResponse.adserverTargeting = targeting;
        }
      }
    },
    extPrebidMeta: {
      // sets bidResponse.meta from ext.prebid.meta
      fn(bidResponse, bid) {
        bidResponse.meta = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_8__.mergeDeep)({}, (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__["default"])(bid, 'ext.prebid.meta'), bidResponse.meta);
      }
    },
    pbsWinTrackers: {
      // converts "legacy" burl and ext.prebid.events.win into eventtrackers
      fn: _eventTrackers_js__WEBPACK_IMPORTED_MODULE_9__.addEventTrackers
    }
  },
  [_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_0__.RESPONSE]: {
    serverSideStats: {
      // updates bidderRequest and bidRequests with serverErrors from ext.errors and serverResponseTimeMs from ext.responsetimemillis
      fn(response, ortbResponse, context) {
        Object.entries({
          errors: 'serverErrors',
          responsetimemillis: 'serverResponseTimeMs'
        }).forEach(_ref => {
          let [serverName, clientName] = _ref;
          const value = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__["default"])(ortbResponse, `ext.${serverName}.${context.bidderRequest.bidderCode}`);
          if (value) {
            context.bidderRequest[clientName] = value;
            context.bidRequests.forEach(bid => bid[clientName] = value);
          }
        });
      }
    }
  }
};

/***/ }),

/***/ "./libraries/pbsExtensions/processors/requestExtPrebid.js":
/*!****************************************************************!*\
  !*** ./libraries/pbsExtensions/processors/requestExtPrebid.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setRequestExtPrebid: () => (/* binding */ setRequestExtPrebid),
/* harmony export */   setRequestExtPrebidChannel: () => (/* binding */ setRequestExtPrebidChannel)
/* harmony export */ });
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/config.js */ "./src/config.js");
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/prebidGlobal.js */ "./src/prebidGlobal.js");



function setRequestExtPrebid(ortbRequest, bidderRequest) {
  (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.dset)(ortbRequest, 'ext.prebid', (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeep)({
    auctiontimestamp: bidderRequest.auctionStart,
    targeting: {
      includewinners: true,
      includebidderkeys: false
    }
  }, ortbRequest.ext?.prebid));
  if (_src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('debug')) {
    ortbRequest.ext.prebid.debug = true;
  }
}
function setRequestExtPrebidChannel(ortbRequest) {
  (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.dset)(ortbRequest, 'ext.prebid.channel', Object.assign({
    name: 'pbjs',
    version: (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_3__.getGlobal)().version
  }, ortbRequest.ext?.prebid?.channel));
}

/***/ }),

/***/ "./libraries/pbsExtensions/processors/video.js":
/*!*****************************************************!*\
  !*** ./libraries/pbsExtensions/processors/video.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setBidResponseVideoCache: () => (/* binding */ setBidResponseVideoCache)
/* harmony export */ });
/* harmony import */ var _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../src/mediaTypes.js */ "./src/mediaTypes.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/utils.js */ "./node_modules/dlv/index.js");


function setBidResponseVideoCache(bidResponse, bid) {
  if (bidResponse.mediaType === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO) {
    // try to get cache values from 'response.ext.prebid.cache'
    // else try 'bid.ext.prebid.targeting' as fallback
    let {
      cacheId: videoCacheKey,
      url: vastUrl
    } = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bid, 'ext.prebid.cache.vastXml') || {};
    if (!videoCacheKey || !vastUrl) {
      const {
        hb_uuid: uuid,
        hb_cache_host: cacheHost,
        hb_cache_path: cachePath
      } = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bid, 'ext.prebid.targeting') || {};
      if (uuid && cacheHost && cachePath) {
        videoCacheKey = uuid;
        vastUrl = `https://${cacheHost}${cachePath}?uuid=${uuid}`;
      }
    }
    if (videoCacheKey && vastUrl) {
      Object.assign(bidResponse, {
        videoCacheKey,
        vastUrl
      });
    }
  }
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["domainOverrideToRootDomain"],{

/***/ "./libraries/domainOverrideToRootDomain/index.js":
/*!*******************************************************!*\
  !*** ./libraries/domainOverrideToRootDomain/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   domainOverrideToRootDomain: () => (/* binding */ domainOverrideToRootDomain)
/* harmony export */ });
/**
 * Create a domainOverride callback for an ID module, closing over
 * an instance of StorageManager.
 *
 * The domainOverride function, given document.domain, will return
 * the topmost domain we are able to set a cookie on. For example,
 * given subdomain.example.com, it would return example.com.
 *
 * @param {StorageManager} storage e.g. from getStorageManager()
 * @param {string} moduleName the name of the module using this function
 * @returns {function(): string}
 */
function domainOverrideToRootDomain(storage, moduleName) {
  return function () {
    const domainElements = document.domain.split('.');
    const cookieName = `_gd${Date.now()}_${moduleName}`;
    for (let i = 0, topDomain, testCookie; i < domainElements.length; i++) {
      const nextDomain = domainElements.slice(i).join('.');

      // write test cookie
      storage.setCookie(cookieName, '1', undefined, undefined, nextDomain);

      // read test cookie to verify domain was valid
      testCookie = storage.getCookie(cookieName);

      // delete test cookie
      storage.setCookie(cookieName, '', 'Thu, 01 Jan 1970 00:00:01 GMT', undefined, nextDomain);
      if (testCookie === '1') {
        // cookie was written successfully using test domain so the topDomain is updated
        topDomain = nextDomain;
      } else {
        // cookie failed to write using test domain so exit by returning the topDomain
        return topDomain;
      }
    }
  };
}

/***/ })

}]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["adpod"],{

/***/ "./modules/adpod.js":
/*!**************************!*\
  !*** ./modules/adpod.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports callPrebidCacheHook, checkAdUnitSetupHook, checkVideoBidSetupHook, adpodSetConfig, callPrebidCacheAfterAuction, sortByPricePerSecond, getTargeting */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _src_auction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/auction.js */ "./src/auction.js");
/* harmony import */ var _src_prebid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/prebid.js */ "./src/prebid.js");
/* harmony import */ var _src_video_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/video.js */ "./src/video.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_videoCache_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/videoCache.js */ "./src/videoCache.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/mediaTypes.js */ "./src/mediaTypes.js");
/* harmony import */ var _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/auctionManager.js */ "./src/auctionManager.js");
/* harmony import */ var _src_constants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/constants.js */ "./src/constants.js");

/**
 * This module houses the functionality to evaluate and process adpod adunits/bids.  Specifically there are several hooked functions,
 * that either supplement the base function (ie to check something additional or unique to adpod objects) or to replace the base function
 * entirely when appropriate.
 *
 * Brief outline of each hook:
 * - `callPrebidCacheHook` - for any adpod bids, this function will temporarily hold them in a queue in order to send the bids to Prebid Cache in bulk
 * - `checkAdUnitSetupHook` - evaluates the adUnits to ensure that required fields for adpod adUnits are present.  Invalid adpod adUntis are removed from the array.
 * - `checkVideoBidSetupHook` - evaluates the adpod bid returned from an adaptor/bidder to ensure required fields are populated; also initializes duration bucket field.
 *
 * To initialize the module, there is an `initAdpodHooks()` function that should be imported and executed by a corresponding `...AdServerVideo`
 * module that designed to support adpod video type ads.  This import process allows this module to effectively act as a sub-module.
 */











const TARGETING_KEY_PB_CAT_DUR = 'hb_pb_cat_dur';
const TARGETING_KEY_CACHE_ID = 'hb_cache_id';
let queueTimeDelay = 50;
let queueSizeLimit = 5;
let bidCacheRegistry = createBidCacheRegistry();

/**
 * Create a registry object that stores/manages bids while be held in queue for Prebid Cache.
 * @returns registry object with defined accessor functions
 */
function createBidCacheRegistry() {
  let registry = {};
  function setupRegistrySlot(auctionId) {
    registry[auctionId] = {};
    registry[auctionId].bidStorage = new Set();
    registry[auctionId].queueDispatcher = createDispatcher(queueTimeDelay);
    registry[auctionId].initialCacheKey = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.generateUUID)();
  }
  return {
    addBid: function (bid) {
      // create parent level object based on auction ID (in case there are concurrent auctions running) to store objects for that auction
      if (!registry[bid.auctionId]) {
        setupRegistrySlot(bid.auctionId);
      }
      registry[bid.auctionId].bidStorage.add(bid);
    },
    removeBid: function (bid) {
      registry[bid.auctionId].bidStorage.delete(bid);
    },
    getBids: function (bid) {
      return registry[bid.auctionId] && registry[bid.auctionId].bidStorage.values();
    },
    getQueueDispatcher: function (bid) {
      return registry[bid.auctionId] && registry[bid.auctionId].queueDispatcher;
    },
    setupInitialCacheKey: function (bid) {
      if (!registry[bid.auctionId]) {
        registry[bid.auctionId] = {};
        registry[bid.auctionId].initialCacheKey = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.generateUUID)();
      }
    },
    getInitialCacheKey: function (bid) {
      return registry[bid.auctionId] && registry[bid.auctionId].initialCacheKey;
    }
  };
}

/**
 * Creates a function that when called updates the bid queue and extends the running timer (when called subsequently).
 * Once the time threshold for the queue (defined by queueSizeLimit) is reached, the queue will be flushed by calling the `firePrebidCacheCall` function.
 * If there is a long enough time between calls (based on timeoutDration), the queue will automatically flush itself.
 * @param {Number} timeoutDuration number of milliseconds to pass before timer expires and current bid queue is flushed
 * @returns {Function}
 */
function createDispatcher(timeoutDuration) {
  let timeout;
  let counter = 1;
  return function (auctionInstance, bidListArr, afterBidAdded, killQueue) {
    const context = this;
    var callbackFn = function () {
      firePrebidCacheCall.call(context, auctionInstance, bidListArr, afterBidAdded);
    };
    clearTimeout(timeout);
    if (!killQueue) {
      // want to fire off the queue if either: size limit is reached or time has passed since last call to dispatcher
      if (counter === queueSizeLimit) {
        counter = 1;
        callbackFn();
      } else {
        counter++;
        timeout = setTimeout(callbackFn, timeoutDuration);
      }
    } else {
      counter = 1;
    }
  };
}
function getPricePartForAdpodKey(bid) {
  let pricePart;
  let prioritizeDeals = _src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('adpod.prioritizeDeals');
  if (prioritizeDeals && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(bid, 'video.dealTier')) {
    const adpodDealPrefix = _src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig(`adpod.dealTier.${bid.bidderCode}.prefix`);
    pricePart = adpodDealPrefix ? adpodDealPrefix + (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(bid, 'video.dealTier') : (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(bid, 'video.dealTier');
  } else {
    const granularity = (0,_src_auction_js__WEBPACK_IMPORTED_MODULE_4__.getPriceGranularity)(bid);
    pricePart = (0,_src_auction_js__WEBPACK_IMPORTED_MODULE_4__.getPriceByGranularity)(granularity)(bid);
  }
  return pricePart;
}

/**
 * This function reads certain fields from the bid to generate a specific key used for caching the bid in Prebid Cache
 * @param {Object} bid bid object to update
 * @param {Boolean} brandCategoryExclusion value read from setConfig; influences whether category is required or not
 */
function attachPriceIndustryDurationKeyToBid(bid, brandCategoryExclusion) {
  let initialCacheKey = bidCacheRegistry.getInitialCacheKey(bid);
  let duration = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(bid, 'video.durationBucket');
  const pricePart = getPricePartForAdpodKey(bid);
  let pcd;
  if (brandCategoryExclusion) {
    let category = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(bid, 'meta.adServerCatId');
    pcd = `${pricePart}_${category}_${duration}s`;
  } else {
    pcd = `${pricePart}_${duration}s`;
  }
  if (!bid.adserverTargeting) {
    bid.adserverTargeting = {};
  }
  bid.adserverTargeting[TARGETING_KEY_PB_CAT_DUR] = pcd;
  bid.adserverTargeting[TARGETING_KEY_CACHE_ID] = initialCacheKey;
  bid.videoCacheKey = initialCacheKey;
  bid.customCacheKey = `${pcd}_${initialCacheKey}`;
}

/**
 * Updates the running queue for the associated auction.
 * Does a check to ensure the auction is still running; if it's not - the previously running queue is killed.
 * @param {*} auctionInstance running context of the auction
 * @param {Object} bidResponse bid object being added to queue
 * @param {Function} afterBidAdded callback function used when Prebid Cache responds
 */
function updateBidQueue(auctionInstance, bidResponse, afterBidAdded) {
  let bidListIter = bidCacheRegistry.getBids(bidResponse);
  if (bidListIter) {
    let bidListArr = Array.from(bidListIter);
    let callDispatcher = bidCacheRegistry.getQueueDispatcher(bidResponse);
    let killQueue = !!(auctionInstance.getAuctionStatus() !== _src_auction_js__WEBPACK_IMPORTED_MODULE_4__.AUCTION_IN_PROGRESS);
    callDispatcher(auctionInstance, bidListArr, afterBidAdded, killQueue);
  } else {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)('Attempted to cache a bid from an unknown auction. Bid:', bidResponse);
  }
}

/**
 * Small helper function to remove bids from internal storage; normally b/c they're about to sent to Prebid Cache for processing.
 * @param {Array[Object]} bidResponses list of bids to remove
 */
function removeBidsFromStorage(bidResponses) {
  for (let i = 0; i < bidResponses.length; i++) {
    bidCacheRegistry.removeBid(bidResponses[i]);
  }
}

/**
 * This function will send a list of bids to Prebid Cache.  It also removes the same bids from the internal bidCacheRegistry
 * to maintain which bids are in queue.
 * If the bids are successfully cached, they will be added to the respective auction.
 * @param {*} auctionInstance running context of the auction
 * @param {Array[Object]} bidList list of bid objects that need to be sent to Prebid Cache
 * @param {Function} afterBidAdded callback function used when Prebid Cache responds
 */
function firePrebidCacheCall(auctionInstance, bidList, afterBidAdded) {
  // remove entries now so other incoming bids won't accidentally have a stale version of the list while PBC is processing the current submitted list
  removeBidsFromStorage(bidList);
  (0,_src_videoCache_js__WEBPACK_IMPORTED_MODULE_5__.store)(bidList, function (error, cacheIds) {
    if (error) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Failed to save to the video cache: ${error}. Video bid(s) must be discarded.`);
    } else {
      for (let i = 0; i < cacheIds.length; i++) {
        // when uuid in response is empty string then the key already existed, so this bid wasn't cached
        if (cacheIds[i].uuid !== '') {
          (0,_src_auction_js__WEBPACK_IMPORTED_MODULE_4__.addBidToAuction)(auctionInstance, bidList[i]);
        } else {
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logInfo)(`Detected a bid was not cached because the custom key was already registered.  Attempted to use key: ${bidList[i].customCacheKey}. Bid was: `, bidList[i]);
        }
        afterBidAdded();
      }
    }
  });
}

/**
 * This is the main hook function to handle adpod bids; maintains the logic to temporarily hold bids in a queue in order to send bulk requests to Prebid Cache.
 * @param {Function} fn reference to original function (used by hook logic)
 * @param {*} auctionInstance running context of the auction
 * @param {Object} bidResponse incoming bid; if adpod, will be processed through hook function.  If not adpod, returns to original function.
 * @param {Function} afterBidAdded callback function used when Prebid Cache responds
 * @param {Object} videoConfig mediaTypes.video from the bid's adUnit
 */
function callPrebidCacheHook(fn, auctionInstance, bidResponse, afterBidAdded, videoConfig) {
  if (videoConfig && videoConfig.context === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_6__.ADPOD) {
    let brandCategoryExclusion = _src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('adpod.brandCategoryExclusion');
    let adServerCatId = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(bidResponse, 'meta.adServerCatId');
    if (!adServerCatId && brandCategoryExclusion) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)('Detected a bid without meta.adServerCatId while setConfig({adpod.brandCategoryExclusion}) was enabled.  This bid has been rejected:', bidResponse);
      afterBidAdded();
    } else {
      if (_src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('adpod.deferCaching') === false) {
        bidCacheRegistry.addBid(bidResponse);
        attachPriceIndustryDurationKeyToBid(bidResponse, brandCategoryExclusion);
        updateBidQueue(auctionInstance, bidResponse, afterBidAdded);
      } else {
        // generate targeting keys for bid
        bidCacheRegistry.setupInitialCacheKey(bidResponse);
        attachPriceIndustryDurationKeyToBid(bidResponse, brandCategoryExclusion);

        // add bid to auction
        (0,_src_auction_js__WEBPACK_IMPORTED_MODULE_4__.addBidToAuction)(auctionInstance, bidResponse);
        afterBidAdded();
      }
    }
  } else {
    fn.call(this, auctionInstance, bidResponse, afterBidAdded, videoConfig);
  }
}

/**
 * This hook function will review the adUnit setup and verify certain required values are present in any adpod adUnits.
 * If the fields are missing or incorrectly setup, the adUnit is removed from the list.
 * @param {Function} fn reference to original function (used by hook logic)
 * @param {Array[Object]} adUnits list of adUnits to be evaluated
 * @returns {Array[Object]} list of adUnits that passed the check
 */
function checkAdUnitSetupHook(fn, adUnits) {
  let goodAdUnits = adUnits.filter(adUnit => {
    let mediaTypes = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(adUnit, 'mediaTypes');
    let videoConfig = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(mediaTypes, 'video');
    if (videoConfig && videoConfig.context === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_6__.ADPOD) {
      // run check to see if other mediaTypes are defined (ie multi-format); reject adUnit if so
      if (Object.keys(mediaTypes).length > 1) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Detected more than one mediaType in adUnitCode: ${adUnit.code} while attempting to define an 'adpod' video adUnit.  'adpod' adUnits cannot be mixed with other mediaTypes.  This adUnit will be removed from the auction.`);
        return false;
      }
      let errMsg = `Detected missing or incorrectly setup fields for an adpod adUnit.  Please review the following fields of adUnitCode: ${adUnit.code}.  This adUnit will be removed from the auction.`;
      let playerSize = !!(videoConfig.playerSize && ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isArrayOfNums)(videoConfig.playerSize, 2) || (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(videoConfig.playerSize) && videoConfig.playerSize.every(sz => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isArrayOfNums)(sz, 2))) || videoConfig.sizeConfig);
      let adPodDurationSec = !!(videoConfig.adPodDurationSec && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(videoConfig.adPodDurationSec) && videoConfig.adPodDurationSec > 0);
      let durationRangeSec = !!(videoConfig.durationRangeSec && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isArrayOfNums)(videoConfig.durationRangeSec) && videoConfig.durationRangeSec.every(range => range > 0));
      if (!playerSize || !adPodDurationSec || !durationRangeSec) {
        errMsg += !playerSize ? '\nmediaTypes.video.playerSize' : '';
        errMsg += !adPodDurationSec ? '\nmediaTypes.video.adPodDurationSec' : '';
        errMsg += !durationRangeSec ? '\nmediaTypes.video.durationRangeSec' : '';
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(errMsg);
        return false;
      }
    }
    return true;
  });
  adUnits = goodAdUnits;
  fn.call(this, adUnits);
}

/**
 * This check evaluates the incoming bid's `video.durationSeconds` field and tests it against specific logic depending on adUnit config.  Summary of logic below:
 * when adUnit.mediaTypes.video.requireExactDuration is true
 *  - only bids that exactly match those listed values are accepted (don't round at all).
 *  - populate the `bid.video.durationBucket` field with the matching duration value
 * when adUnit.mediaTypes.video.requireExactDuration is false
 *  - round the duration to the next highest specified duration value based on adunit.  If the duration is above a range within a set buffer, that bid falls down into that bucket.
 *      (eg if range was [5, 15, 30] -> 2s is rounded to 5s; 17s is rounded back to 15s; 18s is rounded up to 30s)
 *  - if the bid is above the range of the listed durations (and outside the buffer), reject the bid
 *  - set the rounded duration value in the `bid.video.durationBucket` field for accepted bids
 * @param {Object} videoMediaType 'mediaTypes.video' associated to bidResponse
 * @param {Object} bidResponse incoming bidResponse being evaluated by bidderFactory
 * @returns {boolean} return false if bid duration is deemed invalid as per adUnit configuration; return true if fine
 */
function checkBidDuration(videoMediaType, bidResponse) {
  const buffer = 2;
  let bidDuration = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(bidResponse, 'video.durationSeconds');
  let adUnitRanges = videoMediaType.durationRangeSec;
  adUnitRanges.sort((a, b) => a - b); // ensure the ranges are sorted in numeric order

  if (!videoMediaType.requireExactDuration) {
    let max = Math.max(...adUnitRanges);
    if (bidDuration <= max + buffer) {
      let nextHighestRange = (adUnitRanges || []).find(range => range + buffer >= bidDuration);
      bidResponse.video.durationBucket = nextHighestRange;
    } else {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Detected a bid with a duration value outside the accepted ranges specified in adUnit.mediaTypes.video.durationRangeSec.  Rejecting bid: `, bidResponse);
      return false;
    }
  } else {
    if ((adUnitRanges || []).find(range => range === bidDuration)) {
      bidResponse.video.durationBucket = bidDuration;
    } else {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Detected a bid with a duration value not part of the list of accepted ranges specified in adUnit.mediaTypes.video.durationRangeSec.  Exact match durations must be used for this adUnit. Rejecting bid: `, bidResponse);
      return false;
    }
  }
  return true;
}

/**
 * This hooked function evaluates an adpod bid and determines if the required fields are present.
 * If it's found to not be an adpod bid, it will return to original function via hook logic
 * @param {Function} fn reference to original function (used by hook logic)
 * @param {Object} bid incoming bid object
 * @param {Object} adUnit adUnit object of associated bid
 * @param {Object} videoMediaType copy of the `bidRequest.mediaTypes.video` object; used in original function
 * @param {String} context value of the `bidRequest.mediaTypes.video.context` field; used in original function
 * @returns {boolean} this return is only used for adpod bids
 */
function checkVideoBidSetupHook(fn, bid, adUnit, videoMediaType, context) {
  if (context === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_6__.ADPOD) {
    let result = true;
    let brandCategoryExclusion = _src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('adpod.brandCategoryExclusion');
    if (brandCategoryExclusion && !(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(bid, 'meta.primaryCatId')) {
      result = false;
    }
    if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(bid, 'video')) {
      if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(bid, 'video.context') || bid.video.context !== _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_6__.ADPOD) {
        result = false;
      }
      if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(bid, 'video.durationSeconds') || bid.video.durationSeconds <= 0) {
        result = false;
      } else {
        let isBidGood = checkBidDuration(videoMediaType, bid);
        if (!isBidGood) result = false;
      }
    }
    if (!_src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('cache.url') && bid.vastXml && !bid.vastUrl) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`
        This bid contains only vastXml and will not work when a prebid cache url is not specified.
        Try enabling prebid cache with pbjs.setConfig({ cache: {url: "..."} });
      `);
      result = false;
    }
    ;
    fn.bail(result);
  } else {
    fn.call(this, bid, adUnit, videoMediaType, context);
  }
}

/**
 * This function reads the (optional) settings for the adpod as set from the setConfig()
 * @param {Object} config contains the config settings for adpod module
 */
function adpodSetConfig(config) {
  if (config.bidQueueTimeDelay !== undefined) {
    if (typeof config.bidQueueTimeDelay === 'number' && config.bidQueueTimeDelay > 0) {
      queueTimeDelay = config.bidQueueTimeDelay;
    } else {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Detected invalid value for adpod.bidQueueTimeDelay in setConfig; must be a positive number.  Using default: ${queueTimeDelay}`);
    }
  }
  if (config.bidQueueSizeLimit !== undefined) {
    if (typeof config.bidQueueSizeLimit === 'number' && config.bidQueueSizeLimit > 0) {
      queueSizeLimit = config.bidQueueSizeLimit;
    } else {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Detected invalid value for adpod.bidQueueSizeLimit in setConfig; must be a positive number.  Using default: ${queueSizeLimit}`);
    }
  }
}
_src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('adpod', config => adpodSetConfig(config.adpod));

/**
 * This function initializes the adpod module's hooks.  This is called by the corresponding adserver video module.
 */
function initAdpodHooks() {
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_7__.setupBeforeHookFnOnce)((0,_src_hook_js__WEBPACK_IMPORTED_MODULE_7__.getHook)('callPrebidCache'), callPrebidCacheHook);
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_7__.setupBeforeHookFnOnce)(_src_prebid_js__WEBPACK_IMPORTED_MODULE_0__.checkAdUnitSetup, checkAdUnitSetupHook);
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_7__.setupBeforeHookFnOnce)(_src_video_js__WEBPACK_IMPORTED_MODULE_8__.checkVideoBidSetup, checkVideoBidSetupHook);
}
initAdpodHooks();

/**
 *
 * @param {Array[Object]} bids list of 'winning' bids that need to be cached
 * @param {Function} callback send the cached bids (or error) back to adserverVideoModule for further processing
 }}
 */
function callPrebidCacheAfterAuction(bids, callback) {
  // will call PBC here and execute cb param to initialize player code
  (0,_src_videoCache_js__WEBPACK_IMPORTED_MODULE_5__.store)(bids, function (error, cacheIds) {
    if (error) {
      callback(error, null);
    } else {
      let successfulCachedBids = [];
      for (let i = 0; i < cacheIds.length; i++) {
        if (cacheIds[i] !== '') {
          successfulCachedBids.push(bids[i]);
        }
      }
      callback(null, successfulCachedBids);
    }
  });
}

/**
 * Compare function to be used in sorting long-form bids. This will compare bids on price per second.
 * @param {Object} a
 * @param {Object} b
 */
function sortByPricePerSecond(a, b) {
  if (a.adserverTargeting[_src_constants_js__WEBPACK_IMPORTED_MODULE_9__.TARGETING_KEYS.PRICE_BUCKET] / a.video.durationBucket < b.adserverTargeting[_src_constants_js__WEBPACK_IMPORTED_MODULE_9__.TARGETING_KEYS.PRICE_BUCKET] / b.video.durationBucket) {
    return 1;
  }
  if (a.adserverTargeting[_src_constants_js__WEBPACK_IMPORTED_MODULE_9__.TARGETING_KEYS.PRICE_BUCKET] / a.video.durationBucket > b.adserverTargeting[_src_constants_js__WEBPACK_IMPORTED_MODULE_9__.TARGETING_KEYS.PRICE_BUCKET] / b.video.durationBucket) {
    return -1;
  }
  return 0;
}

/**
 * This function returns targeting keyvalue pairs for long-form adserver modules. Freewheel and GAM are currently supporting Prebid long-form
 * @param {Object} options - Options for targeting.
 * @param {Array<string>} options.codes - Array of ad unit codes.
 * @param {function} options.callback - Callback function to handle the targeting key-value pairs.
 * @returns {Object} Targeting key-value pairs for ad unit codes.
 */
function getTargeting() {
  let {
    codes,
    callback
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  if (!callback) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)('No callback function was defined in the getTargeting call.  Aborting getTargeting().');
    return;
  }
  codes = codes || [];
  const adPodAdUnits = getAdPodAdUnits(codes);
  const bidsReceived = _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_10__.auctionManager.getBidsReceived();
  const competiveExclusionEnabled = _src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('adpod.brandCategoryExclusion');
  const deferCachingSetting = _src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('adpod.deferCaching');
  const deferCachingEnabled = typeof deferCachingSetting === 'boolean' ? deferCachingSetting : true;
  let bids = getBidsForAdpod(bidsReceived, adPodAdUnits);
  bids = competiveExclusionEnabled || deferCachingEnabled ? getExclusiveBids(bids) : bids;
  let prioritizeDeals = _src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('adpod.prioritizeDeals');
  if (prioritizeDeals) {
    let [otherBids, highPriorityDealBids] = bids.reduce((partitions, bid) => {
      let bidDealTier = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(bid, 'video.dealTier');
      let minDealTier = _src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig(`adpod.dealTier.${bid.bidderCode}.minDealTier`);
      if (minDealTier && bidDealTier) {
        if (bidDealTier >= minDealTier) {
          partitions[1].push(bid);
        } else {
          partitions[0].push(bid);
        }
      } else if (bidDealTier) {
        partitions[1].push(bid);
      } else {
        partitions[0].push(bid);
      }
      return partitions;
    }, [[], []]);
    highPriorityDealBids.sort(sortByPricePerSecond);
    otherBids.sort(sortByPricePerSecond);
    bids = highPriorityDealBids.concat(otherBids);
  } else {
    bids.sort(sortByPricePerSecond);
  }
  let targeting = {};
  if (deferCachingEnabled === false) {
    adPodAdUnits.forEach(adUnit => {
      let adPodTargeting = [];
      let adPodDurationSeconds = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(adUnit, 'mediaTypes.video.adPodDurationSec');
      bids.filter(bid => bid.adUnitCode === adUnit.code).forEach((bid, index, arr) => {
        if (bid.video.durationBucket <= adPodDurationSeconds) {
          adPodTargeting.push({
            [TARGETING_KEY_PB_CAT_DUR]: bid.adserverTargeting[TARGETING_KEY_PB_CAT_DUR]
          });
          adPodDurationSeconds -= bid.video.durationBucket;
        }
        if (index === arr.length - 1 && adPodTargeting.length > 0) {
          adPodTargeting.push({
            [TARGETING_KEY_CACHE_ID]: bid.adserverTargeting[TARGETING_KEY_CACHE_ID]
          });
        }
      });
      targeting[adUnit.code] = adPodTargeting;
    });
    callback(null, targeting);
  } else {
    let bidsToCache = [];
    adPodAdUnits.forEach(adUnit => {
      let adPodDurationSeconds = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(adUnit, 'mediaTypes.video.adPodDurationSec');
      bids.filter(bid => bid.adUnitCode === adUnit.code).forEach(bid => {
        if (bid.video.durationBucket <= adPodDurationSeconds) {
          bidsToCache.push(bid);
          adPodDurationSeconds -= bid.video.durationBucket;
        }
      });
    });
    callPrebidCacheAfterAuction(bidsToCache, function (error, bidsSuccessfullyCached) {
      if (error) {
        callback(error, null);
      } else {
        let groupedBids = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.groupBy)(bidsSuccessfullyCached, 'adUnitCode');
        Object.keys(groupedBids).forEach(adUnitCode => {
          let adPodTargeting = [];
          groupedBids[adUnitCode].forEach((bid, index, arr) => {
            adPodTargeting.push({
              [TARGETING_KEY_PB_CAT_DUR]: bid.adserverTargeting[TARGETING_KEY_PB_CAT_DUR]
            });
            if (index === arr.length - 1 && adPodTargeting.length > 0) {
              adPodTargeting.push({
                [TARGETING_KEY_CACHE_ID]: bid.adserverTargeting[TARGETING_KEY_CACHE_ID]
              });
            }
          });
          targeting[adUnitCode] = adPodTargeting;
        });
        callback(null, targeting);
      }
    });
  }
  return targeting;
}

/**
 * This function returns the adunit of mediaType adpod
 * @param {Array} codes adUnitCodes
 * @returns {Array[Object]} adunits of mediaType adpod
 */
function getAdPodAdUnits(codes) {
  return _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_10__.auctionManager.getAdUnits().filter(adUnit => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(adUnit, 'mediaTypes.video.context') === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_6__.ADPOD).filter(adUnit => codes.length > 0 ? codes.indexOf(adUnit.code) != -1 : true);
}

/**
 * This function will create compare function to sort on object property
 * @param {string} property
 * @returns {function} compare function to be used in sorting
 */
function compareOn(property) {
  return function compare(a, b) {
    if (a[property] < b[property]) {
      return 1;
    }
    if (a[property] > b[property]) {
      return -1;
    }
    return 0;
  };
}

/**
 * This function removes bids of same category. It will be used when competitive exclusion is enabled.
 * @param {Array[Object]} bidsReceived
 * @returns {Array[Object]} unique category bids
 */
function getExclusiveBids(bidsReceived) {
  let bids = bidsReceived.map(bid => Object.assign({}, bid, {
    [TARGETING_KEY_PB_CAT_DUR]: bid.adserverTargeting[TARGETING_KEY_PB_CAT_DUR]
  }));
  bids = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.groupBy)(bids, TARGETING_KEY_PB_CAT_DUR);
  let filteredBids = [];
  Object.keys(bids).forEach(targetingKey => {
    bids[targetingKey].sort(compareOn('responseTimestamp'));
    filteredBids.push(bids[targetingKey][0]);
  });
  return filteredBids;
}

/**
 * This function returns bids for adpod adunits
 * @param {Array[Object]} bidsReceived
 * @param {Array[Object]} adPodAdUnits
 * @returns {Array[Object]} bids of mediaType adpod
 */
function getBidsForAdpod(bidsReceived, adPodAdUnits) {
  let adUnitCodes = adPodAdUnits.map(adUnit => adUnit.code);
  return bidsReceived.filter(bid => adUnitCodes.indexOf(bid.adUnitCode) != -1 && bid.video && bid.video.context === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_6__.ADPOD);
}
const sharedMethods = {
  TARGETING_KEY_PB_CAT_DUR: TARGETING_KEY_PB_CAT_DUR,
  TARGETING_KEY_CACHE_ID: TARGETING_KEY_CACHE_ID,
  'getTargeting': getTargeting
};
Object.freeze(sharedMethods);
(0,_src_hook_js__WEBPACK_IMPORTED_MODULE_7__.module)('adpod', function shareAdpodUtilities() {
  if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(arguments.length <= 0 ? undefined : arguments[0])) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)('Adpod module needs plain object to share methods with submodule');
    return;
  }
  function addMethods(object, func) {
    for (let name in func) {
      object[name] = func[name];
    }
  }
  addMethods(arguments.length <= 0 ? undefined : arguments[0], sharedMethods);
});
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_11__.registerModule)('adpod');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/adpod.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["appnexusBidAdapter"],{

/***/ "./modules/appnexusBidAdapter.js":
/*!***************************************!*\
  !*** ./modules/appnexusBidAdapter.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony export spec */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _src_Renderer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/Renderer.js */ "./src/Renderer.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../src/adapters/bidderFactory.js */ "./src/adapters/bidderFactory.js");
/* harmony import */ var _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/mediaTypes.js */ "./src/mediaTypes.js");
/* harmony import */ var _src_video_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../src/video.js */ "./src/video.js");
/* harmony import */ var _src_storageManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/storageManager.js */ "./src/storageManager.js");
/* harmony import */ var _src_bidderSettings_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/bidderSettings.js */ "./src/bidderSettings.js");
/* harmony import */ var _src_utils_gdpr_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/utils/gdpr.js */ "./src/utils/gdpr.js");
/* harmony import */ var _src_native_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/native.js */ "./src/native.js");
/* harmony import */ var _libraries_categoryTranslationMapping_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../libraries/categoryTranslationMapping/index.js */ "./libraries/categoryTranslationMapping/index.js");
/* harmony import */ var _libraries_appnexusUtils_anKeywords_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../libraries/appnexusUtils/anKeywords.js */ "./libraries/appnexusUtils/anKeywords.js");
/* harmony import */ var _libraries_appnexusUtils_anUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libraries/appnexusUtils/anUtils.js */ "./libraries/appnexusUtils/anUtils.js");
/* harmony import */ var _libraries_transformParamsUtils_convertTypes_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../libraries/transformParamsUtils/convertTypes.js */ "./libraries/transformParamsUtils/convertTypes.js");
/* harmony import */ var _libraries_chunk_chunk_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../libraries/chunk/chunk.js */ "./libraries/chunk/chunk.js");

















/**
 * @typedef {import('../src/adapters/bidderFactory.js').BidRequest} BidRequest
 * @typedef {import('../src/adapters/bidderFactory.js').Bid} Bid
 */

const BIDDER_CODE = 'appnexus';
const URL = 'https://ib.adnxs.com/ut/v3/prebid';
const URL_SIMPLE = 'https://ib.adnxs-simple.com/ut/v3/prebid';
const VIDEO_TARGETING = ['id', 'minduration', 'maxduration', 'skippable', 'playback_method', 'frameworks', 'context', 'skipoffset'];
const VIDEO_RTB_TARGETING = ['minduration', 'maxduration', 'skip', 'skipafter', 'playbackmethod', 'api', 'startdelay', 'placement', 'plcmt'];
const USER_PARAMS = ['age', 'externalUid', 'external_uid', 'segments', 'gender', 'dnt', 'language'];
const APP_DEVICE_PARAMS = ['geo', 'device_id']; // appid is collected separately
const DEBUG_PARAMS = ['enabled', 'dongle', 'member_id', 'debug_timeout'];
const DEBUG_QUERY_PARAM_MAP = {
  'apn_debug_dongle': 'dongle',
  'apn_debug_member_id': 'member_id',
  'apn_debug_timeout': 'debug_timeout'
};
const VIDEO_MAPPING = {
  playback_method: {
    'unknown': 0,
    'auto_play_sound_on': 1,
    'auto_play_sound_off': 2,
    'click_to_play': 3,
    'mouse_over': 4,
    'auto_play_sound_unknown': 5
  },
  context: {
    'unknown': 0,
    'pre_roll': 1,
    'mid_roll': 2,
    'post_roll': 3,
    'outstream': 4,
    'in-banner': 5,
    'in-feed': 6,
    'interstitial': 7,
    'accompanying_content_pre_roll': 8,
    'accompanying_content_mid_roll': 9,
    'accompanying_content_post_roll': 10
  }
};
const NATIVE_MAPPING = {
  body: 'description',
  body2: 'desc2',
  cta: 'ctatext',
  image: {
    serverName: 'main_image',
    requiredParams: {
      required: true
    }
  },
  icon: {
    serverName: 'icon',
    requiredParams: {
      required: true
    }
  },
  sponsoredBy: 'sponsored_by',
  privacyLink: 'privacy_link',
  salePrice: 'saleprice',
  displayUrl: 'displayurl'
};
const SOURCE = 'pbjs';
const MAX_IMPS_PER_REQUEST = 15;
const SCRIPT_TAG_START = '<script';
const VIEWABILITY_URL_START = /\/\/cdn\.adnxs\.com\/v|\/\/cdn\.adnxs\-simple\.com\/v/;
const VIEWABILITY_FILE_NAME = 'trk.js';
const GVLID = 32;
const storage = (0,_src_storageManager_js__WEBPACK_IMPORTED_MODULE_0__.getStorageManager)({
  bidderCode: BIDDER_CODE
});
// ORTB2 device types according to the OpenRTB specification
const ORTB2_DEVICE_TYPE = {
  MOBILE_TABLET: 1,
  PERSONAL_COMPUTER: 2,
  CONNECTED_TV: 3,
  PHONE: 4,
  TABLET: 5,
  CONNECTED_DEVICE: 6,
  SET_TOP_BOX: 7,
  OOH_DEVICE: 8
};
// Map of ORTB2 device types to AppNexus device types
const ORTB2_DEVICE_TYPE_MAP = new Map([[ORTB2_DEVICE_TYPE.MOBILE_TABLET, 'Mobile/Tablet - General'], [ORTB2_DEVICE_TYPE.PERSONAL_COMPUTER, 'Personal Computer'], [ORTB2_DEVICE_TYPE.CONNECTED_TV, 'Connected TV'], [ORTB2_DEVICE_TYPE.PHONE, 'Phone'], [ORTB2_DEVICE_TYPE.TABLET, 'Tablet'], [ORTB2_DEVICE_TYPE.CONNECTED_DEVICE, 'Connected Device'], [ORTB2_DEVICE_TYPE.SET_TOP_BOX, 'Set Top Box'], [ORTB2_DEVICE_TYPE.OOH_DEVICE, 'OOH Device']]);
const spec = {
  code: BIDDER_CODE,
  gvlid: GVLID,
  aliases: _libraries_appnexusUtils_anUtils_js__WEBPACK_IMPORTED_MODULE_1__.appnexusAliases,
  supportedMediaTypes: [_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.BANNER, _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.VIDEO, _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.NATIVE],
  /**
   * Determines whether or not the given bid request is valid.
   *
   * @param {object} bid The bid to validate.
   * @return boolean True if this is a valid bid, and false otherwise.
   */
  isBidRequestValid: function (bid) {
    return !!(bid.params.placementId || bid.params.placement_id || bid.params.member && (bid.params.invCode || bid.params.inv_code));
  },
  /**
   * Make a server request from the list of BidRequests.
   *
   * @param {BidRequest[]} bidRequests A non-empty list of bid requests which should be sent to the Server.
   * @return ServerRequest Info describing the request to the server.
   */
  buildRequests: function (bidRequests, bidderRequest) {
    // convert Native ORTB definition to old-style prebid native definition
    bidRequests = (0,_src_native_js__WEBPACK_IMPORTED_MODULE_3__.convertOrtbRequestToProprietaryNative)(bidRequests);
    const tags = bidRequests.map(bidToTag);
    const userObjBid = (bidRequests || []).find(hasUserInfo);
    let userObj = {};
    if (_src_config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('coppa') === true) {
      userObj = {
        'coppa': true
      };
    }
    if (userObjBid) {
      Object.keys(userObjBid.params.user).filter(param => USER_PARAMS.includes(param)).forEach(param => {
        let uparam = (0,_libraries_appnexusUtils_anUtils_js__WEBPACK_IMPORTED_MODULE_1__.convertCamelToUnderscore)(param);
        if (param === 'segments' && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isArray)(userObjBid.params.user[param])) {
          let segs = [];
          userObjBid.params.user[param].forEach(val => {
            if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(val)) {
              segs.push({
                'id': val
              });
            } else if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isPlainObject)(val)) {
              segs.push(val);
            }
          });
          userObj[uparam] = segs;
        } else if (param !== 'segments') {
          userObj[uparam] = userObjBid.params.user[param];
        }
      });
    }
    const appDeviceObjBid = (bidRequests || []).find(hasAppDeviceInfo);
    let appDeviceObj;
    if (appDeviceObjBid && appDeviceObjBid.params && appDeviceObjBid.params.app) {
      appDeviceObj = {};
      Object.keys(appDeviceObjBid.params.app).filter(param => APP_DEVICE_PARAMS.includes(param)).forEach(param => appDeviceObj[param] = appDeviceObjBid.params.app[param]);
    }
    const appIdObjBid = (bidRequests || []).find(hasAppId);
    let appIdObj;
    if (appIdObjBid && appIdObjBid.params && appDeviceObjBid.params.app && appDeviceObjBid.params.app.id) {
      appIdObj = {
        appid: appIdObjBid.params.app.id
      };
    }
    let debugObj = {};
    let debugObjParams = {};
    const debugCookieName = 'apn_prebid_debug';
    const debugCookie = storage.getCookie(debugCookieName) || null;
    if (debugCookie) {
      try {
        debugObj = JSON.parse(debugCookie);
      } catch (e) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.logError)('AppNexus Debug Auction Cookie Error:\n\n' + e);
      }
    } else {
      Object.keys(DEBUG_QUERY_PARAM_MAP).forEach(qparam => {
        let qval = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.getParameterByName)(qparam);
        if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isStr)(qval) && qval !== '') {
          debugObj[DEBUG_QUERY_PARAM_MAP[qparam]] = qval;
          debugObj.enabled = true;
        }
      });
      debugObj = (0,_libraries_transformParamsUtils_convertTypes_js__WEBPACK_IMPORTED_MODULE_6__.convertTypes)({
        'member_id': 'number',
        'debug_timeout': 'number'
      }, debugObj);
      const debugBidRequest = (bidRequests || []).find(hasDebug);
      if (debugBidRequest && debugBidRequest.debug) {
        debugObj = debugBidRequest.debug;
      }
    }
    if (debugObj && debugObj.enabled) {
      Object.keys(debugObj).filter(param => DEBUG_PARAMS.includes(param)).forEach(param => {
        debugObjParams[param] = debugObj[param];
      });
    }
    const memberIdBid = (bidRequests || []).find(hasMemberId);
    const member = memberIdBid ? parseInt(memberIdBid.params.member, 10) : 0;
    const schain = bidRequests[0].schain;
    const omidSupport = (bidRequests || []).find(hasOmidSupport);
    const payload = {
      tags: [...tags],
      user: userObj,
      sdk: {
        source: SOURCE,
        version: "9.49.0-pre"
      },
      schain: schain
    };
    if (omidSupport) {
      payload['iab_support'] = {
        omidpn: 'Appnexus',
        omidpv: "9.49.0-pre"
      };
    }
    if (member > 0) {
      payload.member_id = member;
    }
    if (appDeviceObjBid) {
      payload.device = appDeviceObj;
    }
    if (appIdObjBid) {
      payload.app = appIdObj;
    }

    // if present, convert and merge device object from ortb2 into `payload.device`
    if (bidderRequest?.ortb2?.device) {
      payload.device = payload.device || {};
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.mergeDeep)(payload.device, convertORTB2DeviceDataToAppNexusDeviceObject(bidderRequest.ortb2.device));
    }

    // grab the ortb2 keyword data (if it exists) and convert from the comma list string format to object format
    let ortb2 = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.deepClone)(bidderRequest && bidderRequest.ortb2);
    let anAuctionKeywords = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.deepClone)(_src_config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('appnexusAuctionKeywords')) || {};
    let auctionKeywords = (0,_libraries_appnexusUtils_anKeywords_js__WEBPACK_IMPORTED_MODULE_7__.getANKeywordParam)(ortb2, anAuctionKeywords);
    if (auctionKeywords.length > 0) {
      payload.keywords = auctionKeywords;
    }
    if (_src_config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('adpod.brandCategoryExclusion')) {
      payload.brand_category_uniqueness = true;
    }
    if (debugObjParams.enabled) {
      payload.debug = debugObjParams;
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.logInfo)('AppNexus Debug Auction Settings:\n\n' + JSON.stringify(debugObjParams, null, 4));
    }
    if (bidderRequest && bidderRequest.gdprConsent) {
      // note - objects for impbus use underscore instead of camelCase
      payload.gdpr_consent = {
        consent_string: bidderRequest.gdprConsent.consentString,
        consent_required: bidderRequest.gdprConsent.gdprApplies
      };
      if (bidderRequest.gdprConsent.addtlConsent && bidderRequest.gdprConsent.addtlConsent.indexOf('~') !== -1) {
        let ac = bidderRequest.gdprConsent.addtlConsent;
        // pull only the ids from the string (after the ~) and convert them to an array of ints
        let acStr = ac.substring(ac.indexOf('~') + 1);
        payload.gdpr_consent.addtl_consent = acStr.split('.').map(id => parseInt(id, 10));
      }
    }
    if (bidderRequest && bidderRequest.uspConsent) {
      payload.us_privacy = bidderRequest.uspConsent;
    }
    if (bidderRequest?.gppConsent) {
      payload.privacy = {
        gpp: bidderRequest.gppConsent.gppString,
        gpp_sid: bidderRequest.gppConsent.applicableSections
      };
    } else if (bidderRequest?.ortb2?.regs?.gpp) {
      payload.privacy = {
        gpp: bidderRequest.ortb2.regs.gpp,
        gpp_sid: bidderRequest.ortb2.regs.gpp_sid
      };
    }
    if (bidderRequest && bidderRequest.refererInfo) {
      let refererinfo = {
        // TODO: are these the correct referer values?
        rd_ref: encodeURIComponent(bidderRequest.refererInfo.topmostLocation),
        rd_top: bidderRequest.refererInfo.reachedTop,
        rd_ifs: bidderRequest.refererInfo.numIframes,
        rd_stk: bidderRequest.refererInfo.stack.map(url => encodeURIComponent(url)).join(',')
      };
      let pubPageUrl = bidderRequest.refererInfo.canonicalUrl;
      if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isStr)(pubPageUrl) && pubPageUrl !== '') {
        refererinfo.rd_can = pubPageUrl;
      }
      payload.referrer_detection = refererinfo;
    }
    if (true) {
      const hasAdPodBid = (bidRequests || []).find(hasAdPod);
      if (hasAdPodBid) {
        bidRequests.filter(hasAdPod).forEach(adPodBid => {
          const adPodTags = createAdPodRequest(tags, adPodBid);
          // don't need the original adpod placement because it's in adPodTags
          const nonPodTags = payload.tags.filter(tag => tag.uuid !== adPodBid.bidId);
          payload.tags = [...nonPodTags, ...adPodTags];
        });
      }
    }
    if (bidRequests[0].userIdAsEids?.length > 0) {
      let eids = [];
      bidRequests[0].userIdAsEids.forEach(eid => {
        if (!eid || !eid.uids || eid.uids.length < 1) {
          return;
        }
        eid.uids.forEach(uid => {
          let tmp = {
            'source': eid.source,
            'id': uid.id
          };
          if (eid.source == 'adserver.org') {
            tmp.rti_partner = 'TDID';
          } else if (eid.source == 'uidapi.com') {
            tmp.rti_partner = 'UID2';
          }
          eids.push(tmp);
        });
      });
      if (eids.length) {
        payload.eids = eids;
      }
    }
    if (bidderRequest?.ortb2?.regs?.ext?.dsa) {
      const pubDsaObj = bidderRequest.ortb2.regs.ext.dsa;
      const dsaObj = {};
      ['dsarequired', 'pubrender', 'datatopub'].forEach(dsaKey => {
        if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(pubDsaObj[dsaKey])) {
          dsaObj[dsaKey] = pubDsaObj[dsaKey];
        }
      });
      if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isArray)(pubDsaObj.transparency) && pubDsaObj.transparency.every(v => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isPlainObject)(v))) {
        const tpData = [];
        pubDsaObj.transparency.forEach(tpObj => {
          if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isStr)(tpObj.domain) && tpObj.domain != '' && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isArray)(tpObj.dsaparams) && tpObj.dsaparams.every(v => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isNumber)(v))) {
            tpData.push(tpObj);
          }
        });
        if (tpData.length > 0) {
          dsaObj.transparency = tpData;
        }
      }
      if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isEmpty)(dsaObj)) payload.dsa = dsaObj;
    }
    if (tags[0].publisher_id) {
      payload.publisher_id = tags[0].publisher_id;
    }
    const request = formatRequest(payload, bidderRequest);
    return request;
  },
  /**
   * Unpack the response from the server into a list of bids.
   *
   * @param {*} serverResponse A successful response from the server.
   * @return {Bid[]} An array of bids which were nested inside the server.
   */
  interpretResponse: function (serverResponse, _ref) {
    let {
      bidderRequest
    } = _ref;
    serverResponse = serverResponse.body;
    const bids = [];
    if (!serverResponse || serverResponse.error) {
      let errorMessage = `in response for ${bidderRequest.bidderCode} adapter`;
      if (serverResponse && serverResponse.error) {
        errorMessage += `: ${serverResponse.error}`;
      }
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.logError)(errorMessage);
      return bids;
    }
    if (serverResponse.tags) {
      serverResponse.tags.forEach(serverBid => {
        const rtbBid = getRtbBid(serverBid);
        if (rtbBid) {
          const cpmCheck = _src_bidderSettings_js__WEBPACK_IMPORTED_MODULE_8__.bidderSettings.get(bidderRequest.bidderCode, 'allowZeroCpmBids') === true ? rtbBid.cpm >= 0 : rtbBid.cpm > 0;
          if (cpmCheck && this.supportedMediaTypes.includes(rtbBid.ad_type)) {
            const bid = newBid(serverBid, rtbBid, bidderRequest);
            bid.mediaType = parseMediaType(rtbBid);
            bids.push(bid);
          }
        }
      });
    }
    if (serverResponse.debug && serverResponse.debug.debug_info) {
      let debugHeader = 'AppNexus Debug Auction for Prebid\n\n';
      let debugText = debugHeader + serverResponse.debug.debug_info;
      debugText = debugText.replace(/(<td>|<th>)/gm, '\t') // Tables
      .replace(/(<\/td>|<\/th>)/gm, '\n') // Tables
      .replace(/^<br>/gm, '') // Remove leading <br>
      .replace(/(<br>\n|<br>)/gm, '\n') // <br>
      .replace(/<h1>(.*)<\/h1>/gm, '\n\n===== $1 =====\n\n') // Header H1
      .replace(/<h[2-6]>(.*)<\/h[2-6]>/gm, '\n\n*** $1 ***\n\n') // Headers
      .replace(/(<([^>]+)>)/igm, ''); // Remove any other tags
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.logMessage)('https://console.appnexus.com/docs/understanding-the-debug-auction');
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.logMessage)(debugText);
    }
    return bids;
  },
  getUserSyncs: function (syncOptions, responses, gdprConsent, uspConsent, gppConsent) {
    if (syncOptions.iframeEnabled && (0,_src_utils_gdpr_js__WEBPACK_IMPORTED_MODULE_9__.hasPurpose1Consent)(gdprConsent)) {
      return [{
        type: 'iframe',
        url: 'https://acdn.adnxs.com/dmp/async_usersync.html'
      }];
    }
    if (syncOptions.pixelEnabled) {
      // first attempt using static list
      const imgList = ['https://px.ads.linkedin.com/setuid?partner=appNexus'];
      return imgList.map(url => ({
        type: 'image',
        url
      }));
    }
  }
};
function strIsAppnexusViewabilityScript(str) {
  if (!str || str === '') return false;
  let regexMatchUrlStart = str.match(VIEWABILITY_URL_START);
  let viewUrlStartInStr = regexMatchUrlStart != null && regexMatchUrlStart.length >= 1;
  let regexMatchFileName = str.match(VIEWABILITY_FILE_NAME);
  let fileNameInStr = regexMatchFileName != null && regexMatchFileName.length >= 1;
  return str.startsWith(SCRIPT_TAG_START) && fileNameInStr && viewUrlStartInStr;
}
function formatRequest(payload, bidderRequest) {
  let request = [];
  let options = {
    withCredentials: true
  };
  let endpointUrl = URL;
  if (!(0,_src_utils_gdpr_js__WEBPACK_IMPORTED_MODULE_9__.hasPurpose1Consent)(bidderRequest?.gdprConsent)) {
    endpointUrl = URL_SIMPLE;
  }
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.getParameterByName)('apn_test').toUpperCase() === 'TRUE' || _src_config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('apn_test') === true) {
    options.customHeaders = {
      'X-Is-Test': 1
    };
  }
  if (payload.tags.length > MAX_IMPS_PER_REQUEST) {
    const clonedPayload = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.deepClone)(payload);
    (0,_libraries_chunk_chunk_js__WEBPACK_IMPORTED_MODULE_10__.chunk)(payload.tags, MAX_IMPS_PER_REQUEST).forEach(tags => {
      clonedPayload.tags = tags;
      const payloadString = JSON.stringify(clonedPayload);
      request.push({
        method: 'POST',
        url: endpointUrl,
        data: payloadString,
        bidderRequest,
        options
      });
    });
  } else {
    const payloadString = JSON.stringify(payload);
    request = {
      method: 'POST',
      url: endpointUrl,
      data: payloadString,
      bidderRequest,
      options
    };
  }
  return request;
}
function newRenderer(adUnitCode, rtbBid) {
  let rendererOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const renderer = _src_Renderer_js__WEBPACK_IMPORTED_MODULE_11__.Renderer.install({
    id: rtbBid.renderer_id,
    url: rtbBid.renderer_url,
    config: rendererOptions,
    loaded: false,
    adUnitCode
  });
  try {
    renderer.setRender(outstreamRender);
  } catch (err) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.logWarn)('Prebid Error calling setRender on renderer', err);
  }
  renderer.setEventHandlers({
    impression: () => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.logMessage)('AppNexus outstream video impression event'),
    loaded: () => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.logMessage)('AppNexus outstream video loaded event'),
    ended: () => {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.logMessage)('AppNexus outstream renderer video event');
      document.querySelector(`#${adUnitCode}`).style.display = 'none';
    }
  });
  return renderer;
}

/**
 * Unpack the Server's Bid into a Prebid-compatible one.
 * @param serverBid
 * @param rtbBid
 * @param bidderRequest
 * @return Bid
 */
function newBid(serverBid, rtbBid, bidderRequest) {
  const bidRequest = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBidRequest)(serverBid.uuid, [bidderRequest]);
  const adId = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.getUniqueIdentifierStr)();
  const bid = {
    adId: adId,
    requestId: serverBid.uuid,
    cpm: rtbBid.cpm,
    creativeId: rtbBid.creative_id,
    dealId: rtbBid.deal_id,
    currency: 'USD',
    netRevenue: true,
    ttl: 300,
    adUnitCode: bidRequest.adUnitCode,
    appnexus: {
      buyerMemberId: rtbBid.buyer_member_id,
      dealPriority: rtbBid.deal_priority,
      dealCode: rtbBid.deal_code
    }
  };
  if (rtbBid.adomain) {
    bid.meta = Object.assign({}, bid.meta, {
      advertiserDomains: [rtbBid.adomain]
    });
  }
  if (rtbBid.advertiser_id) {
    bid.meta = Object.assign({}, bid.meta, {
      advertiserId: rtbBid.advertiser_id
    });
  }
  if (rtbBid.dsa) {
    bid.meta = Object.assign({}, bid.meta, {
      dsa: rtbBid.dsa
    });
  }

  // temporary function; may remove at later date if/when adserver fully supports dchain
  function setupDChain(rtbBid) {
    let dchain = {
      ver: '1.0',
      complete: 0,
      nodes: [{
        bsid: rtbBid.buyer_member_id.toString()
      }]
    };
    return dchain;
  }
  if (rtbBid.buyer_member_id) {
    bid.meta = Object.assign({}, bid.meta, {
      dchain: setupDChain(rtbBid)
    });
  }
  if (rtbBid.brand_id) {
    bid.meta = Object.assign({}, bid.meta, {
      brandId: rtbBid.brand_id
    });
  }
  if ( true && rtbBid.rtb.video) {
    // shared video properties used for all 3 contexts
    Object.assign(bid, {
      width: rtbBid.rtb.video.player_width,
      height: rtbBid.rtb.video.player_height,
      vastImpUrl: rtbBid.notify_url,
      ttl: 3600
    });
    const videoContext = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_12__["default"])(bidRequest, 'mediaTypes.video.context');
    switch (videoContext) {
      case _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.ADPOD:
        const primaryCatId = _libraries_categoryTranslationMapping_index_js__WEBPACK_IMPORTED_MODULE_13__.APPNEXUS_CATEGORY_MAPPING[rtbBid.brand_category_id] ? _libraries_categoryTranslationMapping_index_js__WEBPACK_IMPORTED_MODULE_13__.APPNEXUS_CATEGORY_MAPPING[rtbBid.brand_category_id] : null;
        bid.meta = Object.assign({}, bid.meta, {
          primaryCatId
        });
        const dealTier = rtbBid.deal_priority;
        bid.video = {
          context: _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.ADPOD,
          durationSeconds: Math.floor(rtbBid.rtb.video.duration_ms / 1000),
          dealTier
        };
        bid.vastUrl = rtbBid.rtb.video.asset_url;
        break;
      case _src_video_js__WEBPACK_IMPORTED_MODULE_14__.OUTSTREAM:
        bid.adResponse = serverBid;
        bid.adResponse.ad = bid.adResponse.ads[0];
        bid.adResponse.ad.video = bid.adResponse.ad.rtb.video;
        bid.vastXml = rtbBid.rtb.video.content;
        if (rtbBid.renderer_url) {
          const videoBid = (bidderRequest.bids || []).find(bid => bid.bidId === serverBid.uuid);
          let rendererOptions = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_12__["default"])(videoBid, 'mediaTypes.video.renderer.options'); // mediaType definition has preference (shouldn't options be .config?)
          if (!rendererOptions) {
            rendererOptions = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_12__["default"])(videoBid, 'renderer.options'); // second the adUnit definition has preference (shouldn't options be .config?)
          }
          bid.renderer = newRenderer(bid.adUnitCode, rtbBid, rendererOptions);
        }
        break;
      case _src_video_js__WEBPACK_IMPORTED_MODULE_14__.INSTREAM:
        bid.vastUrl = rtbBid.notify_url + '&redir=' + encodeURIComponent(rtbBid.rtb.video.asset_url);
        break;
    }
  } else if ( true && rtbBid.rtb[_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.NATIVE]) {
    const nativeAd = rtbBid.rtb[_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.NATIVE];
    let viewScript;
    if (strIsAppnexusViewabilityScript(rtbBid.viewability.config)) {
      let prebidParams = 'pbjs_adid=' + adId + ';pbjs_auc=' + bidRequest.adUnitCode;
      viewScript = rtbBid.viewability.config.replace('dom_id=%native_dom_id%', prebidParams);
    }
    let jsTrackers = nativeAd.javascript_trackers;
    if (jsTrackers == undefined) {
      jsTrackers = viewScript;
    } else if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isStr)(jsTrackers)) {
      jsTrackers = [jsTrackers, viewScript];
    } else {
      jsTrackers.push(viewScript);
    }
    bid[_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.NATIVE] = {
      title: nativeAd.title,
      body: nativeAd.desc,
      body2: nativeAd.desc2,
      cta: nativeAd.ctatext,
      rating: nativeAd.rating,
      sponsoredBy: nativeAd.sponsored,
      privacyLink: nativeAd.privacy_link,
      address: nativeAd.address,
      downloads: nativeAd.downloads,
      likes: nativeAd.likes,
      phone: nativeAd.phone,
      price: nativeAd.price,
      salePrice: nativeAd.saleprice,
      clickUrl: nativeAd.link.url,
      displayUrl: nativeAd.displayurl,
      clickTrackers: nativeAd.link.click_trackers,
      impressionTrackers: nativeAd.impression_trackers,
      video: nativeAd.video,
      javascriptTrackers: jsTrackers
    };
    if (nativeAd.main_img) {
      bid[_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.NATIVE].image = {
        url: nativeAd.main_img.url,
        height: nativeAd.main_img.height,
        width: nativeAd.main_img.width
      };
    }
    if (nativeAd.icon) {
      bid[_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.NATIVE].icon = {
        url: nativeAd.icon.url,
        height: nativeAd.icon.height,
        width: nativeAd.icon.width
      };
    }

    // Custom fields
    bid[_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.NATIVE].ext = {
      video: nativeAd.video,
      customImage1: nativeAd.image1 && {
        url: nativeAd.image1.url,
        height: nativeAd.image1.height,
        width: nativeAd.image1.width
      },
      customImage2: nativeAd.image2 && {
        url: nativeAd.image2.url,
        height: nativeAd.image2.height,
        width: nativeAd.image2.width
      },
      customImage3: nativeAd.image3 && {
        url: nativeAd.image3.url,
        height: nativeAd.image3.height,
        width: nativeAd.image3.width
      },
      customImage4: nativeAd.image4 && {
        url: nativeAd.image4.url,
        height: nativeAd.image4.height,
        width: nativeAd.image4.width
      },
      customImage5: nativeAd.image5 && {
        url: nativeAd.image5.url,
        height: nativeAd.image5.height,
        width: nativeAd.image5.width
      },
      customIcon1: nativeAd.icon1 && {
        url: nativeAd.icon1.url,
        height: nativeAd.icon1.height,
        width: nativeAd.icon1.width
      },
      customIcon2: nativeAd.icon2 && {
        url: nativeAd.icon2.url,
        height: nativeAd.icon2.height,
        width: nativeAd.icon2.width
      },
      customIcon3: nativeAd.icon3 && {
        url: nativeAd.icon3.url,
        height: nativeAd.icon3.height,
        width: nativeAd.icon3.width
      },
      customIcon4: nativeAd.icon4 && {
        url: nativeAd.icon4.url,
        height: nativeAd.icon4.height,
        width: nativeAd.icon4.width
      },
      customIcon5: nativeAd.icon5 && {
        url: nativeAd.icon5.url,
        height: nativeAd.icon5.height,
        width: nativeAd.icon5.width
      },
      customSocialIcon1: nativeAd.socialicon1 && {
        url: nativeAd.socialicon1.url,
        height: nativeAd.socialicon1.height,
        width: nativeAd.socialicon1.width
      },
      customSocialIcon2: nativeAd.socialicon2 && {
        url: nativeAd.socialicon2.url,
        height: nativeAd.socialicon2.height,
        width: nativeAd.socialicon2.width
      },
      customSocialIcon3: nativeAd.socialicon3 && {
        url: nativeAd.socialicon3.url,
        height: nativeAd.socialicon3.height,
        width: nativeAd.socialicon3.width
      },
      customSocialIcon4: nativeAd.socialicon4 && {
        url: nativeAd.socialicon4.url,
        height: nativeAd.socialicon4.height,
        width: nativeAd.socialicon4.width
      },
      customSocialIcon5: nativeAd.socialicon5 && {
        url: nativeAd.socialicon5.url,
        height: nativeAd.socialicon5.height,
        width: nativeAd.socialicon5.width
      },
      customTitle1: nativeAd.title1,
      customTitle2: nativeAd.title2,
      customTitle3: nativeAd.title3,
      customTitle4: nativeAd.title4,
      customTitle5: nativeAd.title5,
      customBody1: nativeAd.body1,
      customBody2: nativeAd.body2,
      customBody3: nativeAd.body3,
      customBody4: nativeAd.body4,
      customBody5: nativeAd.body5,
      customCta1: nativeAd.ctatext1,
      customCta2: nativeAd.ctatext2,
      customCta3: nativeAd.ctatext3,
      customCta4: nativeAd.ctatext4,
      customCta5: nativeAd.ctatext5,
      customDisplayUrl1: nativeAd.displayurl1,
      customDisplayUrl2: nativeAd.displayurl2,
      customDisplayUrl3: nativeAd.displayurl3,
      customDisplayUrl4: nativeAd.displayurl4,
      customDisplayUrl5: nativeAd.displayurl5,
      customSocialUrl1: nativeAd.socialurl1,
      customSocialUrl2: nativeAd.socialurl2,
      customSocialUrl3: nativeAd.socialurl3,
      customSocialUrl4: nativeAd.socialurl4,
      customSocialUrl5: nativeAd.socialurl5
    };
  } else {
    Object.assign(bid, {
      width: rtbBid.rtb.banner.width,
      height: rtbBid.rtb.banner.height,
      ad: rtbBid.rtb.banner.content
    });
    try {
      if (rtbBid.rtb.trackers) {
        for (let i = 0; i < rtbBid.rtb.trackers[0].impression_urls.length; i++) {
          const url = rtbBid.rtb.trackers[0].impression_urls[i];
          const tracker = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.createTrackPixelHtml)(url);
          bid.ad += tracker;
        }
      }
    } catch (error) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.logError)('Error appending tracking pixel', error);
    }
  }
  return bid;
}
function bidToTag(bid) {
  const tag = {};
  Object.keys(bid.params).forEach(paramKey => {
    let convertedKey = (0,_libraries_appnexusUtils_anUtils_js__WEBPACK_IMPORTED_MODULE_1__.convertCamelToUnderscore)(paramKey);
    if (convertedKey !== paramKey) {
      bid.params[convertedKey] = bid.params[paramKey];
      delete bid.params[paramKey];
    }
  });
  tag.sizes = transformSizes(bid.sizes);
  tag.primary_size = tag.sizes[0];
  tag.ad_types = [];
  tag.uuid = bid.bidId;
  if (bid.params.placement_id) {
    tag.id = parseInt(bid.params.placement_id, 10);
  } else {
    tag.code = bid.params.inv_code;
  }
  // Xandr expects GET variable to be in a following format:
  // page.html?ast_override_div=divId:creativeId,divId2:creativeId2
  const overrides = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.getParameterByName)('ast_override_div');
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isStr)(overrides) && overrides !== '') {
    const adUnitOverride = decodeURIComponent(overrides).split(',').find(pair => pair.startsWith(`${bid.adUnitCode}:`));
    if (adUnitOverride) {
      const forceCreativeId = adUnitOverride.split(':')[1];
      if (forceCreativeId) {
        tag.force_creative_id = parseInt(forceCreativeId, 10);
      }
    }
  }
  tag.allow_smaller_sizes = bid.params.allow_smaller_sizes || false;
  tag.use_pmt_rule = typeof bid.params.use_payment_rule === 'boolean' ? bid.params.use_payment_rule : typeof bid.params.use_pmt_rule === 'boolean' ? bid.params.use_pmt_rule : false;
  tag.prebid = true;
  tag.disable_psa = true;
  let bidFloor = getBidFloor(bid);
  if (bidFloor) {
    tag.reserve = bidFloor;
  }
  if (bid.params.position) {
    tag.position = {
      'above': 1,
      'below': 2
    }[bid.params.position] || 0;
  } else {
    let mediaTypePos = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_12__["default"])(bid, `mediaTypes.banner.pos`) || (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_12__["default"])(bid, `mediaTypes.video.pos`);
    // only support unknown, atf, and btf values for position at this time
    if (mediaTypePos === 0 || mediaTypePos === 1 || mediaTypePos === 3) {
      // ortb spec treats btf === 3, but our system interprets btf === 2; so converting the ortb value here for consistency
      tag.position = mediaTypePos === 3 ? 2 : mediaTypePos;
    }
  }
  if (bid.params.traffic_source_code) {
    tag.traffic_source_code = bid.params.traffic_source_code;
  }
  if (bid.params.private_sizes) {
    tag.private_sizes = transformSizes(bid.params.private_sizes);
  }
  if (bid.params.supply_type) {
    tag.supply_type = bid.params.supply_type;
  }
  if (bid.params.pub_click) {
    tag.pubclick = bid.params.pub_click;
  }
  if (bid.params.ext_inv_code) {
    tag.ext_inv_code = bid.params.ext_inv_code;
  }
  if (bid.params.publisher_id) {
    tag.publisher_id = parseInt(bid.params.publisher_id, 10);
  }
  if (bid.params.external_imp_id) {
    tag.external_imp_id = bid.params.external_imp_id;
  }
  const auKeywords = (0,_libraries_appnexusUtils_anKeywords_js__WEBPACK_IMPORTED_MODULE_7__.getANKewyordParamFromMaps)((0,_libraries_appnexusUtils_anKeywords_js__WEBPACK_IMPORTED_MODULE_7__.convertKeywordStringToANMap)((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_12__["default"])(bid, 'ortb2Imp.ext.data.keywords')), bid.params?.keywords);
  if (auKeywords.length > 0) {
    tag.keywords = auKeywords;
  }
  let gpid = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_12__["default"])(bid, 'ortb2Imp.ext.gpid') || (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_12__["default"])(bid, 'ortb2Imp.ext.data.pbadslot');
  if (gpid) {
    tag.gpid = gpid;
  }
  if ( true && (bid.mediaType === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.NATIVE || (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_12__["default"])(bid, `mediaTypes.${_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.NATIVE}`))) {
    tag.ad_types.push(_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.NATIVE);
    if (tag.sizes.length === 0) {
      tag.sizes = transformSizes([1, 1]);
    }
    if (bid.nativeParams) {
      const nativeRequest = buildNativeRequest(bid.nativeParams);
      tag[_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.NATIVE] = {
        layouts: [nativeRequest]
      };
    }
  }
  if (true) {
    const videoMediaType = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_12__["default"])(bid, `mediaTypes.${_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.VIDEO}`);
    const context = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_12__["default"])(bid, 'mediaTypes.video.context');
    if (videoMediaType && context === 'adpod') {
      tag.hb_source = 7;
    } else {
      tag.hb_source = 1;
    }
    if (bid.mediaType === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.VIDEO || videoMediaType) {
      tag.ad_types.push(_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.VIDEO);
    }

    // instream gets vastUrl, outstream gets vastXml
    if (bid.mediaType === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.VIDEO || videoMediaType && context !== 'outstream') {
      tag.require_asset_url = true;
    }
    if (bid.params.video) {
      tag.video = {};
      // place any valid video params on the tag
      Object.keys(bid.params.video).filter(param => VIDEO_TARGETING.includes(param)).forEach(param => {
        switch (param) {
          case 'context':
          case 'playback_method':
            let type = bid.params.video[param];
            type = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isArray)(type) ? type[0] : type;
            tag.video[param] = VIDEO_MAPPING[param][type];
            break;
          // Deprecating tags[].video.frameworks in favor of tags[].video_frameworks
          case 'frameworks':
            break;
          default:
            tag.video[param] = bid.params.video[param];
        }
      });
      if (bid.params.video.frameworks && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isArray)(bid.params.video.frameworks)) {
        tag['video_frameworks'] = bid.params.video.frameworks;
      }
    }

    // use IAB ORTB values if the corresponding values weren't already set by bid.params.video
    if (videoMediaType) {
      tag.video = tag.video || {};
      Object.keys(videoMediaType).filter(param => VIDEO_RTB_TARGETING.includes(param)).forEach(param => {
        switch (param) {
          case 'minduration':
          case 'maxduration':
            if (typeof tag.video[param] !== 'number') tag.video[param] = videoMediaType[param];
            break;
          case 'skip':
            if (typeof tag.video['skippable'] !== 'boolean') tag.video['skippable'] = videoMediaType[param] === 1;
            break;
          case 'skipafter':
            if (typeof tag.video['skipoffset'] !== 'number') tag.video['skippoffset'] = videoMediaType[param];
            break;
          case 'playbackmethod':
            if (typeof tag.video['playback_method'] !== 'number') {
              let type = videoMediaType[param];
              type = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isArray)(type) ? type[0] : type;

              // we only support iab's options 1-4 at this time.
              if (type >= 1 && type <= 4) {
                tag.video['playback_method'] = type;
              }
            }
            break;
          case 'api':
            if (!tag['video_frameworks'] && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isArray)(videoMediaType[param])) {
              // need to read thru array; remove 6 (we don't support it), swap 4 <> 5 if found (to match our adserver mapping for these specific values)
              let apiTmp = videoMediaType[param].map(val => {
                let v = val === 4 ? 5 : val === 5 ? 4 : val;
                if (v >= 1 && v <= 5) {
                  return v;
                }
              }).filter(v => v);
              tag['video_frameworks'] = apiTmp;
            }
            break;
          case 'startdelay':
          case 'plcmt':
          case 'placement':
            if (typeof tag.video.context !== 'number') {
              const plcmt = videoMediaType['plcmt'];
              const placement = videoMediaType['placement'];
              const startdelay = videoMediaType['startdelay'];
              const contextVal = getContextFromPlcmt(plcmt, startdelay) || getContextFromPlacement(placement) || getContextFromStartDelay(startdelay);
              tag.video.context = VIDEO_MAPPING.context[contextVal];
            }
            break;
        }
      });
    }
    if (bid.renderer) {
      tag.video = Object.assign({}, tag.video, {
        custom_renderer_present: true
      });
    }
  } else {}
  if (bid.params.frameworks && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isArray)(bid.params.frameworks)) {
    tag['banner_frameworks'] = bid.params.frameworks;
  }
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_12__["default"])(bid, `mediaTypes.${_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.BANNER}`)) {
    tag.ad_types.push(_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.BANNER);
  }
  if (tag.ad_types.length === 0) {
    delete tag.ad_types;
  }
  return tag;
}

/* Turn bid request sizes into ut-compatible format */
function transformSizes(requestSizes) {
  let sizes = [];
  let sizeObj = {};
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isArray)(requestSizes) && requestSizes.length === 2 && !(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isArray)(requestSizes[0])) {
    sizeObj.width = parseInt(requestSizes[0], 10);
    sizeObj.height = parseInt(requestSizes[1], 10);
    sizes.push(sizeObj);
  } else if (typeof requestSizes === 'object') {
    for (let i = 0; i < requestSizes.length; i++) {
      let size = requestSizes[i];
      sizeObj = {};
      sizeObj.width = parseInt(size[0], 10);
      sizeObj.height = parseInt(size[1], 10);
      sizes.push(sizeObj);
    }
  }
  return sizes;
}
function getContextFromPlacement(ortbPlacement) {
  if (!ortbPlacement) {
    return;
  }
  if (ortbPlacement === 2) {
    return 'in-banner';
  } else if (ortbPlacement === 3) {
    return 'outstream';
  } else if (ortbPlacement === 4) {
    return 'in-feed';
  } else if (ortbPlacement === 5) {
    return 'intersitial';
  }
}
function getContextFromStartDelay(ortbStartDelay) {
  if (typeof ortbStartDelay === 'undefined') {
    return;
  }
  if (ortbStartDelay === 0) {
    return 'pre_roll';
  } else if (ortbStartDelay === -1) {
    return 'mid_roll';
  } else if (ortbStartDelay === -2) {
    return 'post_roll';
  }
}
function getContextFromPlcmt(ortbPlcmt, ortbStartDelay) {
  if (!ortbPlcmt) {
    return;
  }
  if (ortbPlcmt === 2) {
    if (typeof ortbStartDelay === 'undefined') {
      return;
    }
    if (ortbStartDelay === 0) {
      return 'accompanying_content_pre_roll';
    } else if (ortbStartDelay === -1) {
      return 'accompanying_content_mid_roll';
    } else if (ortbStartDelay === -2) {
      return 'accompanying_content_post_roll';
    }
  } else if (ortbPlcmt === 3) {
    return 'interstitial';
  } else if (ortbPlcmt === 4) {
    return 'outstream';
  }
}
function hasUserInfo(bid) {
  return !!bid.params.user;
}
function hasMemberId(bid) {
  return !!parseInt(bid.params.member, 10);
}
function hasAppDeviceInfo(bid) {
  if (bid.params) {
    return !!bid.params.app;
  }
}
function hasAppId(bid) {
  if (bid.params && bid.params.app) {
    return !!bid.params.app.id;
  }
  return !!bid.params.app;
}
function hasDebug(bid) {
  return !!bid.debug;
}
function hasAdPod(bid) {
  return bid.mediaTypes && bid.mediaTypes.video && bid.mediaTypes.video.context === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.ADPOD;
}
function hasOmidSupport(bid) {
  let hasOmid = false;
  const bidderParams = bid.params;
  const videoParams = bid.params.video;
  if (bidderParams.frameworks && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isArray)(bidderParams.frameworks)) {
    hasOmid = bid.params.frameworks.includes(6);
  }
  if (!hasOmid && videoParams && videoParams.frameworks && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isArray)(videoParams.frameworks)) {
    hasOmid = bid.params.video.frameworks.includes(6);
  }
  return hasOmid;
}

/**
 * Expand an adpod placement into a set of request objects according to the
 * total adpod duration and the range of duration seconds. Sets minduration/
 * maxduration video property according to requireExactDuration configuration
 */
function createAdPodRequest(tags, adPodBid) {
  const {
    durationRangeSec,
    requireExactDuration
  } = adPodBid.mediaTypes.video;
  const numberOfPlacements = getAdPodPlacementNumber(adPodBid.mediaTypes.video);
  const maxDuration = Math.max(...durationRangeSec);
  const tagToDuplicate = tags.filter(tag => tag.uuid === adPodBid.bidId);
  let request = (0,_libraries_appnexusUtils_anUtils_js__WEBPACK_IMPORTED_MODULE_1__.fill)(...tagToDuplicate, numberOfPlacements);
  if (requireExactDuration) {
    const divider = Math.ceil(numberOfPlacements / durationRangeSec.length);
    const chunked = (0,_libraries_chunk_chunk_js__WEBPACK_IMPORTED_MODULE_10__.chunk)(request, divider);

    // each configured duration is set as min/maxduration for a subset of requests
    durationRangeSec.forEach((duration, index) => {
      chunked[index].map(tag => {
        setVideoProperty(tag, 'minduration', duration);
        setVideoProperty(tag, 'maxduration', duration);
      });
    });
  } else {
    // all maxdurations should be the same
    request.map(tag => setVideoProperty(tag, 'maxduration', maxDuration));
  }
  return request;
}
function getAdPodPlacementNumber(videoParams) {
  const {
    adPodDurationSec,
    durationRangeSec,
    requireExactDuration
  } = videoParams;
  const minAllowedDuration = Math.min(...durationRangeSec);
  const numberOfPlacements = Math.floor(adPodDurationSec / minAllowedDuration);
  return requireExactDuration ? Math.max(numberOfPlacements, durationRangeSec.length) : numberOfPlacements;
}
function setVideoProperty(tag, key, value) {
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isEmpty)(tag.video)) {
    tag.video = {};
  }
  tag.video[key] = value;
}
function getRtbBid(tag) {
  return tag && tag.ads && tag.ads.length && (tag.ads || []).find(ad => ad.rtb);
}
function buildNativeRequest(params) {
  const request = {};

  // map standard prebid native asset identifier to /ut parameters
  // e.g., tag specifies `body` but /ut only knows `description`.
  // mapping may be in form {tag: '<server name>'} or
  // {tag: {serverName: '<server name>', requiredParams: {...}}}
  Object.keys(params).forEach(key => {
    // check if one of the <server name> forms is used, otherwise
    // a mapping wasn't specified so pass the key straight through
    const requestKey = NATIVE_MAPPING[key] && NATIVE_MAPPING[key].serverName || NATIVE_MAPPING[key] || key;

    // required params are always passed on request
    const requiredParams = NATIVE_MAPPING[key] && NATIVE_MAPPING[key].requiredParams;
    request[requestKey] = Object.assign({}, requiredParams, params[key]);

    // convert the sizes of image/icon assets to proper format (if needed)
    const isImageAsset = !!(requestKey === NATIVE_MAPPING.image.serverName || requestKey === NATIVE_MAPPING.icon.serverName);
    if (isImageAsset && request[requestKey].sizes) {
      let sizes = request[requestKey].sizes;
      if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isArrayOfNums)(sizes) || (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isArray)(sizes) && sizes.length > 0 && sizes.every(sz => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isArrayOfNums)(sz))) {
        request[requestKey].sizes = transformSizes(request[requestKey].sizes);
      }
    }
    if (requestKey === NATIVE_MAPPING.privacyLink) {
      request.privacy_supported = true;
    }
  });
  return request;
}

/**
 * This function hides google div container for outstream bids to remove unwanted space on page. Appnexus renderer creates a new iframe outside of google iframe to render the outstream creative.
 * @param {string} elementId element id
 */
function hidedfpContainer(elementId) {
  try {
    const el = document.getElementById(elementId).querySelectorAll("div[id^='google_ads']");
    if (el[0]) {
      el[0].style.setProperty('display', 'none');
    }
  } catch (e) {
    // element not found!
  }
}
function hideSASIframe(elementId) {
  try {
    // find script tag with id 'sas_script'. This ensures it only works if you're using Smart Ad Server.
    const el = document.getElementById(elementId).querySelectorAll("script[id^='sas_script']");
    if (el[0].nextSibling && el[0].nextSibling.localName === 'iframe') {
      el[0].nextSibling.style.setProperty('display', 'none');
    }
  } catch (e) {
    // element not found!
  }
}
function outstreamRender(bid, doc) {
  hidedfpContainer(bid.adUnitCode);
  hideSASIframe(bid.adUnitCode);
  // push to render queue because ANOutstreamVideo may not be loaded yet
  bid.renderer.push(() => {
    const win = doc?.defaultView || window;
    win.ANOutstreamVideo.renderAd({
      tagId: bid.adResponse.tag_id,
      sizes: [bid.getSize().split('x')],
      targetId: bid.adUnitCode,
      // target div id to render video
      uuid: bid.adResponse.uuid,
      adResponse: bid.adResponse,
      rendererOptions: bid.renderer.getConfig()
    }, handleOutstreamRendererEvents.bind(null, bid));
  });
}
function handleOutstreamRendererEvents(bid, id, eventName) {
  bid.renderer.handleVideoEvent({
    id,
    eventName
  });
}
function parseMediaType(rtbBid) {
  const adType = rtbBid.ad_type;
  if (adType === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.VIDEO) {
    return _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.VIDEO;
  } else if (adType === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.NATIVE) {
    return _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.NATIVE;
  } else {
    return _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_2__.BANNER;
  }
}
function getBidFloor(bid) {
  if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isFn)(bid.getFloor)) {
    return bid.params.reserve ? bid.params.reserve : null;
  }
  let floor = bid.getFloor({
    currency: 'USD',
    mediaType: '*',
    size: '*'
  });
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.isPlainObject)(floor) && !isNaN(floor.floor) && floor.currency === 'USD') {
    return floor.floor;
  }
  return null;
}

// Convert device data to a format that AppNexus expects
function convertORTB2DeviceDataToAppNexusDeviceObject(ortb2DeviceData) {
  const _device = {
    useragent: ortb2DeviceData.ua,
    devicetype: ORTB2_DEVICE_TYPE_MAP.get(ortb2DeviceData.devicetype),
    make: ortb2DeviceData.make,
    model: ortb2DeviceData.model,
    os: ortb2DeviceData.os,
    os_version: ortb2DeviceData.osv,
    w: ortb2DeviceData.w,
    h: ortb2DeviceData.h,
    ppi: ortb2DeviceData.ppi,
    pxratio: ortb2DeviceData.pxratio
  };

  // filter out any empty values and return the object
  return Object.keys(_device).reduce((r, key) => {
    if (_device[key]) {
      r[key] = _device[key];
    }
    return r;
  }, {});
}
(0,_src_adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_15__.registerBidder)(spec);
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_16__.registerModule)('appnexusBidAdapter');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","appnexusUtils","transformParamsUtils","keywords","chunk","categoryTranslationMapping","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/appnexusBidAdapter.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["consentManagementGpp"],{

/***/ "./modules/consentManagementGpp.js":
/*!*****************************************!*\
  !*** ./modules/consentManagementGpp.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports consentConfig, GPPClient, toConsentData, resetConsentData, setConsentConfig, enrichFPDHook */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/adapterManager.js */ "./src/consentHandler.js");
/* harmony import */ var _src_fpd_enrichment_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/fpd/enrichment.js */ "./src/fpd/enrichment.js");
/* harmony import */ var _libraries_cmp_cmpClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libraries/cmp/cmpClient.js */ "./libraries/cmp/cmpClient.js");
/* harmony import */ var _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _libraries_consentManagement_cmUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../libraries/consentManagement/cmUtils.js */ "./libraries/consentManagement/cmUtils.js");

/**
 * This module adds GPP consentManagement support to prebid.js.  It interacts with
 * supported CMPs (Consent Management Platforms) to grab the user's consent information
 * and make it available for any GPP supported adapters to read/pass this information to
 * their system and for various other features/modules in Prebid.js.
 */







let consentConfig = {};
class GPPError {
  constructor(message, arg) {
    this.message = message;
    this.args = arg == null ? [] : [arg];
  }
}
class GPPClient {
  apiVersion = '1.1';
  static INST;
  static get() {
    let mkCmp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _libraries_cmp_cmpClient_js__WEBPACK_IMPORTED_MODULE_0__.cmpClient;
    if (this.INST == null) {
      const cmp = mkCmp({
        apiName: '__gpp',
        apiArgs: ['command', 'callback', 'parameter'],
        // do not pass version - not clear what it's for (or what we should use),
        mode: _libraries_cmp_cmpClient_js__WEBPACK_IMPORTED_MODULE_0__.MODE_CALLBACK
      });
      if (cmp == null) {
        throw new GPPError('GPP CMP not found');
      }
      this.INST = new this(cmp);
    }
    return this.INST;
  }
  #resolve;
  #reject;
  #pending = [];
  initialized = false;
  constructor(cmp) {
    this.cmp = cmp;
    [this.#resolve, this.#reject] = ['resolve', 'reject'].map(slot => result => {
      while (this.#pending.length) {
        this.#pending.pop()[slot](result);
      }
    });
  }

  /**
   * initialize this client - update consent data if already available,
   * and set up event listeners to also update on CMP changes
   *
   * @param pingData
   * @returns {Promise<{}>} a promise to GPP consent data
   */
  init(pingData) {
    const ready = this.updateWhenReady(pingData);
    if (!this.initialized) {
      if (pingData.gppVersion !== this.apiVersion) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Unrecognized GPP CMP version: ${pingData.apiVersion}. Continuing using GPP API version ${this.apiVersion}...`);
      }
      this.initialized = true;
      this.cmp({
        command: 'addEventListener',
        callback: (event, success) => {
          if (success != null && !success) {
            this.#reject(new GPPError('Received error response from CMP', event));
          } else if (event?.pingData?.cmpStatus === 'error') {
            this.#reject(new GPPError('CMP status is "error"; please check CMP setup', event));
          } else if (this.isCMPReady(event?.pingData || {}) && ['sectionChange', 'signalStatus'].includes(event?.eventName)) {
            this.#resolve(this.updateConsent(event.pingData));
          }
          // NOTE: according to https://github.com/InteractiveAdvertisingBureau/Global-Privacy-Platform/blob/main/Core/CMP%20API%20Specification.md,
          // > [signalStatus] Event is called whenever the display status of the CMP changes (e.g. the CMP shows the consent layer).
          //
          // however, from real world testing, at least some CMPs only trigger 'cmpDisplayStatus'
          // other CMPs may do something else yet; here we just look for 'signalStatus: not ready' on any event
          // to decide if consent data is likely to change
          if (_src_adapterManager_js__WEBPACK_IMPORTED_MODULE_2__.gppDataHandler.getConsentData() != null && event?.pingData != null && !this.isCMPReady(event.pingData)) {
            _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_2__.gppDataHandler.setConsentData(null);
          }
        }
      });
    }
    return ready;
  }
  refresh() {
    return this.cmp({
      command: 'ping'
    }).then(this.init.bind(this));
  }

  /**
   * Retrieve and store GPP consent data.
   *
   * @param pingData
   * @returns {Promise<{}>} a promise to GPP consent data
   */
  updateConsent(pingData) {
    return new _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_3__.PbPromise(resolve => {
      if (pingData == null || (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(pingData)) {
        throw new GPPError('Received empty response from CMP', pingData);
      }
      const consentData = parseConsentData(pingData);
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logInfo)('Retrieved GPP consent from CMP:', consentData);
      _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_2__.gppDataHandler.setConsentData(consentData);
      resolve(consentData);
    });
  }

  /**
   * Return a promise to GPP consent data, to be retrieved the next time the CMP signals it's ready.
   *
   * @returns {Promise<{}>}
   */
  nextUpdate() {
    const def = (0,_src_utils_promise_js__WEBPACK_IMPORTED_MODULE_3__.defer)();
    this.#pending.push(def);
    return def.promise;
  }

  /**
   * Return a promise to GPP consent data, to be retrieved immediately if the CMP is ready according to `pingData`,
   * or as soon as it signals that it's ready otherwise.
   *
   * @param pingData
   * @returns {Promise<{}>}
   */
  updateWhenReady(pingData) {
    return this.isCMPReady(pingData) ? this.updateConsent(pingData) : this.nextUpdate();
  }
  isCMPReady(pingData) {
    return pingData.signalStatus === 'ready';
  }
}
function lookupIabConsent() {
  return new _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_3__.PbPromise(resolve => resolve(GPPClient.get().refresh()));
}

// add new CMPs here, with their dedicated lookup function
const cmpCallMap = {
  'iab': lookupIabConsent
};
function parseConsentData(cmpData) {
  if (cmpData?.applicableSections != null && !Array.isArray(cmpData.applicableSections) || cmpData?.gppString != null && !(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isStr)(cmpData.gppString) || cmpData?.parsedSections != null && !(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(cmpData.parsedSections)) {
    throw new GPPError('CMP returned unexpected value during lookup process.', cmpData);
  }
  ['usnatv1', 'uscav1'].forEach(section => {
    if (cmpData?.parsedSections?.[section]) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Received invalid section from cmp: '${section}'. Some functionality may not work as expected`, cmpData);
    }
  });
  return toConsentData(cmpData);
}
function toConsentData() {
  let gppData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    gppString: gppData?.gppString,
    applicableSections: gppData?.applicableSections || [],
    parsedSections: gppData?.parsedSections || {},
    gppData: gppData
  };
}

/**
 * Simply resets the module's consentData variable back to undefined, mainly for testing purposes
 */
function resetConsentData() {
  consentConfig = {};
  _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_2__.gppDataHandler.reset();
  GPPClient.INST = null;
}
const parseConfig = (0,_libraries_consentManagement_cmUtils_js__WEBPACK_IMPORTED_MODULE_4__.configParser)({
  namespace: 'gpp',
  displayName: 'GPP',
  consentDataHandler: _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_2__.gppDataHandler,
  parseConsentData,
  getNullConsent: () => toConsentData(null),
  cmpHandlers: cmpCallMap
});
function setConsentConfig(config) {
  consentConfig = parseConfig(config);
  return consentConfig.loadConsentData?.()?.catch?.(() => null);
}
_src_config_js__WEBPACK_IMPORTED_MODULE_5__.config.getConfig('consentManagement', config => setConsentConfig(config.consentManagement));
function enrichFPDHook(next, fpd) {
  return next(fpd.then(ortb2 => {
    const consent = _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_2__.gppDataHandler.getConsentData();
    if (consent) {
      if (Array.isArray(consent.applicableSections)) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_6__.dset)(ortb2, 'regs.gpp_sid', consent.applicableSections);
      }
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_6__.dset)(ortb2, 'regs.gpp', consent.gppString);
    }
    return ortb2;
  }));
}
_src_fpd_enrichment_js__WEBPACK_IMPORTED_MODULE_7__.enrichFPD.before(enrichFPDHook);
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_8__.registerModule)('consentManagementGpp');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["cmp","consentManagement","chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/consentManagementGpp.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["consentManagementTcf"],{

/***/ "./modules/consentManagementTcf.js":
/*!*****************************************!*\
  !*** ./modules/consentManagementTcf.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports consentConfig, gdprScope, resetConsentData, setConsentConfig, enrichFPDHook, setOrtbAdditionalConsent */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/adapterManager.js */ "./src/consentHandler.js");
/* harmony import */ var _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/pbjsORTB.js */ "./src/pbjsORTB.js");
/* harmony import */ var _src_fpd_enrichment_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/fpd/enrichment.js */ "./src/fpd/enrichment.js");
/* harmony import */ var _libraries_cmp_cmpClient_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../libraries/cmp/cmpClient.js */ "./libraries/cmp/cmpClient.js");
/* harmony import */ var _libraries_consentManagement_cmUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../libraries/consentManagement/cmUtils.js */ "./libraries/consentManagement/cmUtils.js");

/**
 * This module adds GDPR consentManagement support to prebid.js.  It interacts with
 * supported CMPs (Consent Management Platforms) to grab the user's consent information
 * and make it available for any GDPR supported adapters to read/pass this information to
 * their system.
 */







let consentConfig = {};
let gdprScope;
let dsaPlatform;
const CMP_VERSION = 2;

// add new CMPs here, with their dedicated lookup function
const cmpCallMap = {
  'iab': lookupIabConsent
};

/**
 * This function handles interacting with an IAB compliant CMP to obtain the consent information of the user.
 */
function lookupIabConsent(setProvisionalConsent) {
  return new Promise((resolve, reject) => {
    function cmpResponseCallback(tcfData, success) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.logInfo)('Received a response from CMP', tcfData);
      if (success) {
        try {
          setProvisionalConsent(parseConsentData(tcfData));
        } catch (e) {}
        if (tcfData.gdprApplies === false || tcfData.eventStatus === 'tcloaded' || tcfData.eventStatus === 'useractioncomplete') {
          try {
            _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_1__.gdprDataHandler.setConsentData(parseConsentData(tcfData));
            resolve();
          } catch (e) {
            reject(e);
          }
        }
      } else {
        reject(Error('CMP unable to register callback function.  Please check CMP setup.'));
      }
    }
    const cmp = (0,_libraries_cmp_cmpClient_js__WEBPACK_IMPORTED_MODULE_2__.cmpClient)({
      apiName: '__tcfapi',
      apiVersion: CMP_VERSION,
      apiArgs: ['command', 'version', 'callback', 'parameter']
    });
    if (!cmp) {
      reject(new Error('TCF2 CMP not found.'));
    }
    if (cmp.isDirect) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.logInfo)('Detected CMP API is directly accessible, calling it now...');
    } else {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.logInfo)('Detected CMP is outside the current iframe where Prebid.js is located, calling it now...');
    }
    cmp({
      command: 'addEventListener',
      callback: cmpResponseCallback
    });
  });
}
function parseConsentData(consentObject) {
  function checkData() {
    // if CMP does not respond with a gdprApplies boolean, use defaultGdprScope (gdprScope)
    const gdprApplies = consentObject && typeof consentObject.gdprApplies === 'boolean' ? consentObject.gdprApplies : gdprScope;
    const tcString = consentObject && consentObject.tcString;
    return !!(typeof gdprApplies !== 'boolean' || gdprApplies === true && (!tcString || !(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr)(tcString)));
  }
  if (checkData()) {
    throw Object.assign(new Error(`CMP returned unexpected value during lookup process.`), {
      args: [consentObject]
    });
  } else {
    return toConsentData(consentObject);
  }
}
function toConsentData(cmpConsentObject) {
  const consentData = {
    consentString: cmpConsentObject ? cmpConsentObject.tcString : undefined,
    vendorData: cmpConsentObject || undefined,
    gdprApplies: cmpConsentObject && typeof cmpConsentObject.gdprApplies === 'boolean' ? cmpConsentObject.gdprApplies : gdprScope
  };
  if (cmpConsentObject && cmpConsentObject.addtlConsent && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr)(cmpConsentObject.addtlConsent)) {
    consentData.addtlConsent = cmpConsentObject.addtlConsent;
  }
  consentData.apiVersion = CMP_VERSION;
  return consentData;
}

/**
 * Simply resets the module's consentData variable back to undefined, mainly for testing purposes
 */
function resetConsentData() {
  consentConfig = {};
  _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_1__.gdprDataHandler.reset();
}
const parseConfig = (0,_libraries_consentManagement_cmUtils_js__WEBPACK_IMPORTED_MODULE_3__.configParser)({
  namespace: 'gdpr',
  displayName: 'TCF',
  consentDataHandler: _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_1__.gdprDataHandler,
  cmpHandlers: cmpCallMap,
  parseConsentData,
  getNullConsent: () => toConsentData(null)
});
/**
 * A configuration function that initializes some module variables, as well as add a hook into the requestBids function
 * @param {{cmp:string, timeout:number, defaultGdprScope:boolean}} config required; consentManagement module config settings; cmp (string), timeout (int))
 */
function setConsentConfig(config) {
  // if `config.gdpr`, `config.usp` or `config.gpp` exist, assume new config format.
  // else for backward compatability, just use `config`
  config = config && (config.gdpr || config.usp || config.gpp ? config.gdpr : config);
  if (config?.consentData?.getTCData != null) {
    config.consentData = config.consentData.getTCData;
  }
  gdprScope = config?.defaultGdprScope === true;
  dsaPlatform = !!config?.dsaPlatform;
  consentConfig = parseConfig({
    gdpr: config
  });
  return consentConfig.loadConsentData?.()?.catch?.(() => null);
}
_src_config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('consentManagement', config => setConsentConfig(config.consentManagement));
function enrichFPDHook(next, fpd) {
  return next(fpd.then(ortb2 => {
    const consent = _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_1__.gdprDataHandler.getConsentData();
    if (consent) {
      if (typeof consent.gdprApplies === 'boolean') {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.dset)(ortb2, 'regs.ext.gdpr', consent.gdprApplies ? 1 : 0);
      }
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.dset)(ortb2, 'user.ext.consent', consent.consentString);
    }
    if (dsaPlatform) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.dset)(ortb2, 'regs.ext.dsa.dsarequired', 3);
    }
    return ortb2;
  }));
}
_src_fpd_enrichment_js__WEBPACK_IMPORTED_MODULE_6__.enrichFPD.before(enrichFPDHook);
function setOrtbAdditionalConsent(ortbRequest, bidderRequest) {
  // this is not a standardized name for addtlConsent, so keep this as an ORTB library processor rather than an FPD enrichment
  const addtl = bidderRequest.gdprConsent?.addtlConsent;
  if (addtl && typeof addtl === 'string') {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.dset)(ortbRequest, 'user.ext.ConsentedProvidersSettings.consented_providers', addtl);
  }
}
(0,_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_7__.registerOrtbProcessor)({
  type: _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_7__.REQUEST,
  name: 'gdprAddtlConsent',
  fn: setOrtbAdditionalConsent
});
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_8__.registerModule)('consentManagementTcf');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","cmp","consentManagement","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/consentManagementTcf.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["consentManagementUsp"],{

/***/ "./modules/consentManagementUsp.js":
/*!*****************************************!*\
  !*** ./modules/consentManagementUsp.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports consentAPI, consentTimeout, staticConsentData, requestBidsHook, resetConsentData, setConsentConfig, enrichFPDHook */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/adapterManager.js */ "./src/adapterManager.js");
/* harmony import */ var _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/adapterManager.js */ "./src/consentHandler.js");
/* harmony import */ var _src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/utils/perfMetrics.js */ "./src/utils/perfMetrics.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_fpd_enrichment_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/fpd/enrichment.js */ "./src/fpd/enrichment.js");
/* harmony import */ var _libraries_cmp_cmpClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libraries/cmp/cmpClient.js */ "./libraries/cmp/cmpClient.js");

/**
 * This module adds USPAPI (CCPA) consentManagement support to prebid.js. It
 * interacts with supported USP Consent APIs to grab the user's consent
 * information and make it available for any USP (CCPA) supported adapters to
 * read/pass this information to their system.
 */







const DEFAULT_CONSENT_API = 'iab';
const DEFAULT_CONSENT_TIMEOUT = 50;
const USPAPI_VERSION = 1;
let consentAPI = DEFAULT_CONSENT_API;
let consentTimeout = DEFAULT_CONSENT_TIMEOUT;
let staticConsentData;
let consentData;
let enabled = false;

// consent APIs
const uspCallMap = {
  'iab': lookupUspConsent,
  'static': lookupStaticConsentData
};

/**
 * This function reads the consent string from the config to obtain the consent information of the user.
 */
function lookupStaticConsentData(_ref) {
  let {
    onSuccess,
    onError
  } = _ref;
  processUspData(staticConsentData, {
    onSuccess,
    onError
  });
}

/**
 * This function handles interacting with an USP compliant consent manager to obtain the consent information of the user.
 * Given the async nature of the USP's API, we pass in acting success/error callback functions to exit this function
 * based on the appropriate result.
 */
function lookupUspConsent(_ref2) {
  let {
    onSuccess,
    onError
  } = _ref2;
  function handleUspApiResponseCallbacks() {
    const uspResponse = {};
    function afterEach() {
      if (uspResponse.usPrivacy) {
        processUspData(uspResponse, {
          onSuccess,
          onError
        });
      } else {
        onError('Unable to get USP consent string.');
      }
    }
    return {
      consentDataCallback: (consentResponse, success) => {
        if (success && consentResponse.uspString) {
          uspResponse.usPrivacy = consentResponse.uspString;
        }
        afterEach();
      }
    };
  }
  let callbackHandler = handleUspApiResponseCallbacks();
  const cmp = (0,_libraries_cmp_cmpClient_js__WEBPACK_IMPORTED_MODULE_0__.cmpClient)({
    apiName: '__uspapi',
    apiVersion: USPAPI_VERSION,
    apiArgs: ['command', 'version', 'callback']
  });
  if (!cmp) {
    return onError('USP CMP not found.');
  }
  if (cmp.isDirect) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logInfo)('Detected USP CMP is directly accessible, calling it now...');
  } else {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logInfo)('Detected USP CMP is outside the current iframe where Prebid.js is located, calling it now...');
  }
  cmp({
    command: 'getUSPData',
    callback: callbackHandler.consentDataCallback
  });
  cmp({
    command: 'registerDeletion',
    callback: (res, success) => (success == null || success) && _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_2__["default"].callDataDeletionRequest(res)
  }).catch(e => {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)('Error invoking CMP `registerDeletion`:', e);
  });
}

/**
 * Lookup consent data and store it in the `consentData` global as well as `adapterManager.js`' uspDataHanlder.
 *
 * @param cb a callback that takes an error message and extra error arguments; all args will be undefined if consent
 * data was retrieved successfully.
 */
function loadConsentData(cb) {
  let timer = null;
  let isDone = false;
  function done(consentData, errMsg) {
    if (timer != null) {
      clearTimeout(timer);
    }
    isDone = true;
    _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_3__.uspDataHandler.setConsentData(consentData);
    if (cb != null) {
      for (var _len = arguments.length, extraArgs = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        extraArgs[_key - 2] = arguments[_key];
      }
      cb(errMsg, ...extraArgs);
    }
  }
  if (!uspCallMap[consentAPI]) {
    done(null, `USP framework (${consentAPI}) is not a supported framework. Aborting consentManagement module and resuming auction.`);
    return;
  }
  const callbacks = {
    onSuccess: done,
    onError: function (errMsg) {
      for (var _len2 = arguments.length, extraArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        extraArgs[_key2 - 1] = arguments[_key2];
      }
      done(null, `${errMsg} Resuming auction without consent data as per consentManagement config.`, ...extraArgs);
    }
  };
  uspCallMap[consentAPI](callbacks);
  if (!isDone) {
    if (consentTimeout === 0) {
      processUspData(undefined, callbacks);
    } else {
      timer = setTimeout(callbacks.onError.bind(null, 'USPAPI workflow exceeded timeout threshold.'), consentTimeout);
    }
  }
}

/**
 * If consentManagementUSP module is enabled (ie included in setConfig), this hook function will attempt to fetch the
 * user's encoded consent string from the supported USPAPI. Once obtained, the module will store this
 * data as part of a uspConsent object which gets transferred to adapterManager's uspDataHandler object.
 * This information is later added into the bidRequest object for any supported adapters to read/pass along to their system.
 * @param {object} reqBidsConfigObj required; This is the same param that's used in pbjs.requestBids.
 * @param {function} fn required; The next function in the chain, used by hook.js
 */
const requestBidsHook = (0,_src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_4__.timedAuctionHook)('usp', function requestBidsHook(fn, reqBidsConfigObj) {
  var _this = this;
  if (!enabled) {
    enableConsentManagement();
  }
  loadConsentData(function (errMsg) {
    if (errMsg != null) {
      for (var _len3 = arguments.length, extraArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        extraArgs[_key3 - 1] = arguments[_key3];
      }
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(errMsg, ...extraArgs);
    }
    fn.call(_this, reqBidsConfigObj);
  });
});

/**
 * This function checks the consent data provided by USPAPI to ensure it's in an expected state.
 * If it's bad, we exit the module depending on config settings.
 * If it's good, then we store the value and exit the module.
 *
 * @param {Object} consentObject - The object returned by USPAPI that contains the user's consent choices.
 * @param {Object} callbacks - An object containing the callback functions.
 * @param {function(string): void} callbacks.onSuccess - Callback accepting the resolved USP consent string.
 * @param {function(string, ...Object?): void} callbacks.onError - Callback accepting an error message and any extra error arguments (used purely for logging).
 */
function processUspData(consentObject, _ref3) {
  let {
    onSuccess,
    onError
  } = _ref3;
  const valid = !!(consentObject && consentObject.usPrivacy);
  if (!valid) {
    onError(`USPAPI returned unexpected value during lookup process.`, consentObject);
    return;
  }
  storeUspConsentData(consentObject);
  onSuccess(consentData);
}

/**
 * Stores USP data locally in module and then invokes uspDataHandler.setConsentData() to make information available in adaptermanger.js for later in the auction
 * @param {object} consentObject required; an object representing user's consent choices (can be undefined in certain use-cases for this function only)
 */
function storeUspConsentData(consentObject) {
  if (consentObject && consentObject.usPrivacy) {
    consentData = consentObject.usPrivacy;
  }
}

/**
 * Simply resets the module's consentData variable back to undefined, mainly for testing purposes
 */
function resetConsentData() {
  consentData = undefined;
  consentAPI = undefined;
  consentTimeout = undefined;
  _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_3__.uspDataHandler.reset();
  enabled = false;
}

/**
 * A configuration function that initializes some module variables, as well as add a hook into the requestBids function
 * @param {object} config required; consentManagementUSP module config settings; usp (string), timeout (int)
 */
function setConsentConfig(config) {
  config = config && config.usp;
  if (!config || typeof config !== 'object') {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)('consentManagement.usp config not defined, using defaults');
  }
  if (config && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isStr)(config.cmpApi)) {
    consentAPI = config.cmpApi;
  } else {
    consentAPI = DEFAULT_CONSENT_API;
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logInfo)(`consentManagement.usp config did not specify cmpApi. Using system default setting (${DEFAULT_CONSENT_API}).`);
  }
  if (config && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(config.timeout)) {
    consentTimeout = config.timeout;
  } else {
    consentTimeout = DEFAULT_CONSENT_TIMEOUT;
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logInfo)(`consentManagement.usp config did not specify timeout. Using system default setting (${DEFAULT_CONSENT_TIMEOUT}).`);
  }
  if (consentAPI === 'static') {
    if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(config.consentData) && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(config.consentData.getUSPData)) {
      if (config.consentData.getUSPData.uspString) staticConsentData = {
        usPrivacy: config.consentData.getUSPData.uspString
      };
      consentTimeout = 0;
    } else {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`consentManagement config with cmpApi: 'static' did not specify consentData. No consents will be available to adapters.`);
    }
  }
  enableConsentManagement(true);
}
function enableConsentManagement() {
  let configFromUser = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  if (!enabled) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logInfo)(`USPAPI consentManagement module has been activated${configFromUser ? '' : ` using default values (api: '${consentAPI}', timeout: ${consentTimeout}ms)`}`);
    enabled = true;
    _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_3__.uspDataHandler.enable();
  }
  loadConsentData(); // immediately look up consent data to make it available without requiring an auction
}
_src_config_js__WEBPACK_IMPORTED_MODULE_5__.config.getConfig('consentManagement', config => setConsentConfig(config.consentManagement));
(0,_src_hook_js__WEBPACK_IMPORTED_MODULE_6__.getHook)('requestBids').before(requestBidsHook, 50);
function enrichFPDHook(next, fpd) {
  return next(fpd.then(ortb2 => {
    const consent = _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_3__.uspDataHandler.getConsentData();
    if (consent) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__.dset)(ortb2, 'regs.ext.us_privacy', consent);
    }
    return ortb2;
  }));
}
_src_fpd_enrichment_js__WEBPACK_IMPORTED_MODULE_8__.enrichFPD.before(enrichFPDHook);
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_9__.registerModule)('consentManagementUsp');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["cmp","chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/consentManagementUsp.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["conversantBidAdapter"],{

/***/ "./modules/conversantBidAdapter.js":
/*!*****************************************!*\
  !*** ./modules/conversantBidAdapter.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony export spec */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _src_adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/adapters/bidderFactory.js */ "./src/adapters/bidderFactory.js");
/* harmony import */ var _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/mediaTypes.js */ "./src/mediaTypes.js");
/* harmony import */ var _libraries_ortbConverter_converter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libraries/ortbConverter/converter.js */ "./libraries/ortbConverter/converter.js");
/* harmony import */ var _libraries_ortbConverter_processors_mediaType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../libraries/ortbConverter/processors/mediaType.js */ "./libraries/ortbConverter/processors/mediaType.js");







// Maintainer: mediapsr@epsilon.com

/**
 * @typedef {import('../src/adapters/bidderFactory.js').BidRequest} BidRequest
 * @typedef {import('../src/adapters/bidderFactory.js').Bid} Bid
 * @typedef {import('../src/adapters/bidderFactory.js').ServerRequest} ServerRequest
 * @typedef {import('../src/adapters/bidderFactory.js').Device} Device
 */

const GVLID = 24;
const BIDDER_CODE = 'conversant';
const URL = 'https://web.hb.ad.cpe.dotomi.com/cvx/client/hb/ortb/25';
function setSiteId(bidRequest, request) {
  if (bidRequest.params.site_id) {
    if (request.site) {
      request.site.id = bidRequest.params.site_id;
    }
    if (request.app) {
      request.app.id = bidRequest.params.site_id;
    }
  }
}
const converter = (0,_libraries_ortbConverter_converter_js__WEBPACK_IMPORTED_MODULE_0__.ortbConverter)({
  context: {
    netRevenue: true,
    ttl: 300
  },
  request: function (buildRequest, imps, bidderRequest, context) {
    const request = buildRequest(imps, bidderRequest, context);
    request.at = 1;
    request.cur = ['USD'];
    if (context.bidRequests) {
      const bidRequest = context.bidRequests[0];
      setSiteId(bidRequest, request);
    }
    return request;
  },
  imp(buildImp, bidRequest, context) {
    const imp = buildImp(bidRequest, context);
    const data = {
      secure: 1,
      bidfloor: getBidFloor(bidRequest) || 0,
      displaymanager: 'Prebid.js',
      displaymanagerver: "9.49.0-pre"
    };
    copyOptProperty(bidRequest.params.tag_id, data, 'tagid');
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeep)(imp, data, imp);
    return imp;
  },
  bidResponse: function (buildBidResponse, bid, context) {
    if (!bid.price) return;

    // ensure that context.mediaType is set to banner or video otherwise
    if (!context.mediaType && context.bidRequest.mediaTypes) {
      const [type] = Object.keys(context.bidRequest.mediaTypes);
      if (Object.values(_libraries_ortbConverter_processors_mediaType_js__WEBPACK_IMPORTED_MODULE_2__.ORTB_MTYPES).includes(type)) {
        context.mediaType = type;
      }
    }
    const bidResponse = buildBidResponse(bid, context);
    return bidResponse;
  },
  response(buildResponse, bidResponses, ortbResponse, context) {
    const response = buildResponse(bidResponses, ortbResponse, context);
    return response;
  },
  overrides: {
    imp: {
      banner(fillBannerImp, imp, bidRequest, context) {
        if (bidRequest.mediaTypes && !bidRequest.mediaTypes.banner) return;
        if (bidRequest.params.position) {
          // fillBannerImp looks for mediaTypes.banner.pos so put it under the right name here
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeep)(bidRequest, {
            mediaTypes: {
              banner: {
                pos: bidRequest.params.position
              }
            }
          });
        }
        fillBannerImp(imp, bidRequest, context);
      },
      video(fillVideoImp, imp, bidRequest, context) {
        if (bidRequest.mediaTypes && !bidRequest.mediaTypes.video) return;
        const videoData = {};
        copyOptProperty(bidRequest.params?.position, videoData, 'pos');
        copyOptProperty(bidRequest.params?.mimes, videoData, 'mimes');
        copyOptProperty(bidRequest.params?.maxduration, videoData, 'maxduration');
        copyOptProperty(bidRequest.params?.protocols, videoData, 'protocols');
        copyOptProperty(bidRequest.params?.api, videoData, 'api');
        imp.video = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeep)(videoData, imp.video);
        fillVideoImp(imp, bidRequest, context);
      }
    }
  }
});
const spec = {
  code: BIDDER_CODE,
  gvlid: GVLID,
  aliases: ['cnvr', 'epsilon'],
  // short code
  supportedMediaTypes: [_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_3__.BANNER, _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_3__.VIDEO, _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_3__.NATIVE],
  /**
   * Determines whether or not the given bid request is valid.
   *
   * @param {BidRequest} bid - The bid params to validate.
   * @return {boolean} True if this is a valid bid, and false otherwise.
   */
  isBidRequestValid: function (bid) {
    if (!bid || !bid.params) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(BIDDER_CODE + ': Missing bid parameters');
      return false;
    }
    if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isStr)(bid.params.site_id)) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(BIDDER_CODE + ': site_id must be specified as a string');
      return false;
    }
    if (isVideoRequest(bid)) {
      const mimes = bid.params.mimes || (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__["default"])(bid, 'mediaTypes.video.mimes');
      if (!mimes) {
        // Give a warning but let it pass
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(BIDDER_CODE + ': mimes should be specified for videos');
      } else if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(mimes) || !mimes.every(s => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isStr)(s))) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(BIDDER_CODE + ': mimes must be an array of strings');
        return false;
      }
    }
    return true;
  },
  buildRequests: function (bidRequests, bidderRequest) {
    const payload = converter.toORTB({
      bidderRequest,
      bidRequests
    });
    const result = {
      method: 'POST',
      url: makeBidUrl(bidRequests[0]),
      data: payload
    };
    return result;
  },
  /**
   * Unpack the response from the server into a list of bids.
   *
   * @param {*} serverResponse A successful response from the server.
   * @param bidRequest
   * @return {Bid[]} An array of bids which were nested inside the server.
   */
  interpretResponse: function (serverResponse, bidRequest) {
    const ortbBids = converter.fromORTB({
      request: bidRequest.data,
      response: serverResponse.body
    });
    return ortbBids;
  },
  /**
   * Register User Sync.
   */
  getUserSyncs: function (syncOptions, responses, gdprConsent, uspConsent) {
    let params = {};
    const syncs = [];

    // Attaching GDPR Consent Params in UserSync url
    if (gdprConsent) {
      params.gdpr = gdprConsent.gdprApplies ? 1 : 0;
      params.gdpr_consent = encodeURIComponent(gdprConsent.consentString || '');
    }

    // CCPA
    if (uspConsent) {
      params.us_privacy = encodeURIComponent(uspConsent);
    }
    if (responses && responses.ext) {
      const pixels = [{
        urls: responses.ext.fsyncs,
        type: 'iframe'
      }, {
        urls: responses.ext.psyncs,
        type: 'image'
      }].filter(entry => {
        return entry.urls && (entry.type === 'iframe' && syncOptions.iframeEnabled || entry.type === 'image' && syncOptions.pixelEnabled);
      }).map(entry => {
        return entry.urls.map(endpoint => {
          let urlInfo = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.parseUrl)(endpoint);
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeep)(urlInfo.search, params);
          if (Object.keys(urlInfo.search).length === 0) {
            delete urlInfo.search; // empty search object causes buildUrl to add a trailing ? to the url
          }
          return {
            type: entry.type,
            url: (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.buildUrl)(urlInfo)
          };
        }).reduce((x, y) => x.concat(y), []);
      }).reduce((x, y) => x.concat(y), []);
      syncs.push(...pixels);
    }
    return syncs;
  }
};

/**
 * Check if it's a video bid request
 *
 * @param {BidRequest} bid - Bid request generated from ad slots
 * @returns {boolean} True if it's a video bid
 */
function isVideoRequest(bid) {
  return bid.mediaType === 'video' || !!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__["default"])(bid, 'mediaTypes.video');
}

/**
 * Copy property if exists from src to dst
 *
 * @param {object} src - source object
 * @param {object} dst - destination object
 * @param {string} dstName - destination property name
 */
function copyOptProperty(src, dst, dstName) {
  if (src) {
    dst[dstName] = src;
  }
}

/**
 * Get the floor price from bid.params for backward compatibility.
 * If not found, then check floor module.
 * @param bid A valid bid object
 * @returns {*|number} floor price
 */
function getBidFloor(bid) {
  let floor = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.getBidIdParameter)('bidfloor', bid.params);
  if (!floor && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFn)(bid.getFloor)) {
    const floorObj = bid.getFloor({
      currency: 'USD',
      mediaType: '*',
      size: '*'
    });
    if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(floorObj) && !isNaN(floorObj.floor) && floorObj.currency === 'USD') {
      floor = floorObj.floor;
    }
  }
  return floor;
}
function makeBidUrl(bid) {
  let bidurl = URL;
  if (bid.params.white_label_url) {
    bidurl = bid.params.white_label_url;
  }
  return bidurl;
}
(0,_src_adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_5__.registerBidder)(spec);
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_6__.registerModule)('conversantBidAdapter');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","ortbConverter","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/conversantBidAdapter.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["currency"],{

/***/ "./modules/currency.js":
/*!*****************************!*\
  !*** ./modules/currency.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports currencySupportEnabled, currencyRates, responseReady, setConfig, resetCurrency, addBidResponseHook, setOrtbCurrency, requestBidsHook */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _src_constants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/constants.js */ "./src/constants.js");
/* harmony import */ var _src_ajax_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/ajax.js */ "./src/ajax.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/pbjsORTB.js */ "./src/pbjsORTB.js");
/* harmony import */ var _src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/utils/perfMetrics.js */ "./src/utils/perfMetrics.js");
/* harmony import */ var _src_events_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/events.js */ "./src/events.js");
/* harmony import */ var _src_fpd_enrichment_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/fpd/enrichment.js */ "./src/fpd/enrichment.js");
/* harmony import */ var _libraries_timeoutQueue_timeoutQueue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libraries/timeoutQueue/timeoutQueue.js */ "./libraries/timeoutQueue/timeoutQueue.js");













const DEFAULT_CURRENCY_RATE_URL = 'https://cdn.jsdelivr.net/gh/prebid/currency-file@1/latest.json?date=$$TODAY$$';
const CURRENCY_RATE_PRECISION = 4;
const MODULE_NAME = 'currency';
let ratesURL;
let bidResponseQueue = [];
let conversionCache = {};
let currencyRatesLoaded = false;
let needToCallForCurrencyFile = true;
let adServerCurrency = 'USD';
var currencySupportEnabled = false;
var currencyRates = {};
let bidderCurrencyDefault = {};
let defaultRates;
let responseReady = (0,_src_utils_promise_js__WEBPACK_IMPORTED_MODULE_0__.defer)();
const delayedAuctions = (0,_libraries_timeoutQueue_timeoutQueue_js__WEBPACK_IMPORTED_MODULE_1__.timeoutQueue)();
let auctionDelay = 0;

/**
 * Configuration function for currency
 * @param {object} config
 * @param  {string} [config.adServerCurrency = 'USD']
 *  ISO 4217 3-letter currency code that represents the target currency. (e.g. 'EUR').  If this value is present,
 *  the currency conversion feature is activated.
 * @param  {number} [config.granularityMultiplier = 1]
 *  A decimal value representing how mcuh to scale the price granularity calculations.
 * @param  {object} config.bidderCurrencyDefault
 *  An optional argument to specify bid currencies for bid adapters.  This option is provided for the transitional phase
 *  before every bid adapter will specify its own bid currency.  If the adapter specifies a bid currency, this value is
 *  ignored for that bidder.
 *
 *  example:
 *  {
 *    rubicon: 'USD'
 *  }
 * @param  {string} [config.conversionRateFile = 'URL pointing to conversion file']
 *  Optional path to a file containing currency conversion data.  Prebid.org hosts a file that is used as the default,
 *  if not specified.
 * @param  {object} [config.rates]
 *  This optional argument allows you to specify the rates with a JSON object, subverting the need for a external
 *  config.conversionRateFile parameter.  If this argument is specified, the conversion rate file will not be loaded.
 *
 *  example:
 *  {
 *    'GBP': { 'CNY': 8.8282, 'JPY': 141.7, 'USD': 1.2824 },
 *    'USD': { 'CNY': 6.8842, 'GBP': 0.7798, 'JPY': 110.49 }
 *  }
 *  @param {object} [config.defaultRates]
 *  This optional currency rates definition follows the same format as config.rates, however it is only utilized if
 *  there is an error loading the config.conversionRateFile.
 */
function setConfig(config) {
  ratesURL = DEFAULT_CURRENCY_RATE_URL;
  if (config.rates !== null && typeof config.rates === 'object') {
    currencyRates.conversions = config.rates;
    currencyRatesLoaded = true;
    needToCallForCurrencyFile = false; // don't call if rates are already specified
  }
  if (config.defaultRates !== null && typeof config.defaultRates === 'object') {
    defaultRates = config.defaultRates;

    // set up the default rates to be used if the rate file doesn't get loaded in time
    currencyRates.conversions = defaultRates;
    currencyRatesLoaded = true;
  }
  if (typeof config.adServerCurrency === 'string') {
    auctionDelay = config.auctionDelay;
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)('enabling currency support', arguments);
    adServerCurrency = config.adServerCurrency;
    if (config.conversionRateFile) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)('currency using override conversionRateFile:', config.conversionRateFile);
      ratesURL = config.conversionRateFile;
    }

    // see if the url contains a date macro
    // this is a workaround to the fact that jsdelivr doesn't currently support setting a 24-hour HTTP cache header
    // So this is an approach to let the browser cache a copy of the file each day
    // We should remove the macro once the CDN support a day-level HTTP cache setting
    const macroLocation = ratesURL.indexOf('$$TODAY$$');
    if (macroLocation !== -1) {
      // get the date to resolve the macro
      const d = new Date();
      let month = `${d.getMonth() + 1}`;
      let day = `${d.getDate()}`;
      if (month.length < 2) month = `0${month}`;
      if (day.length < 2) day = `0${day}`;
      const todaysDate = `${d.getFullYear()}${month}${day}`;

      // replace $$TODAY$$ with todaysDate
      ratesURL = `${ratesURL.substring(0, macroLocation)}${todaysDate}${ratesURL.substring(macroLocation + 9, ratesURL.length)}`;
    }
    initCurrency();
  } else {
    // currency support is disabled, setting defaults
    auctionDelay = 0;
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)('disabling currency support');
    resetCurrency();
  }
  if (typeof config.bidderCurrencyDefault === 'object') {
    bidderCurrencyDefault = config.bidderCurrencyDefault;
  }
}
_src_config_js__WEBPACK_IMPORTED_MODULE_3__.config.getConfig('currency', config => setConfig(config.currency));
function errorSettingsRates(msg) {
  if (defaultRates) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)(msg);
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)('Currency failed loading rates, falling back to currency.defaultRates');
  } else {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)(msg);
  }
}
function loadRates() {
  if (needToCallForCurrencyFile) {
    needToCallForCurrencyFile = false;
    currencyRatesLoaded = false;
    (0,_src_ajax_js__WEBPACK_IMPORTED_MODULE_4__.ajax)(ratesURL, {
      success: function (response) {
        try {
          currencyRates = JSON.parse(response);
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)('currencyRates set to ' + JSON.stringify(currencyRates));
          conversionCache = {};
          currencyRatesLoaded = true;
          processBidResponseQueue();
          delayedAuctions.resume();
        } catch (e) {
          errorSettingsRates('Failed to parse currencyRates response: ' + response);
        }
      },
      error: function () {
        errorSettingsRates(...arguments);
        currencyRatesLoaded = true;
        processBidResponseQueue();
        delayedAuctions.resume();
        needToCallForCurrencyFile = true;
      }
    });
  } else {
    processBidResponseQueue();
  }
}
function initCurrency() {
  conversionCache = {};
  if (!currencySupportEnabled) {
    currencySupportEnabled = true;
    // Adding conversion function to prebid global for external module and on page use
    (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_5__.getGlobal)().convertCurrency = (cpm, fromCurrency, toCurrency) => parseFloat(cpm) * getCurrencyConversion(fromCurrency, toCurrency);
    (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_6__.getHook)('addBidResponse').before(addBidResponseHook, 100);
    (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_6__.getHook)('responsesReady').before(responsesReadyHook);
    _src_fpd_enrichment_js__WEBPACK_IMPORTED_MODULE_7__.enrichFPD.before(enrichFPDHook);
    (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_6__.getHook)('requestBids').before(requestBidsHook, 50);
    (0,_src_events_js__WEBPACK_IMPORTED_MODULE_8__.on)(_src_constants_js__WEBPACK_IMPORTED_MODULE_9__.EVENTS.AUCTION_TIMEOUT, rejectOnAuctionTimeout);
    (0,_src_events_js__WEBPACK_IMPORTED_MODULE_8__.on)(_src_constants_js__WEBPACK_IMPORTED_MODULE_9__.EVENTS.AUCTION_INIT, loadRates);
    loadRates();
  }
}
function resetCurrency() {
  if (currencySupportEnabled) {
    (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_6__.getHook)('addBidResponse').getHooks({
      hook: addBidResponseHook
    }).remove();
    (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_6__.getHook)('responsesReady').getHooks({
      hook: responsesReadyHook
    }).remove();
    _src_fpd_enrichment_js__WEBPACK_IMPORTED_MODULE_7__.enrichFPD.getHooks({
      hook: enrichFPDHook
    }).remove();
    (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_6__.getHook)('requestBids').getHooks({
      hook: requestBidsHook
    }).remove();
    (0,_src_events_js__WEBPACK_IMPORTED_MODULE_8__.off)(_src_constants_js__WEBPACK_IMPORTED_MODULE_9__.EVENTS.AUCTION_TIMEOUT, rejectOnAuctionTimeout);
    (0,_src_events_js__WEBPACK_IMPORTED_MODULE_8__.off)(_src_constants_js__WEBPACK_IMPORTED_MODULE_9__.EVENTS.AUCTION_INIT, loadRates);
    delete (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_5__.getGlobal)().convertCurrency;
    adServerCurrency = 'USD';
    conversionCache = {};
    currencySupportEnabled = false;
    currencyRatesLoaded = false;
    needToCallForCurrencyFile = true;
    currencyRates = {};
    bidderCurrencyDefault = {};
    responseReady = (0,_src_utils_promise_js__WEBPACK_IMPORTED_MODULE_0__.defer)();
  }
}
function responsesReadyHook(next, ready) {
  next(ready.then(() => responseReady.promise));
}
const addBidResponseHook = (0,_src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_10__.timedBidResponseHook)('currency', function addBidResponseHook(fn, adUnitCode, bid, reject) {
  if (!bid) {
    return fn.call(this, adUnitCode, bid, reject); // if no bid, call original and let it display warnings
  }
  let bidder = bid.bidderCode || bid.bidder;
  if (bidderCurrencyDefault[bidder]) {
    let currencyDefault = bidderCurrencyDefault[bidder];
    if (bid.currency && currencyDefault !== bid.currency) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)(`Currency default '${bidder}: ${currencyDefault}' ignored. adapter specified '${bid.currency}'`);
    } else {
      bid.currency = currencyDefault;
    }
  }

  // default to USD if currency not set
  if (!bid.currency) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)('Currency not specified on bid.  Defaulted to "USD"');
    bid.currency = 'USD';
  }

  // used for analytics
  bid.getCpmInNewCurrency = function (toCurrency) {
    return (parseFloat(this.cpm) * getCurrencyConversion(this.currency, toCurrency)).toFixed(3);
  };

  // execute immediately if the bid is already in the desired currency
  if (bid.currency === adServerCurrency) {
    return fn.call(this, adUnitCode, bid, reject);
  }
  bidResponseQueue.push([fn, this, adUnitCode, bid, reject]);
  if (!currencySupportEnabled || currencyRatesLoaded) {
    processBidResponseQueue();
  }
});
function rejectOnAuctionTimeout(_ref) {
  let {
    auctionId
  } = _ref;
  bidResponseQueue = bidResponseQueue.filter(_ref2 => {
    let [fn, ctx, adUnitCode, bid, reject] = _ref2;
    if (bid.auctionId === auctionId) {
      reject(_src_constants_js__WEBPACK_IMPORTED_MODULE_9__.REJECTION_REASON.CANNOT_CONVERT_CURRENCY);
    } else {
      return true;
    }
  });
}
function processBidResponseQueue() {
  while (bidResponseQueue.length > 0) {
    const [fn, ctx, adUnitCode, bid, reject] = bidResponseQueue.shift();
    if (bid !== undefined && 'currency' in bid && 'cpm' in bid) {
      let fromCurrency = bid.currency;
      try {
        let conversion = getCurrencyConversion(fromCurrency);
        if (conversion !== 1) {
          bid.cpm = (parseFloat(bid.cpm) * conversion).toFixed(4);
          bid.currency = adServerCurrency;
        }
      } catch (e) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)('getCurrencyConversion threw error: ', e);
        reject(_src_constants_js__WEBPACK_IMPORTED_MODULE_9__.REJECTION_REASON.CANNOT_CONVERT_CURRENCY);
        continue;
      }
    }
    fn.call(ctx, adUnitCode, bid, reject);
  }
  responseReady.resolve();
}
function getCurrencyConversion(fromCurrency) {
  let toCurrency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : adServerCurrency;
  var conversionRate = null;
  var rates;
  let cacheKey = `${fromCurrency}->${toCurrency}`;
  if (cacheKey in conversionCache) {
    conversionRate = conversionCache[cacheKey];
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logMessage)('Using conversionCache value ' + conversionRate + ' for ' + cacheKey);
  } else if (currencySupportEnabled === false) {
    if (fromCurrency === 'USD') {
      conversionRate = 1;
    } else {
      throw new Error('Prebid currency support has not been enabled and fromCurrency is not USD');
    }
  } else if (fromCurrency === toCurrency) {
    conversionRate = 1;
  } else {
    if (fromCurrency in currencyRates.conversions) {
      // using direct conversion rate from fromCurrency to toCurrency
      rates = currencyRates.conversions[fromCurrency];
      if (!(toCurrency in rates)) {
        // bid should fail, currency is not supported
        throw new Error('Specified adServerCurrency in config \'' + toCurrency + '\' not found in the currency rates file');
      }
      conversionRate = rates[toCurrency];
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)('getCurrencyConversion using direct ' + fromCurrency + ' to ' + toCurrency + ' conversionRate ' + conversionRate);
    } else if (toCurrency in currencyRates.conversions) {
      // using reciprocal of conversion rate from toCurrency to fromCurrency
      rates = currencyRates.conversions[toCurrency];
      if (!(fromCurrency in rates)) {
        // bid should fail, currency is not supported
        throw new Error('Specified fromCurrency \'' + fromCurrency + '\' not found in the currency rates file');
      }
      conversionRate = roundFloat(1 / rates[fromCurrency], CURRENCY_RATE_PRECISION);
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)('getCurrencyConversion using reciprocal ' + fromCurrency + ' to ' + toCurrency + ' conversionRate ' + conversionRate);
    } else {
      // first defined currency base used as intermediary
      var anyBaseCurrency = Object.keys(currencyRates.conversions)[0];
      if (!(fromCurrency in currencyRates.conversions[anyBaseCurrency])) {
        // bid should fail, currency is not supported
        throw new Error('Specified fromCurrency \'' + fromCurrency + '\' not found in the currency rates file');
      }
      var toIntermediateConversionRate = 1 / currencyRates.conversions[anyBaseCurrency][fromCurrency];
      if (!(toCurrency in currencyRates.conversions[anyBaseCurrency])) {
        // bid should fail, currency is not supported
        throw new Error('Specified adServerCurrency in config \'' + toCurrency + '\' not found in the currency rates file');
      }
      var fromIntermediateConversionRate = currencyRates.conversions[anyBaseCurrency][toCurrency];
      conversionRate = roundFloat(toIntermediateConversionRate * fromIntermediateConversionRate, CURRENCY_RATE_PRECISION);
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)('getCurrencyConversion using intermediate ' + fromCurrency + ' thru ' + anyBaseCurrency + ' to ' + toCurrency + ' conversionRate ' + conversionRate);
    }
  }
  if (!(cacheKey in conversionCache)) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logMessage)('Adding conversionCache value ' + conversionRate + ' for ' + cacheKey);
    conversionCache[cacheKey] = conversionRate;
  }
  return conversionRate;
}
function roundFloat(num, dec) {
  var d = 1;
  for (let i = 0; i < dec; i++) {
    d += '0';
  }
  return Math.round(num * d) / d;
}
function setOrtbCurrency(ortbRequest, bidderRequest, context) {
  if (currencySupportEnabled) {
    ortbRequest.cur = ortbRequest.cur || [context.currency || adServerCurrency];
  }
}
(0,_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_11__.registerOrtbProcessor)({
  type: _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_11__.REQUEST,
  name: 'currency',
  fn: setOrtbCurrency
});
function enrichFPDHook(next, fpd) {
  return next(fpd.then(ortb2 => {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_12__.dset)(ortb2, 'ext.prebid.adServerCurrency', adServerCurrency);
    return ortb2;
  }));
}
const requestBidsHook = (0,_src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_10__.timedAuctionHook)('currency', function requestBidsHook(fn, reqBidsConfigObj) {
  const continueAuction = (that => () => fn.call(that, reqBidsConfigObj))(this);
  if (!currencyRatesLoaded && auctionDelay > 0) {
    delayedAuctions.submit(auctionDelay, continueAuction, () => {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)(`${MODULE_NAME}: Fetch attempt did not return in time for auction ${reqBidsConfigObj.auctionId}`);
      continueAuction();
    });
  } else {
    continueAuction();
  }
});
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_5__.registerModule)('currency');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","timeoutQueue","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/currency.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["debugging"],{

/***/ "./modules/debugging/bidInterceptor.js":
/*!*********************************************!*\
  !*** ./modules/debugging/bidInterceptor.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidInterceptor: () => (/* binding */ BidInterceptor)
/* harmony export */ });
/* harmony import */ var _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/mediaTypes.js */ "./src/mediaTypes.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _responses_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./responses.js */ "./modules/debugging/responses.js");




/**
 * @typedef {Number|String|boolean|null|undefined} Scalar
 */

function BidInterceptor() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  ({
    setTimeout: this.setTimeout = window.setTimeout.bind(window)
  } = opts);
  this.logger = opts.logger;
  this.rules = [];
}
Object.assign(BidInterceptor.prototype, {
  DEFAULT_RULE_OPTIONS: {
    delay: 0
  },
  serializeConfig(ruleDefs) {
    const isSerializable = (ruleDef, i) => {
      const serializable = !(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.hasNonSerializableProperty)(ruleDef);
      if (!serializable && !(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"])(ruleDef, 'options.suppressWarnings')) {
        this.logger.logWarn(`Bid interceptor rule definition #${i + 1} contains non-serializable properties and will be lost after a refresh. Rule definition: `, ruleDef);
      }
      return serializable;
    };
    return ruleDefs.filter(isSerializable);
  },
  updateConfig(config) {
    this.rules = (config.intercept || []).map((ruleDef, i) => this.rule(ruleDef, i + 1));
  },
  /**
   * @typedef {Object} RuleOptions
   * @property {Number} [delay=0] delay between bid interception and mocking of response (to simulate network delay)
   * @property {boolean} [suppressWarnings=false] if enabled, do not warn about unserializable rules
   *
   * @typedef {Object} Rule
   * @property {Number} no rule number (used only as an identifier for logging)
   * @property {function({}, {}): boolean} match a predicate function that tests a bid against this rule
   * @property {ReplacerFn} replacer generator function for mock bid responses
   * @property {RuleOptions} options
   */

  /**
   * @param {{}} ruleDef
   * @param {Number} ruleNo
   * @returns {Rule}
   */
  rule(ruleDef, ruleNo) {
    return {
      no: ruleNo,
      match: this.matcher(ruleDef.when, ruleNo),
      replace: this.replacer(ruleDef.then, ruleNo),
      options: Object.assign({}, this.DEFAULT_RULE_OPTIONS, ruleDef.options),
      paapi: this.paapiReplacer(ruleDef.paapi || [], ruleNo)
    };
  },
  /**
   * @typedef {Function} MatchPredicate
   * @param {*} candidate a bid to match, or a portion of it if used inside an ObjectMather.
   * e.g. matcher((bid, bidRequest) => ....) or matcher({property: (property, bidRequest) => ...})
   * @param {Object} bidRequest the request `candidate` belongs to
   * @returns {boolean}
   *
   * @typedef {Object.<string, Scalar|RegExp|MatchPredicate|ObjectMatcher>} ObjectMatcher
   */

  /**
   * @param {MatchPredicate|ObjectMatcher} matchDef matcher definition
   * @param {Number} ruleNo
   * @returns {MatchPredicate} a predicate function that matches a bid against the given `matchDef`
   */
  matcher(matchDef, ruleNo) {
    if (typeof matchDef === 'function') {
      return matchDef;
    }
    if (typeof matchDef !== 'object') {
      this.logger.logError(`Invalid 'when' definition for debug bid interceptor (in rule #${ruleNo})`);
      return () => false;
    }
    function matches(candidate, _ref) {
      let {
        ref = matchDef,
        args = []
      } = _ref;
      return Object.entries(ref).map(_ref2 => {
        let [key, val] = _ref2;
        const cVal = candidate[key];
        if (val instanceof RegExp) {
          return val.exec(cVal) != null;
        }
        if (typeof val === 'function') {
          return !!val(cVal, ...args);
        }
        if (typeof val === 'object') {
          return matches(cVal, {
            ref: val,
            args
          });
        }
        return cVal === val;
      }).every(i => i);
    }
    return function (candidate) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return matches(candidate, {
        args
      });
    };
  },
  /**
   * @typedef {Function} ReplacerFn
   * @param {*} bid a bid that was intercepted
   * @param {Object} bidRequest the request `bid` belongs to
   * @returns {*} the response to mock for `bid`, or a portion of it if used inside an ObjectReplacer.
   * e.g. replacer((bid, bidRequest) => mockResponse) or replacer({property: (bid, bidRequest) => mockProperty})
   *
   * @typedef {Object.<string, ReplacerFn|ObjectReplacer|*>} ObjectReplacer
   */

  /**
   * @param {ReplacerFn|ObjectReplacer} replDef replacer definition
   * @param ruleNo
   * @return {ReplacerFn}
   */
  replacer(replDef, ruleNo) {
    var _this = this;
    if (replDef === null) {
      return () => null;
    }
    replDef = replDef || {};
    let replFn;
    if (typeof replDef === 'function') {
      replFn = _ref3 => {
        let {
          args
        } = _ref3;
        return replDef(...args);
      };
    } else if (typeof replDef !== 'object') {
      this.logger.logError(`Invalid 'then' definition for debug bid interceptor (in rule #${ruleNo})`);
      replFn = () => ({});
    } else {
      replFn = _ref4 => {
        let {
          args,
          ref = replDef
        } = _ref4;
        const result = Array.isArray(ref) ? [] : {};
        Object.entries(ref).forEach(_ref5 => {
          let [key, val] = _ref5;
          if (typeof val === 'function') {
            result[key] = val(...args);
          } else if (val != null && typeof val === 'object') {
            result[key] = replFn({
              args,
              ref: val
            });
          } else {
            result[key] = val;
          }
        });
        return result;
      };
    }
    return function (bid) {
      const response = _this.responseDefaults(bid);
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.mergeDeep)(response, replFn({
        args: [bid, ...args]
      }));
      const resolver = _responses_js__WEBPACK_IMPORTED_MODULE_2__["default"][response.mediaType];
      resolver && resolver(bid, response);
      response.isDebug = true;
      return response;
    };
  },
  paapiReplacer(paapiDef, ruleNo) {
    function wrap() {
      let configs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return configs.map(config => {
        return Object.keys(config).some(k => !['config', 'igb'].includes(k)) ? {
          config
        } : config;
      });
    }
    if (Array.isArray(paapiDef)) {
      return () => wrap(paapiDef);
    } else if (typeof paapiDef === 'function') {
      return function () {
        return wrap(paapiDef(...arguments));
      };
    } else {
      this.logger.logError(`Invalid 'paapi' definition for debug bid interceptor (in rule #${ruleNo})`);
    }
  },
  responseDefaults(bid) {
    const response = {
      requestId: bid.bidId,
      cpm: 3.5764,
      currency: 'EUR',
      ttl: 360,
      creativeId: 'mock-creative-id',
      netRevenue: false,
      meta: {}
    };
    if (!bid.mediaType) {
      response.mediaType = Object.keys(bid.mediaTypes ?? {})[0] ?? _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_3__.BANNER;
    }
    let size;
    if (response.mediaType === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_3__.BANNER) {
      size = bid.mediaTypes?.banner?.sizes?.[0] ?? [300, 250];
    } else if (response.mediaType === _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_3__.VIDEO) {
      size = bid.mediaTypes?.video?.playerSize?.[0] ?? [600, 500];
    }
    if (Array.isArray(size)) {
      [response.width, response.height] = size;
    }
    return response;
  },
  /**
   * Match a candidate bid against all registered rules.
   *
   * @param {{}} candidate
   * @param args
   * @returns {Rule|undefined} the first matching rule, or undefined if no match was found.
   */
  match(candidate) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return this.rules.find(rule => rule.match(candidate, ...args));
  },
  /**
   * Match a set of bids against all registered rules.
   *
   * @param bids
   * @param bidRequest
   * @returns {[{bid: *, rule: Rule}[], *[]]} a 2-tuple for matching bids (decorated with the matching rule) and
   * non-matching bids.
   */
  matchAll(bids, bidRequest) {
    const [matches, remainder] = [[], []];
    bids.forEach(bid => {
      const rule = this.match(bid, bidRequest);
      if (rule != null) {
        matches.push({
          rule: rule,
          bid: bid
        });
      } else {
        remainder.push(bid);
      }
    });
    return [matches, remainder];
  },
  /**
   * Run a set of bids against all registered rules, filter out those that match,
   * and generate mock responses for them.
   *
   * @param {Object} params
   * @param {Object[]} [params.bids]
   * @param {Object} params.bidRequest
   * @param {function(Object):void} params.addBid called once for each mock response
   * @param {function(Object):void} [params.addPaapiConfig] called once for each mock PAAPI config
   * @param {function():void} params.done called once after all mock responses have been run through `addBid`
   * @returns {{bids: Object[], bidRequest: Object}} remaining bids that did not match any rule (this applies also to bidRequest.bids)
   */
  intercept(_ref6) {
    let {
      bids,
      bidRequest,
      addBid,
      addPaapiConfig,
      done
    } = _ref6;
    if (bids == null) {
      bids = bidRequest.bids;
    }
    const [matches, remainder] = this.matchAll(bids, bidRequest);
    if (matches.length > 0) {
      const callDone = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.delayExecution)(done, matches.length);
      matches.forEach(match => {
        const mockResponse = match.rule.replace(match.bid, bidRequest);
        const mockPaapi = match.rule.paapi(match.bid, bidRequest);
        const delay = match.rule.options.delay;
        this.logger.logMessage(`Intercepted bid request (matching rule #${match.rule.no}), mocking response in ${delay}ms. Request, response, PAAPI configs:`, match.bid, mockResponse, mockPaapi);
        this.setTimeout(() => {
          mockResponse && addBid(mockResponse, match.bid);
          mockPaapi.forEach(cfg => addPaapiConfig(cfg, match.bid, bidRequest));
          callDone();
        }, delay);
      });
      bidRequest = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepClone)(bidRequest);
      bids = bidRequest.bids = remainder;
    } else {
      this.setTimeout(done, 0);
    }
    return {
      bids,
      bidRequest
    };
  }
});

/***/ }),

/***/ "./modules/debugging/debugging.js":
/*!****************************************!*\
  !*** ./modules/debugging/debugging.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   install: () => (/* binding */ install)
/* harmony export */ });
/* unused harmony exports disableDebugging, getConfig, sessionLoader, bidderBidInterceptor */
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _bidInterceptor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bidInterceptor.js */ "./modules/debugging/bidInterceptor.js");
/* harmony import */ var _pbsInterceptor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pbsInterceptor.js */ "./modules/debugging/pbsInterceptor.js");
/* harmony import */ var _legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legacy.js */ "./modules/debugging/legacy.js");




const interceptorHooks = [];
let bidInterceptor;
let enabled = false;
function enableDebugging(debugConfig, _ref) {
  let {
    fromSession = false,
    config,
    hook,
    logger
  } = _ref;
  config.setConfig({
    debug: true
  });
  bidInterceptor.updateConfig(debugConfig);
  resetHooks(true);
  // also enable "legacy" overrides
  (0,_legacy_js__WEBPACK_IMPORTED_MODULE_0__.removeHooks)({
    hook
  });
  (0,_legacy_js__WEBPACK_IMPORTED_MODULE_0__.addHooks)(debugConfig, {
    hook,
    logger
  });
  if (!enabled) {
    enabled = true;
    logger.logMessage(`Debug overrides enabled${fromSession ? ' from session' : ''}`);
  }
}
function disableDebugging(_ref2) {
  let {
    hook,
    logger
  } = _ref2;
  bidInterceptor.updateConfig({});
  resetHooks(false);
  // also disable "legacy" overrides
  (0,_legacy_js__WEBPACK_IMPORTED_MODULE_0__.removeHooks)({
    hook
  });
  if (enabled) {
    enabled = false;
    logger.logMessage('Debug overrides disabled');
  }
}

// eslint-disable-next-line no-restricted-properties
function saveDebuggingConfig(debugConfig) {
  let {
    sessionStorage = window.sessionStorage,
    DEBUG_KEY
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!debugConfig.enabled) {
    try {
      sessionStorage.removeItem(DEBUG_KEY);
    } catch (e) {}
  } else {
    if (debugConfig.intercept) {
      debugConfig = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.deepClone)(debugConfig);
      debugConfig.intercept = bidInterceptor.serializeConfig(debugConfig.intercept);
    }
    try {
      sessionStorage.setItem(DEBUG_KEY, JSON.stringify(debugConfig));
    } catch (e) {}
  }
}

// eslint-disable-next-line no-restricted-properties
function getConfig(debugging) {
  let {
    getStorage = () => window.sessionStorage,
    DEBUG_KEY,
    config,
    hook,
    logger
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (debugging == null) return;
  let sessionStorage;
  try {
    sessionStorage = getStorage();
  } catch (e) {
    logger.logError(`sessionStorage is not available: debugging configuration will not persist on page reload`, e);
  }
  if (sessionStorage != null) {
    saveDebuggingConfig(debugging, {
      sessionStorage,
      DEBUG_KEY
    });
  }
  if (!debugging.enabled) {
    disableDebugging({
      hook,
      logger
    });
  } else {
    enableDebugging(debugging, {
      config,
      hook,
      logger
    });
  }
}
function sessionLoader(_ref3) {
  let {
    DEBUG_KEY,
    storage,
    config,
    hook,
    logger
  } = _ref3;
  let overrides;
  try {
    // eslint-disable-next-line no-restricted-properties
    storage = storage || window.sessionStorage;
    overrides = JSON.parse(storage.getItem(DEBUG_KEY));
  } catch (e) {}
  if (overrides) {
    enableDebugging(overrides, {
      fromSession: true,
      config,
      hook,
      logger
    });
  }
}
function resetHooks(enable) {
  interceptorHooks.forEach(_ref4 => {
    let [getHookFn, interceptor] = _ref4;
    getHookFn().getHooks({
      hook: interceptor
    }).remove();
  });
  if (enable) {
    interceptorHooks.forEach(_ref5 => {
      let [getHookFn, interceptor] = _ref5;
      getHookFn().before(interceptor);
    });
  }
}
function registerBidInterceptor(getHookFn, interceptor) {
  const interceptBids = function () {
    return bidInterceptor.intercept(...arguments);
  };
  interceptorHooks.push([getHookFn, function (next) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    interceptor(next, interceptBids, ...args);
  }]);
}
function bidderBidInterceptor(next, interceptBids, spec, bids, bidRequest, ajax, wrapCallback, cbs) {
  const done = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.delayExecution)(cbs.onCompletion, 2);
  ({
    bids,
    bidRequest
  } = interceptBids({
    bids,
    bidRequest,
    addBid: wrapCallback(cbs.onBid),
    addPaapiConfig: wrapCallback((config, bidRequest) => cbs.onPaapi({
      bidId: bidRequest.bidId,
      ...config
    })),
    done
  }));
  if (bids.length === 0) {
    cbs.onResponse?.({}); // trigger onResponse so that the bidder may be marked as "timely" if necessary
    done();
  } else {
    next(spec, bids, bidRequest, ajax, wrapCallback, {
      ...cbs,
      onCompletion: done
    });
  }
}
function install(_ref6) {
  let {
    DEBUG_KEY,
    config,
    hook,
    createBid,
    logger
  } = _ref6;
  bidInterceptor = new _bidInterceptor_js__WEBPACK_IMPORTED_MODULE_2__.BidInterceptor({
    logger
  });
  const pbsBidInterceptor = (0,_pbsInterceptor_js__WEBPACK_IMPORTED_MODULE_3__.makePbsInterceptor)({
    createBid
  });
  registerBidInterceptor(() => hook.get('processBidderRequests'), bidderBidInterceptor);
  registerBidInterceptor(() => hook.get('processPBSRequest'), pbsBidInterceptor);
  sessionLoader({
    DEBUG_KEY,
    config,
    hook,
    logger
  });
  config.getConfig('debugging', _ref7 => {
    let {
      debugging
    } = _ref7;
    return getConfig(debugging, {
      DEBUG_KEY,
      config,
      hook,
      logger
    });
  }, {
    init: true
  });
}

/***/ }),

/***/ "./modules/debugging/index.js":
/*!************************************!*\
  !*** ./modules/debugging/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/config.js */ "./src/config.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/hook.js */ "./src/hook.js");
/* harmony import */ var _debugging_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debugging.js */ "./modules/debugging/debugging.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_bidfactory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../src/bidfactory.js */ "./src/bidfactory.js");
/* harmony import */ var _src_debugging_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/debugging.js */ "./src/debugging.js");







(0,_debugging_js__WEBPACK_IMPORTED_MODULE_0__.install)({
  DEBUG_KEY: _src_debugging_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_KEY,
  config: _src_config_js__WEBPACK_IMPORTED_MODULE_2__.config,
  hook: _src_hook_js__WEBPACK_IMPORTED_MODULE_3__.hook,
  createBid: _src_bidfactory_js__WEBPACK_IMPORTED_MODULE_4__.createBid,
  logger: (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.prefixLog)('DEBUG:')
});
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_6__.registerModule)('debugging');

/***/ }),

/***/ "./modules/debugging/legacy.js":
/*!*************************************!*\
  !*** ./modules/debugging/legacy.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addHooks: () => (/* binding */ addHooks),
/* harmony export */   removeHooks: () => (/* binding */ removeHooks)
/* harmony export */ });
/* unused harmony exports addBidResponseBound, addBidderRequestsBound, bidExcluded, bidderExcluded, applyBidOverrides, addBidResponseHook, addBidderRequestsHook */
let addBidResponseBound;
let addBidderRequestsBound;
function addHooks(overrides, _ref) {
  let {
    hook,
    logger
  } = _ref;
  addBidResponseBound = addBidResponseHook.bind({
    overrides,
    logger
  });
  hook.get('addBidResponse').before(addBidResponseBound, 5);
  addBidderRequestsBound = addBidderRequestsHook.bind({
    overrides,
    logger
  });
  hook.get('addBidderRequests').before(addBidderRequestsBound, 5);
}
function removeHooks(_ref2) {
  let {
    hook
  } = _ref2;
  hook.get('addBidResponse').getHooks({
    hook: addBidResponseBound
  }).remove();
  hook.get('addBidderRequests').getHooks({
    hook: addBidderRequestsBound
  }).remove();
}

/**
 * @param {{bidder:string, adUnitCode:string}} overrideObj
 * @param {string} bidderCode
 * @param {string} adUnitCode
 * @returns {boolean}
 */
function bidExcluded(overrideObj, bidderCode, adUnitCode) {
  if (overrideObj.bidder && overrideObj.bidder !== bidderCode) {
    return true;
  }
  if (overrideObj.adUnitCode && overrideObj.adUnitCode !== adUnitCode) {
    return true;
  }
  return false;
}

/**
 * @param {string[]} bidders
 * @param {string} bidderCode
 * @returns {boolean}
 */
function bidderExcluded(bidders, bidderCode) {
  return Array.isArray(bidders) && bidders.indexOf(bidderCode) === -1;
}

/**
 * @param {Object} overrideObj
 * @param {Object} bidObj
 * @param {Object} bidType
 * @returns {Object} bidObj with overridden properties
 */
function applyBidOverrides(overrideObj, bidObj, bidType, logger) {
  return Object.keys(overrideObj).filter(key => ['adUnitCode', 'bidder'].indexOf(key) === -1).reduce(function (result, key) {
    logger.logMessage(`bidder overrides changed '${result.adUnitCode}/${result.bidderCode}' ${bidType}.${key} from '${result[key]}.js' to '${overrideObj[key]}'`);
    result[key] = overrideObj[key];
    result.isDebug = true;
    return result;
  }, bidObj);
}
function addBidResponseHook(next, adUnitCode, bid, reject) {
  const {
    overrides,
    logger
  } = this;
  if (bidderExcluded(overrides.bidders, bid.bidderCode)) {
    logger.logWarn(`bidder '${bid.bidderCode}' excluded from auction by bidder overrides`);
    return;
  }
  if (Array.isArray(overrides.bids)) {
    overrides.bids.forEach(function (overrideBid) {
      if (!bidExcluded(overrideBid, bid.bidderCode, adUnitCode)) {
        applyBidOverrides(overrideBid, bid, 'bidder', logger);
      }
    });
  }
  next(adUnitCode, bid, reject);
}
function addBidderRequestsHook(next, bidderRequests) {
  const {
    overrides,
    logger
  } = this;
  const includedBidderRequests = bidderRequests.filter(function (bidderRequest) {
    if (bidderExcluded(overrides.bidders, bidderRequest.bidderCode)) {
      logger.logWarn(`bidRequest '${bidderRequest.bidderCode}' excluded from auction by bidder overrides`);
      return false;
    }
    return true;
  });
  if (Array.isArray(overrides.bidRequests)) {
    includedBidderRequests.forEach(function (bidderRequest) {
      overrides.bidRequests.forEach(function (overrideBid) {
        bidderRequest.bids.forEach(function (bid) {
          if (!bidExcluded(overrideBid, bidderRequest.bidderCode, bid.adUnitCode)) {
            applyBidOverrides(overrideBid, bid, 'bidRequest', logger);
          }
        });
      });
    });
  }
  next(includedBidderRequests);
}

/***/ }),

/***/ "./modules/debugging/pbsInterceptor.js":
/*!*********************************************!*\
  !*** ./modules/debugging/pbsInterceptor.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makePbsInterceptor: () => (/* binding */ makePbsInterceptor)
/* harmony export */ });
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/constants.js */ "./src/constants.js");


function makePbsInterceptor(_ref) {
  let {
    createBid
  } = _ref;
  return function pbsBidInterceptor(next, interceptBids, s2sBidRequest, bidRequests, ajax, _ref2) {
    let {
      onResponse,
      onError,
      onBid,
      onFledge
    } = _ref2;
    let responseArgs;
    const done = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.delayExecution)(() => onResponse(...responseArgs), bidRequests.length + 1);
    function signalResponse() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      responseArgs = args;
      done();
    }
    function addBid(bid, bidRequest) {
      onBid({
        adUnit: bidRequest.adUnitCode,
        bid: Object.assign(createBid(_src_constants_js__WEBPACK_IMPORTED_MODULE_1__.STATUS.GOOD, bidRequest), {
          requestBidder: bidRequest.bidder
        }, bid)
      });
    }
    bidRequests = bidRequests.map(req => interceptBids({
      bidRequest: req,
      addBid,
      addPaapiConfig(config, bidRequest, bidderRequest) {
        onFledge({
          adUnitCode: bidRequest.adUnitCode,
          ortb2: bidderRequest.ortb2,
          ortb2Imp: bidRequest.ortb2Imp,
          ...config
        });
      },
      done
    }).bidRequest).filter(req => req.bids.length > 0);
    if (bidRequests.length > 0) {
      const bidIds = new Set();
      bidRequests.forEach(req => req.bids.forEach(bid => bidIds.add(bid.bidId)));
      s2sBidRequest = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepClone)(s2sBidRequest);
      s2sBidRequest.ad_units.forEach(unit => {
        unit.bids = unit.bids.filter(bid => bidIds.has(bid.bid_id));
      });
      s2sBidRequest.ad_units = s2sBidRequest.ad_units.filter(unit => unit.bids.length > 0);
      next(s2sBidRequest, bidRequests, ajax, {
        onResponse: signalResponse,
        onError,
        onBid
      });
    } else {
      signalResponse(true, []);
    }
  };
}

/***/ }),

/***/ "./modules/debugging/responses.js":
/*!****************************************!*\
  !*** ./modules/debugging/responses.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/mediaTypes.js */ "./src/mediaTypes.js");
/* harmony import */ var _src_Renderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/Renderer.js */ "./src/Renderer.js");
/* harmony import */ var _libraries_gptUtils_gptUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../libraries/gptUtils/gptUtils.js */ "./libraries/gptUtils/gptUtils.js");



const ORTB_NATIVE_ASSET_TYPES = ['img', 'video', 'link', 'data', 'title'];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  [_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.BANNER]: (bid, bidResponse) => {
    if (!bidResponse.hasOwnProperty('ad') && !bidResponse.hasOwnProperty('adUrl')) {
      let [size, repeat] = (bidResponse.width ?? bidResponse.wratio) < (bidResponse.height ?? bidResponse.hratio) ? [bidResponse.width, 'repeat-y'] : [bidResponse.height, 'repeat-x'];
      size = size == null ? '100%' : `${size}px`;
      bidResponse.ad = `<html><body><div style="display: inline-block; height: ${bidResponse.height == null ? '100%' : bidResponse.height + 'px'}; width: ${bidResponse.width == null ? '100%' : bidResponse.width + 'px'}; background-image: url(https://vcdn.adnxs.com/p/creative-image/27/c0/52/67/27c05267-5a6d-4874-834e-18e218493c32.png); background-size: ${size}; background-repeat: ${repeat}"></div></body></html>`;
    }
  },
  [_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO]: (bid, bidResponse) => {
    if (!bidResponse.hasOwnProperty('vastXml') && !bidResponse.hasOwnProperty('vastUrl')) {
      bidResponse.vastXml = '<?xml version="1.0" encoding="UTF-8"?><VAST version="3.0"><Ad><InLine><AdSystem>GDFP</AdSystem><AdTitle>Demo</AdTitle><Description><![CDATA[Demo]]></Description><Creatives><Creative><Linear ><Duration>00:00:11</Duration><VideoClicks><ClickThrough><![CDATA[https://prebid.org/]]></ClickThrough></VideoClicks><MediaFiles><MediaFile delivery="progressive" width="640" height="360" type="video/mp4" scalable="true" maintainAspectRatio="true"><![CDATA[https://s3.amazonaws.com/files.prebid.org/creatives/PrebidLogo.mp4]]></MediaFile></MediaFiles></Linear></Creative></Creatives></InLine></Ad></VAST>';
      bidResponse.renderer = _src_Renderer_js__WEBPACK_IMPORTED_MODULE_1__.Renderer.install({
        url: 'https://cdn.jwplayer.com/libraries/l5MchIxB.js'
      });
      bidResponse.renderer.setRender(function (bid, doc) {
        const parentId = (0,_libraries_gptUtils_gptUtils_js__WEBPACK_IMPORTED_MODULE_2__.getGptSlotInfoForAdUnitCode)(bid.adUnitCode).divId ?? bid.adUnitCode;
        const div = doc.createElement('div');
        div.id = `${parentId}-video-player`;
        doc.getElementById(parentId).appendChild(div);
        const player = window.jwplayer(div.id).setup({
          debug: true,
          width: bidResponse.width,
          height: bidResponse.height,
          advertising: {
            client: 'vast',
            outstream: true,
            endstate: 'close'
          }
        });
        player.on('ready', async function () {
          if (bid.vastUrl) {
            player.loadAdTag(bid.vastUrl);
          } else {
            player.loadAdXml(bid.vastXml);
          }
        });
      });
    }
  },
  [_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE]: (bid, bidResponse) => {
    if (!bidResponse.hasOwnProperty('native')) {
      bidResponse.native = {
        ortb: {
          link: {
            url: 'https://www.link.example',
            clicktrackers: ['https://impression.example']
          },
          assets: bid.nativeOrtbRequest.assets.map(mapDefaultNativeOrtbAsset)
        }
      };
    }
  }
});
function mapDefaultNativeOrtbAsset(asset) {
  const assetType = ORTB_NATIVE_ASSET_TYPES.find(type => asset.hasOwnProperty(type));
  switch (assetType) {
    case 'img':
      return {
        ...asset,
        img: {
          type: 3,
          w: 600,
          h: 500,
          url: 'https://vcdn.adnxs.com/p/creative-image/27/c0/52/67/27c05267-5a6d-4874-834e-18e218493c32.png'
        }
      };
    case 'video':
      return {
        ...asset,
        video: {
          vasttag: '<?xml version=\"1.0\" encoding=\"UTF-8\"?><VAST version=\"3.0\"><Ad><InLine><AdSystem>GDFP</AdSystem><AdTitle>Demo</AdTitle><Description><![CDATA[Demo]]></Description><Creatives><Creative><Linear ><Duration>00:00:11</Duration><VideoClicks><ClickThrough><![CDATA[https://prebid.org/]]></ClickThrough></VideoClicks><MediaFiles><MediaFile delivery=\"progressive\" width=\"640\" height=\"360\" type=\"video/mp4\" scalable=\"true\" maintainAspectRatio=\"true\"><![CDATA[https://s3.amazonaws.com/files.prebid.org/creatives/PrebidLogo.mp4]]></MediaFile></MediaFiles></Linear></Creative></Creatives></InLine></Ad></VAST>'
        }
      };
    case 'data':
      {
        return {
          ...asset,
          data: {
            value: '5 stars'
          }
        };
      }
    case 'title':
      {
        return {
          ...asset,
          title: {
            text: 'Prebid Native Example'
          }
        };
      }
  }
}

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["gptUtils","chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/debugging/index.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["dfpAdServerVideo"],{

/***/ "./modules/dfpAdServerVideo.js":
/*!*************************************!*\
  !*** ./modules/dfpAdServerVideo.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports dep, VAST_TAG_URI_TAGNAME, buildDfpVideoUrl, notifyTranslationModule, getVastXml, getBase64BlobContent */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _libraries_gptUtils_gptUtils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../libraries/gptUtils/gptUtils.js */ "./libraries/gptUtils/gptUtils.js");
/* harmony import */ var _src_adServerManager_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../src/adServerManager.js */ "./src/adServerManager.js");
/* harmony import */ var _src_adserver_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/adserver.js */ "./src/adserver.js");
/* harmony import */ var _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/auctionManager.js */ "./src/auctionManager.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_constants_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/constants.js */ "./src/constants.js");
/* harmony import */ var _src_events_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/events.js */ "./src/events.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_refererDetection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/refererDetection.js */ "./src/refererDetection.js");
/* harmony import */ var _src_targeting_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/targeting.js */ "./src/targeting.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _libraries_dfpUtils_dfpUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../libraries/dfpUtils/dfpUtils.js */ "./libraries/dfpUtils/dfpUtils.js");
/* harmony import */ var _src_videoCache_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../src/videoCache.js */ "./src/videoCache.js");
/* harmony import */ var _src_ajax_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../src/ajax.js */ "./src/ajax.js");
/* harmony import */ var _libraries_xmlUtils_xmlUtils_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../libraries/xmlUtils/xmlUtils.js */ "./libraries/xmlUtils/xmlUtils.js");

/**
 * This module adds [DFP support]{@link https://www.doubleclickbygoogle.com/} for Video to Prebid.
 */
















/**
 * @typedef {Object} DfpVideoParams
 *
 * This object contains the params needed to form a URL which hits the
 * [DFP API]{@link https://support.google.com/dfp_premium/answer/1068325?hl=en}.
 *
 * All params (except iu, mentioned below) should be considered optional. This module will choose reasonable
 * defaults for all of the other required params.
 *
 * The cust_params property, if present, must be an object. It will be merged with the rest of the
 * standard Prebid targeting params (hb_adid, hb_bidder, etc).
 *
 * @param {string} iu This param *must* be included, in order for us to create a valid request.
 * @param [string] description_url This field is required if you want Ad Exchange to bid on our ad unit...
 *   but otherwise optional
 */

/**
 * @typedef {Object} DfpVideoOptions
 *
 * @param {Object} adUnit The adUnit which this bid is supposed to help fill.
 * @param [Object] bid The bid which should be considered alongside the rest of the adserver's demand.
 *   If this isn't defined, then we'll use the winning bid for the adUnit.
 *
 * @param {DfpVideoParams} [params] Query params which should be set on the DFP request.
 *   These will override this module's defaults whenever they conflict.
 * @param {string} [url] video adserver url
 */

const dep = {
  ri: _src_refererDetection_js__WEBPACK_IMPORTED_MODULE_0__.getRefererInfo
};
const VAST_TAG_URI_TAGNAME = 'VASTAdTagURI';

/**
 * Merge all the bid data and publisher-supplied options into a single URL, and then return it.
 *
 * @see [The DFP API]{@link https://support.google.com/dfp_premium/answer/1068325?hl=en#env} for details.
 *
 * @param {DfpVideoOptions} options Options which should be used to construct the URL.
 *
 * @return {string} A URL which calls DFP, letting options.bid
 *   (or the auction's winning bid for this adUnit, if undefined) compete alongside the rest of the
 *   demand in DFP.
 */
function buildDfpVideoUrl(options) {
  if (!options.params && !options.url) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(`A params object or a url is required to use pbjs.adServers.dfp.buildVideoUrl`);
    return;
  }
  const adUnit = options.adUnit;
  const bid = options.bid || _src_targeting_js__WEBPACK_IMPORTED_MODULE_2__.targeting.getWinningBids(adUnit.code)[0];
  let urlComponents = {};
  if (options.url) {
    // when both `url` and `params` are given, parsed url will be overwriten
    // with any matching param components
    urlComponents = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.parseUrl)(options.url, {
      noDecodeWholeURL: true
    });
    if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(options.params)) {
      return buildUrlFromAdserverUrlComponents(urlComponents, bid, options);
    }
  }
  const derivedParams = {
    correlator: Date.now(),
    sz: (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.parseSizesInput)(adUnit?.mediaTypes?.video?.playerSize).join('|'),
    url: encodeURIComponent(location.href)
  };
  const urlSearchComponent = urlComponents.search;
  const urlSzParam = urlSearchComponent && urlSearchComponent.sz;
  if (urlSzParam) {
    derivedParams.sz = urlSzParam + '|' + derivedParams.sz;
  }
  let encodedCustomParams = getCustParams(bid, options, urlSearchComponent && urlSearchComponent.cust_params);
  const queryParams = Object.assign({}, _libraries_dfpUtils_dfpUtils_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_DFP_PARAMS, urlComponents.search, derivedParams, options.params, {
    cust_params: encodedCustomParams
  }, (0,_libraries_dfpUtils_dfpUtils_js__WEBPACK_IMPORTED_MODULE_3__.gdprParams)());
  const descriptionUrl = getDescriptionUrl(bid, options, 'params');
  if (descriptionUrl) {
    queryParams.description_url = descriptionUrl;
  }
  if (!queryParams.ppid) {
    const ppid = (0,_src_adserver_js__WEBPACK_IMPORTED_MODULE_4__.getPPID)();
    if (ppid != null) {
      queryParams.ppid = ppid;
    }
  }
  const video = options.adUnit?.mediaTypes?.video;
  Object.entries({
    plcmt: () => video?.plcmt,
    min_ad_duration: () => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(video?.minduration) ? video.minduration * 1000 : null,
    max_ad_duration: () => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(video?.maxduration) ? video.maxduration * 1000 : null,
    vpos() {
      const startdelay = video?.startdelay;
      if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(startdelay)) {
        if (startdelay === -2) return 'postroll';
        if (startdelay === -1 || startdelay > 0) return 'midroll';
        return 'preroll';
      }
    },
    vconp: () => Array.isArray(video?.playbackmethod) && video.playbackmethod.some(m => m === 7) ? '2' : undefined,
    vpa() {
      // playbackmethod = 3 is play on click; 1, 2, 4, 5, 6 are autoplay
      if (Array.isArray(video?.playbackmethod)) {
        const click = video.playbackmethod.some(m => m === 3);
        const auto = video.playbackmethod.some(m => [1, 2, 4, 5, 6].includes(m));
        if (click && !auto) return 'click';
        if (auto && !click) return 'auto';
      }
    },
    vpmute() {
      // playbackmethod = 2, 6 are muted; 1, 3, 4, 5 are not
      if (Array.isArray(video?.playbackmethod)) {
        const muted = video.playbackmethod.some(m => [2, 6].includes(m));
        const talkie = video.playbackmethod.some(m => [1, 3, 4, 5].includes(m));
        if (muted && !talkie) return '1';
        if (talkie && !muted) return '0';
      }
    }
  }).forEach(_ref => {
    let [param, getter] = _ref;
    if (!queryParams.hasOwnProperty(param)) {
      const val = getter();
      if (val != null) {
        queryParams[param] = val;
      }
    }
  });
  const fpd = _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager.index.getBidRequest(options.bid || {})?.ortb2 ?? _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_5__.auctionManager.index.getAuction(options.bid || {})?.getFPD()?.global;
  const signals = (0,_libraries_gptUtils_gptUtils_js__WEBPACK_IMPORTED_MODULE_6__.getSignals)(fpd);
  if (signals.length) {
    queryParams.ppsj = btoa(JSON.stringify({
      PublisherProvidedTaxonomySignals: signals
    }));
  }
  return (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.buildUrl)(Object.assign({}, _libraries_dfpUtils_dfpUtils_js__WEBPACK_IMPORTED_MODULE_3__.DFP_ENDPOINT, urlComponents, {
    search: queryParams
  }));
}
function notifyTranslationModule(fn) {
  fn.call(this, 'dfp');
}
if (_src_config_js__WEBPACK_IMPORTED_MODULE_7__.config.getConfig('brandCategoryTranslation.translationFile')) {
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_8__.getHook)('registerAdserver').before(notifyTranslationModule);
}

/**
 * Builds a video url from a base dfp video url and a winning bid, appending
 * Prebid-specific key-values.
 * @param {Object} components base video adserver url parsed into components object
 * @param {Object} bid winning bid object to append parameters from
 * @param {Object} options Options which should be used to construct the URL (used for custom params).
 * @return {string} video url
 */
function buildUrlFromAdserverUrlComponents(components, bid, options) {
  const descriptionUrl = getDescriptionUrl(bid, components, 'search');
  if (descriptionUrl) {
    components.search.description_url = descriptionUrl;
  }
  components.search.cust_params = getCustParams(bid, options, components.search.cust_params);
  return (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.buildUrl)(components);
}

/**
 * Returns the encoded vast url if it exists on a bid object, only if prebid-cache
 * is disabled, and description_url is not already set on a given input
 * @param {Object} bid object to check for vast url
 * @param {Object} components the object to check that description_url is NOT set on
 * @param {string} prop the property of components that would contain description_url
 * @return {string | undefined} The encoded vast url if it exists, or undefined
 */
function getDescriptionUrl(bid, components, prop) {
  return components?.[prop]?.description_url || encodeURIComponent(dep.ri().page);
}

/**
 * Returns the encoded `cust_params` from the bid.adserverTargeting and adds the `hb_uuid`, and `hb_cache_id`. Optionally the options.params.cust_params
 * @param {Object} bid
 * @param {Object} options this is the options passed in from the `buildDfpVideoUrl` function
 * @return {Object} Encoded key value pairs for cust_params
 */
function getCustParams(bid, options, urlCustParams) {
  const adserverTargeting = bid && bid.adserverTargeting || {};
  let allTargetingData = {};
  const adUnit = options && options.adUnit;
  if (adUnit) {
    let allTargeting = _src_targeting_js__WEBPACK_IMPORTED_MODULE_2__.targeting.getAllTargeting(adUnit.code);
    allTargetingData = allTargeting ? allTargeting[adUnit.code] : {};
  }
  const prebidTargetingSet = Object.assign({},
  // Why are we adding standard keys here ? Refer https://github.com/prebid/Prebid.js/issues/3664
  {
    hb_uuid: bid && bid.videoCacheKey
  },
  // hb_cache_id became optional in prebid 5.0 after 4.x enabled the concept of optional keys. Discussion led to reversing the prior expectation of deprecating hb_uuid
  {
    hb_cache_id: bid && bid.videoCacheKey
  }, allTargetingData, adserverTargeting);

  // TODO: WTF is this? just firing random events, guessing at the argument, hoping noone notices?
  _src_events_js__WEBPACK_IMPORTED_MODULE_9__.emit(_src_constants_js__WEBPACK_IMPORTED_MODULE_10__.EVENTS.SET_TARGETING, {
    [adUnit.code]: prebidTargetingSet
  });

  // merge the prebid + publisher targeting sets
  const publisherTargetingSet = options?.params?.cust_params;
  const targetingSet = Object.assign({}, prebidTargetingSet, publisherTargetingSet);
  let encodedParams = encodeURIComponent((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.formatQS)(targetingSet));
  if (urlCustParams) {
    encodedParams = urlCustParams + '%26' + encodedParams;
  }
  return encodedParams;
}
async function getVastForLocallyCachedBids(gamVastWrapper, localCacheMap) {
  try {
    const xmlUtil = (0,_libraries_xmlUtils_xmlUtils_js__WEBPACK_IMPORTED_MODULE_11__["default"])();
    const xmlDoc = xmlUtil.parse(gamVastWrapper);
    const vastAdTagUriElement = xmlDoc.querySelectorAll(VAST_TAG_URI_TAGNAME)[0];
    if (!vastAdTagUriElement || !vastAdTagUriElement.textContent) {
      return gamVastWrapper;
    }
    const uuidExp = new RegExp(`[A-Fa-f0-9]{8}-(?:[A-Fa-f0-9]{4}-){3}[A-Fa-f0-9]{12}`, 'gi');
    const matchResult = Array.from(vastAdTagUriElement.textContent.matchAll(uuidExp));
    const uuidCandidates = matchResult.map(_ref2 => {
      let [uuid] = _ref2;
      return uuid;
    }).filter(uuid => localCacheMap.has(uuid));
    if (uuidCandidates.length != 1) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Unable to determine unique uuid in ${VAST_TAG_URI_TAGNAME}`);
      return gamVastWrapper;
    }
    const uuid = uuidCandidates[0];
    const blobUrl = localCacheMap.get(uuid);
    const base64BlobContent = await getBase64BlobContent(blobUrl);
    const cdata = xmlDoc.createCDATASection(base64BlobContent);
    vastAdTagUriElement.textContent = '';
    vastAdTagUriElement.appendChild(cdata);
    return xmlUtil.serialize(xmlDoc);
  } catch (error) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)('Unable to process xml', error);
    return gamVastWrapper;
  }
}
;
async function getVastXml(options) {
  let localCacheMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _src_videoCache_js__WEBPACK_IMPORTED_MODULE_12__.vastLocalCache;
  const vastUrl = buildDfpVideoUrl(options);
  const response = await (0,_src_ajax_js__WEBPACK_IMPORTED_MODULE_13__.fetch)(vastUrl);
  if (!response.ok) {
    throw new Error('Unable to fetch GAM VAST wrapper');
  }
  const gamVastWrapper = await response.text();
  if (_src_config_js__WEBPACK_IMPORTED_MODULE_7__.config.getConfig('cache.useLocal')) {
    const vastXml = await getVastForLocallyCachedBids(gamVastWrapper, localCacheMap);
    return vastXml;
  }
  return gamVastWrapper;
}
async function getBase64BlobContent(blobUrl) {
  const response = await (0,_src_ajax_js__WEBPACK_IMPORTED_MODULE_13__.fetch)(blobUrl);
  if (!response.ok) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)('Unable to fetch blob');
    throw new Error('Blob not found');
  }
  // Mechanism to handle cases where VAST tags are fetched
  // from a context where the blob resource is not accessible.
  // like IMA SDK iframe
  const blobContent = await response.text();
  const dataUrl = `data://text/xml;base64,${btoa(blobContent)}`;
  return dataUrl;
}
(0,_src_adServerManager_js__WEBPACK_IMPORTED_MODULE_14__.registerVideoSupport)('dfp', {
  buildVideoUrl: buildDfpVideoUrl,
  getVastXml
});
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_15__.registerModule)('dfpAdServerVideo');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","gptUtils","xmlUtils","dfpUtils","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/dfpAdServerVideo.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["dsaControl"],{

/***/ "./modules/dsaControl.js":
/*!*******************************!*\
  !*** ./modules/dsaControl.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports addBidResponseHook, reset */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/auctionManager.js */ "./src/auctionManager.js");
/* harmony import */ var _src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/utils/perfMetrics.js */ "./src/utils/perfMetrics.js");
/* harmony import */ var _src_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/constants.js */ "./src/constants.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");







let expiryHandle;
let dsaAuctions = {};
const addBidResponseHook = (0,_src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_0__.timedBidResponseHook)('dsa', function (fn, adUnitCode, bid, reject) {
  if (!dsaAuctions.hasOwnProperty(bid.auctionId)) {
    dsaAuctions[bid.auctionId] = _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_1__.auctionManager.index.getAuction(bid)?.getFPD?.()?.global?.regs?.ext?.dsa;
  }
  const dsaRequest = dsaAuctions[bid.auctionId];
  let rejectReason;
  if (dsaRequest) {
    if (!bid.meta?.dsa) {
      if (dsaRequest.dsarequired === 1) {
        // request says dsa is supported; response does not have dsa info; warn about it
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)(`dsaControl: ${_src_constants_js__WEBPACK_IMPORTED_MODULE_3__.REJECTION_REASON.DSA_REQUIRED}; will still be accepted as regs.ext.dsa.dsarequired = 1`, bid);
      } else if ([2, 3].includes(dsaRequest.dsarequired)) {
        // request says dsa is required; response does not have dsa info; reject it
        rejectReason = _src_constants_js__WEBPACK_IMPORTED_MODULE_3__.REJECTION_REASON.DSA_REQUIRED;
      }
    } else {
      if (dsaRequest.pubrender === 0 && bid.meta.dsa.adrender === 0) {
        // request says publisher can't render; response says advertiser won't; reject it
        rejectReason = _src_constants_js__WEBPACK_IMPORTED_MODULE_3__.REJECTION_REASON.DSA_MISMATCH;
      } else if (dsaRequest.pubrender === 2 && bid.meta.dsa.adrender === 1) {
        // request says publisher will render; response says advertiser will; reject it
        rejectReason = _src_constants_js__WEBPACK_IMPORTED_MODULE_3__.REJECTION_REASON.DSA_MISMATCH;
      }
    }
  }
  if (rejectReason) {
    reject(rejectReason);
  } else {
    return fn.call(this, adUnitCode, bid, reject);
  }
});
function toggleHooks(enabled) {
  if (enabled && expiryHandle == null) {
    (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_4__.getHook)('addBidResponse').before(addBidResponseHook);
    expiryHandle = _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_1__.auctionManager.onExpiry(auction => {
      delete dsaAuctions[auction.getAuctionId()];
    });
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)('dsaControl: DSA bid validation is enabled');
  } else if (!enabled && expiryHandle != null) {
    (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_4__.getHook)('addBidResponse').getHooks({
      hook: addBidResponseHook
    }).remove();
    expiryHandle();
    expiryHandle = null;
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)('dsaControl: DSA bid validation is disabled');
  }
}
function reset() {
  toggleHooks(false);
  dsaAuctions = {};
}
toggleHooks(true);
_src_config_js__WEBPACK_IMPORTED_MODULE_5__.config.getConfig('consentManagement', cfg => {
  toggleHooks(cfg.consentManagement?.dsa?.validateBids ?? true);
});
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_6__.registerModule)('dsaControl');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/dsaControl.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["fpdModule"],{

/***/ "./modules/fpdModule/index.js":
/*!************************************!*\
  !*** ./modules/fpdModule/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports registerSubmodules, reset, processFpd, startAuctionHook */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/config.js */ "./src/config.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/utils/perfMetrics.js */ "./src/utils/perfMetrics.js");

/**
 * This module sets default values and validates ortb2 first part data
 * @module modules/firstPartyData
 */





let submodules = [];
function registerSubmodules(submodule) {
  submodules.push(submodule);
}
function reset() {
  submodules.length = 0;
}
function processFpd() {
  let {
    global = {},
    bidder = {}
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let modConf = _src_config_js__WEBPACK_IMPORTED_MODULE_0__.config.getConfig('firstPartyData') || {};
  let result = _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_1__.PbPromise.resolve({
    global,
    bidder
  });
  submodules.sort((a, b) => {
    return (a.queue || 1) - (b.queue || 1);
  }).forEach(submodule => {
    result = result.then(_ref => {
      let {
        global,
        bidder
      } = _ref;
      return _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_1__.PbPromise.resolve(submodule.processFpd(modConf, {
        global,
        bidder
      })).catch(err => {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)(`Error in FPD module ${submodule.name}`, err);
        return {};
      }).then(result => ({
        global: result.global || global,
        bidder: result.bidder || bidder
      }));
    });
  });
  return result;
}
const startAuctionHook = (0,_src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_3__.timedAuctionHook)('fpd', function startAuctionHook(fn, req) {
  processFpd(req.ortb2Fragments).then(ortb2Fragments => {
    Object.assign(req.ortb2Fragments, ortb2Fragments);
    fn.call(this, req);
  });
});
function setupHook() {
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_4__.getHook)('startAuction').before(startAuctionHook, 10);
}
(0,_src_hook_js__WEBPACK_IMPORTED_MODULE_4__.module)('firstPartyData', registerSubmodules);

// Runs setupHook on initial load
setupHook();
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_5__.registerModule)('fpdModule');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/fpdModule/index.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["gppControl_usnat"],{

/***/ "./modules/gppControl_usnat.js":
/*!*************************************!*\
  !*** ./modules/gppControl_usnat.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _libraries_mspa_activityControls_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libraries/mspa/activityControls.js */ "./libraries/mspa/activityControls.js");



let setupDone = false;
_src_config_js__WEBPACK_IMPORTED_MODULE_0__.config.getConfig('consentManagement', cfg => {
  if (cfg?.consentManagement?.gpp != null && !setupDone) {
    (0,_libraries_mspa_activityControls_js__WEBPACK_IMPORTED_MODULE_1__.setupRules)('usnat', [7]);
    setupDone = true;
  }
});
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_2__.registerModule)('gppControl_usnat');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["mspa","chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/gppControl_usnat.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["gppControl_usstates"],{

/***/ "./modules/gppControl_usstates.js":
/*!****************************************!*\
  !*** ./modules/gppControl_usstates.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports normalizer, NORMALIZATIONS, DEFAULT_SID_MAPPING, getSections */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _libraries_mspa_activityControls_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../libraries/mspa/activityControls.js */ "./libraries/mspa/activityControls.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");




const FIELDS = {
  Version: 0,
  Gpc: 0,
  SharingNotice: 0,
  SaleOptOutNotice: 0,
  SharingOptOutNotice: 0,
  TargetedAdvertisingOptOutNotice: 0,
  SensitiveDataProcessingOptOutNotice: 0,
  SensitiveDataLimitUseNotice: 0,
  SaleOptOut: 0,
  SharingOptOut: 0,
  TargetedAdvertisingOptOut: 0,
  SensitiveDataProcessing: 12,
  KnownChildSensitiveDataConsents: 2,
  PersonalDataConsents: 0,
  MspaCoveredTransaction: 0,
  MspaOptOutOptionMode: 0,
  MspaServiceProviderMode: 0
};

/**
 * Generate a normalization function for converting US state strings to the usnat format.
 *
 * Scalar fields are copied over if they exist in the input (state) data, or set to null otherwise.
 * List fields are also copied, but forced to the "correct" length (by truncating or padding with nulls);
 * additionally, elements within them can be moved around using the `move` argument.
 *
 * @param {Object} opts
 * @param {string[]} [opts.nullify] list of fields to force to null
 * @param {Object} [opts.move] Map from list field name to an index remapping for elements within that field (using 1 as the first index).
 *       For example, {SensitiveDataProcessing: {1: 2, 2: [1, 3]}} means "rearrange SensitiveDataProcessing by moving
 *       the first element to the second position, and the second element to both the first and third position."
 * @param {function(Object, Object): void} [opts.fn] an optional function to run once all the processing described above is complete;
 *       it's passed two arguments, the original (state) data, and its normalized (usnat) version.
 * @param {Object} [fields]
 * @returns {function(Object): Object}
 */
function normalizer(_ref) {
  let {
    nullify = [],
    move = {},
    fn
  } = _ref;
  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FIELDS;
  move = Object.fromEntries(Object.entries(move).map(_ref2 => {
    let [k, map] = _ref2;
    return [k, Object.fromEntries(Object.entries(map).map(_ref3 => {
      let [k, v] = _ref3;
      return [k, Array.isArray(v) ? v : [v]];
    }).map(_ref4 => {
      let [k, v] = _ref4;
      return [--k, v.map(el => --el)];
    }))];
  }));
  return function (cd) {
    const norm = Object.fromEntries(Object.entries(fields).map(_ref5 => {
      let [field, len] = _ref5;
      let val = null;
      if (len > 0) {
        val = Array(len).fill(null);
        if (Array.isArray(cd[field])) {
          const remap = move[field] || {};
          const done = [];
          cd[field].forEach((el, i) => {
            const [dest, moved] = remap.hasOwnProperty(i) ? [remap[i], true] : [[i], false];
            dest.forEach(d => {
              if (d < len && !done.includes(d)) {
                val[d] = el;
                moved && done.push(d);
              }
            });
          });
        }
      } else if (cd[field] != null) {
        val = Array.isArray(cd[field]) ? null : cd[field];
      }
      return [field, val];
    }));
    nullify.forEach(path => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.dset)(norm, path, null));
    fn && fn(cd, norm);
    return norm;
  };
}
function scalarMinorsAreChildren(original, normalized) {
  normalized.KnownChildSensitiveDataConsents = original.KnownChildSensitiveDataConsents === 0 ? [0, 0] : [1, 1];
}
const NORMALIZATIONS = {
  // normalization rules - convert state consent into usnat consent
  // https://docs.prebid.org/features/mspa-usnat.html
  7: consent => consent,
  8: normalizer({
    move: {
      SensitiveDataProcessing: {
        1: 9,
        2: 10,
        3: 8,
        4: [1, 2],
        5: 12,
        8: 3,
        9: 4
      }
    },
    fn(original, normalized) {
      if (original.KnownChildSensitiveDataConsents.some(el => el !== 0)) {
        normalized.KnownChildSensitiveDataConsents = [1, 1];
      }
    }
  }),
  9: normalizer({
    fn: scalarMinorsAreChildren
  }),
  10: normalizer({
    fn: scalarMinorsAreChildren
  }),
  11: normalizer({
    move: {
      SensitiveDataProcessing: {
        3: 4,
        4: 5,
        5: 3
      }
    },
    fn: scalarMinorsAreChildren
  }),
  12: normalizer({
    fn(original, normalized) {
      const cc = original.KnownChildSensitiveDataConsents;
      let repl;
      if (!cc.some(el => el !== 0)) {
        repl = [0, 0];
      } else if (cc[1] === 2 && cc[2] === 2) {
        repl = [2, 1];
      } else {
        repl = [1, 1];
      }
      normalized.KnownChildSensitiveDataConsents = repl;
    }
  })
};
const DEFAULT_SID_MAPPING = {
  8: 'usca',
  9: 'usva',
  10: 'usco',
  11: 'usut',
  12: 'usct'
};
const getSections = (() => {
  const allSIDs = Object.keys(DEFAULT_SID_MAPPING).map(Number);
  return function () {
    let {
      sections = {},
      sids = allSIDs
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return sids.map(sid => {
      const logger = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.prefixLog)(`Cannot set up MSPA controls for SID ${sid}:`);
      const ov = sections[sid] || {};
      const normalizeAs = ov.normalizeAs || sid;
      if (!NORMALIZATIONS.hasOwnProperty(normalizeAs)) {
        logger.logError(`no normalization rules are known for SID ${normalizeAs}`);
        return;
      }
      const api = ov.name || DEFAULT_SID_MAPPING[sid];
      if (typeof api !== 'string') {
        logger.logError(`cannot determine GPP section name`);
        return;
      }
      return [api, [sid], NORMALIZATIONS[normalizeAs]];
    }).filter(el => el != null);
  };
})();
const handles = [];
_src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('consentManagement', cfg => {
  const gppConf = cfg.consentManagement?.gpp;
  if (gppConf) {
    while (handles.length) {
      handles.pop()();
    }
    getSections(gppConf?.mspa || {}).forEach(_ref6 => {
      let [api, sids, normalize] = _ref6;
      return handles.push((0,_libraries_mspa_activityControls_js__WEBPACK_IMPORTED_MODULE_3__.setupRules)(api, sids, normalize));
    });
  }
});
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_4__.registerModule)('gppControl_usstates');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["mspa","chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/gppControl_usstates.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["gptPreAuction"],{

/***/ "./modules/gptPreAuction.js":
/*!**********************************!*\
  !*** ./modules/gptPreAuction.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports _currentConfig, getSegments, getSignals, getSignalsArrayByAuctionsIds, getSignalsIntersection, getAuctionsIdsFromTargeting, appendGptSlots, appendPbAdSlot, makeBidRequestsHook */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _libraries_gptUtils_gptUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libraries/gptUtils/gptUtils.js */ "./libraries/gptUtils/gptUtils.js");
/* harmony import */ var _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/auctionManager.js */ "./src/auctionManager.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/constants.js */ "./src/constants.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dlv/index.js");
var _this = undefined;







const MODULE_NAME = 'GPT Pre-Auction';
let _currentConfig = {};
let hooksAdded = false;
function getSegments(fpd, sections, segtax) {
  return (0,_libraries_gptUtils_gptUtils_js__WEBPACK_IMPORTED_MODULE_0__.getSegments)(fpd, sections, segtax);
}
function getSignals(fpd) {
  return (0,_libraries_gptUtils_gptUtils_js__WEBPACK_IMPORTED_MODULE_0__.getSignals)(fpd);
}
function getSignalsArrayByAuctionsIds(auctionIds) {
  let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_1__.auctionManager.index;
  const signals = auctionIds.map(auctionId => index.getAuction({
    auctionId
  })?.getFPD()?.global).map(getSignals).filter(fpd => fpd);
  return signals;
}
function getSignalsIntersection(signals) {
  const result = {};
  _libraries_gptUtils_gptUtils_js__WEBPACK_IMPORTED_MODULE_0__.taxonomies.forEach(taxonomy => {
    const allValues = signals.flatMap(x => x).filter(x => x.taxonomy === taxonomy).map(x => x.values);
    result[taxonomy] = allValues.length ? allValues.reduce((commonElements, subArray) => {
      return commonElements.filter(element => subArray.includes(element));
    }) : [];
    result[taxonomy] = {
      values: result[taxonomy]
    };
  });
  return result;
}
function getAuctionsIdsFromTargeting(targeting) {
  let am = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_1__.auctionManager;
  return Object.values(targeting).flatMap(x => Object.entries(x)).filter(entry => entry[0] === _src_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.AD_ID || entry[0].startsWith(_src_constants_js__WEBPACK_IMPORTED_MODULE_2__.TARGETING_KEYS.AD_ID + '_')).flatMap(entry => entry[1]).map(adId => am.findBidByAdId(adId)?.auctionId).filter(id => id != null).filter(_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.uniques);
}
const appendGptSlots = adUnits => {
  const {
    customGptSlotMatching
  } = _currentConfig;
  if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.isGptPubadsDefined)()) {
    return;
  }
  const adUnitMap = adUnits.reduce((acc, adUnit) => {
    acc[adUnit.code] = acc[adUnit.code] || [];
    acc[adUnit.code].push(adUnit);
    return acc;
  }, {});
  const adUnitPaths = {};
  window.googletag.pubads().getSlots().forEach(slot => {
    const matchingAdUnitCode = Object.keys(adUnitMap).find(customGptSlotMatching ? customGptSlotMatching(slot) : (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.isAdUnitCodeMatchingSlot)(slot));
    if (matchingAdUnitCode) {
      const path = adUnitPaths[matchingAdUnitCode] = slot.getAdUnitPath();
      const adserver = {
        name: 'gam',
        adslot: sanitizeSlotPath(path)
      };
      adUnitMap[matchingAdUnitCode].forEach(adUnit => {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.dset)(adUnit, 'ortb2Imp.ext.data.adserver', Object.assign({}, adUnit.ortb2Imp?.ext?.data?.adserver, adserver));
      });
    }
  });
  return adUnitPaths;
};
const sanitizeSlotPath = path => {
  const gptConfig = _src_config_js__WEBPACK_IMPORTED_MODULE_5__.config.getConfig('gptPreAuction') || {};
  if (gptConfig.mcmEnabled) {
    return path.replace(/(^\/\d*),\d*\//, '$1/');
  }
  return path;
};
const defaultPreAuction = (adUnit, adServerAdSlot, adUnitPath) => {
  const context = adUnit.ortb2Imp.ext.data;

  // use pbadslot if supplied
  if (context.pbadslot) {
    return context.pbadslot;
  }

  // confirm that GPT is set up
  if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.isGptPubadsDefined)()) {
    return;
  }

  // find all GPT slots with this name
  var gptSlots = window.googletag.pubads().getSlots().filter(slot => slot.getAdUnitPath() === adUnitPath);
  if (gptSlots.length === 0) {
    return; // should never happen
  }
  if (gptSlots.length === 1) {
    return adServerAdSlot;
  }

  // else the adunit code must be div id. append it.
  return `${adServerAdSlot}#${adUnit.code}`;
};
const appendPbAdSlot = adUnit => {
  const context = adUnit.ortb2Imp.ext.data;
  const {
    customPbAdSlot
  } = _currentConfig;

  // use context.pbAdSlot if set (if someone set it already, it will take precedence over others)
  if (context.pbadslot) {
    return;
  }
  if (customPbAdSlot) {
    context.pbadslot = customPbAdSlot(adUnit.code, (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_6__["default"])(context, 'adserver.adslot'));
    return;
  }

  // use data attribute 'data-adslotid' if set
  try {
    const adUnitCodeDiv = document.getElementById(adUnit.code);
    if (adUnitCodeDiv.dataset.adslotid) {
      context.pbadslot = adUnitCodeDiv.dataset.adslotid;
      return;
    }
  } catch (e) {}
  // banner adUnit, use GPT adunit if defined
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_6__["default"])(context, 'adserver.adslot')) {
    context.pbadslot = context.adserver.adslot;
    return;
  }
  context.pbadslot = adUnit.code;
  return true;
};
function warnDeprecation(adUnit) {
  (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(`pbadslot is deprecated and will soon be removed, use gpid instead`, adUnit);
}
const makeBidRequestsHook = function (fn, adUnits) {
  const adUnitPaths = appendGptSlots(adUnits);
  const {
    useDefaultPreAuction,
    customPreAuction
  } = _currentConfig;
  adUnits.forEach(adUnit => {
    // init the ortb2Imp if not done yet
    adUnit.ortb2Imp = adUnit.ortb2Imp || {};
    adUnit.ortb2Imp.ext = adUnit.ortb2Imp.ext || {};
    adUnit.ortb2Imp.ext.data = adUnit.ortb2Imp.ext.data || {};
    const context = adUnit.ortb2Imp.ext;
    // if neither new confs set do old stuff
    if (!customPreAuction && !useDefaultPreAuction) {
      warnDeprecation(adUnit);
      const usedAdUnitCode = appendPbAdSlot(adUnit);
      // gpid should be set to itself if already set, or to what pbadslot was (as long as it was not adUnit code)
      if (!context.gpid && !usedAdUnitCode) {
        context.gpid = context.data.pbadslot;
      }
    } else {
      if (context.data?.pbadslot) {
        warnDeprecation(adUnit);
      }
      let adserverSlot = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_6__["default"])(context, 'data.adserver.adslot');
      let result;
      if (customPreAuction) {
        result = customPreAuction(adUnit, adserverSlot, adUnitPaths?.[adUnit.code]);
      } else if (useDefaultPreAuction) {
        result = defaultPreAuction(adUnit, adserverSlot, adUnitPaths?.[adUnit.code]);
      }
      if (result) {
        context.gpid = context.data.pbadslot = result;
      }
    }
  });
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  return fn.call(_this, adUnits, ...args);
};
const setPpsConfigFromTargetingSet = (next, targetingSet) => {
  // set gpt config
  const auctionsIds = getAuctionsIdsFromTargeting(targetingSet);
  const signals = getSignalsIntersection(getSignalsArrayByAuctionsIds(auctionsIds));
  window.googletag.setConfig && window.googletag.setConfig({
    pps: {
      taxonomies: signals
    }
  });
  next(targetingSet);
};
const handleSetGptConfig = moduleConfig => {
  _currentConfig = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.pick)(moduleConfig, ['enabled', enabled => enabled !== false, 'customGptSlotMatching', customGptSlotMatching => typeof customGptSlotMatching === 'function' && customGptSlotMatching, 'customPbAdSlot', customPbAdSlot => typeof customPbAdSlot === 'function' && customPbAdSlot, 'customPreAuction', customPreAuction => typeof customPreAuction === 'function' && customPreAuction, 'useDefaultPreAuction', useDefaultPreAuction => useDefaultPreAuction ?? true]);
  if (_currentConfig.enabled) {
    if (!hooksAdded) {
      (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_7__.getHook)('makeBidRequests').before(makeBidRequestsHook);
      (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_7__.getHook)('targetingDone').after(setPpsConfigFromTargetingSet);
      hooksAdded = true;
    }
  } else {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logInfo)(`${MODULE_NAME}: Turning off module`);
    _currentConfig = {};
    (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_7__.getHook)('makeBidRequests').getHooks({
      hook: makeBidRequestsHook
    }).remove();
    (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_7__.getHook)('targetingDone').getHooks({
      hook: setPpsConfigFromTargetingSet
    }).remove();
    hooksAdded = false;
  }
};
_src_config_js__WEBPACK_IMPORTED_MODULE_5__.config.getConfig('gptPreAuction', config => handleSetGptConfig(config.gptPreAuction));
handleSetGptConfig({});
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_8__.registerModule)('gptPreAuction');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["gptUtils","chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/gptPreAuction.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["identityLinkIdSystem"],{

/***/ "./modules/identityLinkIdSystem.js":
/*!*****************************************!*\
  !*** ./modules/identityLinkIdSystem.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports storage, identityLinkSubmodule, getEnvelopeFromStorage */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_ajax_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/ajax.js */ "./src/ajax.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_storageManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/storageManager.js */ "./src/storageManager.js");
/* harmony import */ var _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/activities/modules.js */ "./src/activities/modules.js");

/**
 * This module adds IdentityLink to the User ID module
 * The {@link module:modules/userId} module is required
 * @module modules/identityLinkSubmodule
 * @requires module:modules/userId
 */







/**
 * @typedef {import('../modules/userId/index.js').Submodule} Submodule
 * @typedef {import('../modules/userId/index.js').SubmoduleConfig} SubmoduleConfig
 * @typedef {import('../modules/userId/index.js').ConsentData} ConsentData
 * @typedef {import('../modules/userId/index.js').IdResponse} IdResponse
 */

const MODULE_NAME = 'identityLink';
const storage = (0,_src_storageManager_js__WEBPACK_IMPORTED_MODULE_0__.getStorageManager)({
  moduleType: _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_1__.MODULE_TYPE_UID,
  moduleName: MODULE_NAME
});
const liverampEnvelopeName = '_lr_env';

/** @type {Submodule} */
const identityLinkSubmodule = {
  /**
   * used to link submodule with config
   * @type {string}
   */
  name: MODULE_NAME,
  /**
   * used to specify vendor id
   * @type {number}
   */
  gvlid: 97,
  /**
   * decode the stored id value for passing to bid requests
   * @function
   * @param {string} value
   * @returns {{idl_env:string}}
   */
  decode(value) {
    return {
      'idl_env': value
    };
  },
  /**
   * performs action to obtain id and return a value in the callback's response argument
   * @function
   * @param {SubmoduleConfig} [config]
   * @param {ConsentData} [consentData]
   * @returns {IdResponse|undefined}
   */
  getId(config, consentData) {
    const configParams = config && config.params || {};
    if (!configParams || typeof configParams.pid !== 'string') {
      _src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError('identityLink: requires partner id to be defined');
      return;
    }
    const {
      gdpr,
      gpp: gppData
    } = consentData ?? {};
    const hasGdpr = gdpr && typeof gdpr.gdprApplies === 'boolean' && gdpr.gdprApplies ? 1 : 0;
    const gdprConsentString = hasGdpr ? gdpr.consentString : '';
    // use protocol relative urls for http or https
    if (hasGdpr && (!gdprConsentString || gdprConsentString === '')) {
      _src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('identityLink: Consent string is required to call envelope API.');
      return;
    }
    const gppString = gppData && gppData.gppString ? gppData.gppString : false;
    const gppSectionId = gppData && gppData.gppString && gppData.applicableSections.length > 0 && gppData.applicableSections[0] !== -1 ? gppData.applicableSections[0] : false;
    const hasGpp = gppString && gppSectionId;
    const url = `https://api.rlcdn.com/api/identity/envelope?pid=${configParams.pid}${hasGdpr ? '&ct=4&cv=' + gdprConsentString : ''}${hasGpp ? '&gpp=' + gppString + '&gpp_sid=' + gppSectionId : ''}`;
    let resp;
    resp = function (callback) {
      // Check ats during callback so it has a chance to initialise.
      // If ats library is available, use it to retrieve envelope. If not use standard third party endpoint
      if (window.ats && window.ats.retrieveEnvelope) {
        _src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('identityLink: ATS exists!');
        window.ats.retrieveEnvelope(function (envelope) {
          if (envelope) {
            _src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('identityLink: An envelope can be retrieved from ATS!');
            setEnvelopeSource(true);
            callback(JSON.parse(envelope).envelope);
          } else {
            getEnvelope(url, callback, configParams);
          }
        });
      } else {
        // try to get envelope directly from storage if ats lib is not present on a page
        let envelope = getEnvelopeFromStorage();
        if (envelope) {
          _src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('identityLink: LiveRamp envelope successfully retrieved from storage!');
          callback(JSON.parse(envelope).envelope);
        } else {
          getEnvelope(url, callback, configParams);
        }
      }
    };
    return {
      callback: resp
    };
  },
  eids: {
    'idl_env': {
      source: 'liveramp.com',
      atype: 3
    }
  }
};
// return envelope from third party endpoint
function getEnvelope(url, callback, configParams) {
  const callbacks = {
    success: response => {
      let responseObj;
      if (response) {
        try {
          responseObj = JSON.parse(response);
        } catch (error) {
          _src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(error);
        }
      }
      callback(responseObj && responseObj.envelope ? responseObj.envelope : '');
    },
    error: error => {
      _src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo(`identityLink: identityLink: ID fetch encountered an error`, error);
      callback();
    }
  };
  if (!configParams.notUse3P && !storage.getCookie('_lr_retry_request')) {
    setRetryCookie();
    _src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo('identityLink: A 3P retrieval is attempted!');
    setEnvelopeSource(false);
    (0,_src_ajax_js__WEBPACK_IMPORTED_MODULE_3__.ajax)(url, callbacks, undefined, {
      method: 'GET',
      withCredentials: true
    });
  } else {
    callback();
  }
}
function setRetryCookie() {
  let now = new Date();
  now.setTime(now.getTime() + 3600000);
  storage.setCookie('_lr_retry_request', 'true', now.toUTCString());
}
function setEnvelopeSource(src) {
  let now = new Date();
  now.setTime(now.getTime() + 2592000000);
  storage.setCookie('_lr_env_src_ats', src, now.toUTCString());
}
function getEnvelopeFromStorage() {
  let rawEnvelope = storage.getCookie(liverampEnvelopeName) || storage.getDataFromLocalStorage(liverampEnvelopeName);
  return rawEnvelope ? window.atob(rawEnvelope) : undefined;
}
(0,_src_hook_js__WEBPACK_IMPORTED_MODULE_4__.submodule)('userId', identityLinkSubmodule);
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_5__.registerModule)('identityLinkIdSystem');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/identityLinkIdSystem.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["idImportLibrary"],{

/***/ "./modules/idImportLibrary.js":
/*!************************************!*\
  !*** ./modules/idImportLibrary.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports CONF_DEFAULT_FULL_BODY_SCAN, CONF_DEFAULT_INPUT_SCAN, setConfig */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var crypto_js_md5_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto-js/md5.js */ "./node_modules/crypto-js/md5.js");
/* harmony import */ var crypto_js_md5_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js_md5_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _src_activities_activities_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/activities/activities.js */ "./src/activities/activities.js");
/* harmony import */ var _src_activities_activityParams_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/activities/activityParams.js */ "./src/activities/activityParams.js");
/* harmony import */ var _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/activities/modules.js */ "./src/activities/modules.js");
/* harmony import */ var _src_activities_rules_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/activities/rules.js */ "./src/activities/rules.js");
/* harmony import */ var _src_ajax_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/ajax.js */ "./src/ajax.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");










let email;
let conf;
const LOG_PRE_FIX = 'ID-Library: ';
const CONF_DEFAULT_OBSERVER_DEBOUNCE_MS = 250;
const CONF_DEFAULT_FULL_BODY_SCAN = false;
const CONF_DEFAULT_INPUT_SCAN = false;
const OBSERVER_CONFIG = {
  subtree: true,
  attributes: true,
  attributeOldValue: false,
  childList: true,
  attirbuteFilter: ['value'],
  characterData: true,
  characterDataOldValue: false
};
const _logInfo = createLogInfo(LOG_PRE_FIX);
const _logError = createLogError(LOG_PRE_FIX);
function createLogInfo(prefix) {
  return function () {
    for (var _len = arguments.length, strings = new Array(_len), _key = 0; _key < _len; _key++) {
      strings[_key] = arguments[_key];
    }
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logInfo)(prefix + ' ', ...strings);
  };
}
function createLogError(prefix) {
  return function () {
    for (var _len2 = arguments.length, strings = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      strings[_key2] = arguments[_key2];
    }
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)(prefix + ' ', ...strings);
  };
}
function getEmail(value) {
  const matched = value.match(/([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+)/gi);
  if (!matched) {
    return null;
  }
  _logInfo('Email found: ' + matched[0]);
  return matched[0];
}
function bodyAction(mutations, observer) {
  _logInfo('BODY observer on debounce called');
  // If the email is found in the input element, disconnect the observer
  if (email) {
    observer.disconnect();
    _logInfo('Email is found, body observer disconnected');
    return;
  }
  const body = document.body.innerHTML;
  email = getEmail(body);
  if (email !== null) {
    _logInfo(`Email obtained from the body ${email}`);
    observer.disconnect();
    _logInfo('Post data on email found in body');
    postData();
  }
}
function targetAction(mutations, observer) {
  _logInfo('Target observer called');
  for (const mutation of mutations) {
    for (const node of mutation.addedNodes) {
      email = node.textContent;
      if (email) {
        _logInfo('Email obtained from the target ' + email);
        observer.disconnect();
        _logInfo('Post data on email found in target');
        postData();
        return;
      }
    }
  }
}
function addInputElementsElementListner() {
  if (doesInputElementsHaveEmail()) {
    _logInfo('Email found in input elements ' + email);
    _logInfo('Post data on email found in target without');
    postData();
    return;
  }
  _logInfo('Adding input element listeners');
  const inputs = document.querySelectorAll('input[type=text], input[type=email]');
  for (var i = 0; i < inputs.length; i++) {
    _logInfo(`Original Value in Input = ${inputs[i].value}`);
    inputs[i].addEventListener('change', event => processInputChange(event));
    inputs[i].addEventListener('blur', event => processInputChange(event));
  }
}
function addFormInputElementsElementListner(id) {
  _logInfo('Adding input element listeners');
  if (doesFormInputElementsHaveEmail(id)) {
    _logInfo('Email found in input elements ' + email);
    postData();
    return;
  }
  _logInfo('Adding input element listeners');
  const input = document.getElementById(id);
  input.addEventListener('change', event => processInputChange(event));
  input.addEventListener('blur', event => processInputChange(event));
}
function removeInputElementsElementListner() {
  _logInfo('Removing input element listeners');
  const inputs = document.querySelectorAll('input[type=text], input[type=email]');
  for (var i = 0; i < inputs.length; i++) {
    inputs[i].removeEventListener('change', event => processInputChange(event));
    inputs[i].removeEventListener('blur', event => processInputChange(event));
  }
}
function processInputChange(event) {
  const value = event.target.value;
  _logInfo(`Modified Value of input ${event.target.value}`);
  email = getEmail(value);
  if (email !== null) {
    _logInfo('Email found in input ' + email);
    postData();
    removeInputElementsElementListner();
  }
}
function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    const context = this;
    const args = arguments;
    const later = function () {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    if (callNow) {
      func.apply(context, args);
    } else {
      _logInfo('Debounce wait time ' + wait);
      timeout = setTimeout(later, wait);
    }
  };
}
;
function handleTargetElement() {
  const targetObserver = new MutationObserver(debounce(targetAction, conf.debounce, false));
  const targetElement = document.getElementById(conf.target);
  if (targetElement) {
    email = targetElement.textContent;
    if (!email) {
      _logInfo('Finding the email with observer');
      targetObserver.observe(targetElement, OBSERVER_CONFIG);
    } else {
      _logInfo('Target found with target ' + email);
      _logInfo('Post data on email found in target with target');
      postData();
    }
  }
}
function handleBodyElements() {
  email = getEmail(document.body.innerHTML);
  if (email !== null) {
    _logInfo('Email found in body ' + email);
    _logInfo('Post data on email found in the body without observer');
    postData();
    return;
  }
  if (conf.fullscan === true) {
    const bodyObserver = new MutationObserver(debounce(bodyAction, conf.debounce, false));
    bodyObserver.observe(document.body, OBSERVER_CONFIG);
  }
}
function doesInputElementsHaveEmail() {
  const inputs = document.getElementsByTagName('input');
  for (let index = 0; index < inputs.length; ++index) {
    const curInput = inputs[index];
    email = getEmail(curInput.value);
    if (email !== null) {
      return true;
    }
  }
  return false;
}
function doesFormInputElementsHaveEmail(formElementId) {
  const input = document.getElementById(formElementId);
  if (input) {
    email = getEmail(input.value);
    if (email !== null) {
      return true;
    }
  }
  return false;
}
function syncCallback() {
  return {
    success: function () {
      _logInfo('Data synced successfully.');
    },
    error: function () {
      _logInfo('Data sync failed.');
    }
  };
}
function postData() {
  (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_2__.getGlobal)().refreshUserIds();
  const userIds = (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_2__.getGlobal)().getUserIds();
  if (Object.keys(userIds).length === 0) {
    _logInfo('No user ids');
    return;
  }
  _logInfo('Users' + userIds);
  const syncPayload = {};
  syncPayload.hid = crypto_js_md5_js__WEBPACK_IMPORTED_MODULE_0___default()(email).toString();
  syncPayload.uids = userIds;
  const payloadString = JSON.stringify(syncPayload);
  _logInfo(payloadString);
  (0,_src_ajax_js__WEBPACK_IMPORTED_MODULE_3__.ajax)(conf.url, syncCallback(), payloadString, {
    method: 'POST',
    withCredentials: true
  });
}
function associateIds() {
  if (window.MutationObserver || window.WebKitMutationObserver) {
    if (conf.target) {
      handleTargetElement();
    } else if (conf.formElementId) {
      addFormInputElementsElementListner(conf.formElementId);
    } else if (conf.inputscan) {
      addInputElementsElementListner();
    } else {
      handleBodyElements();
    }
  }
}
function setConfig(config) {
  if (!config) {
    _logError('Required confirguration not provided');
    return;
  }
  if (!config.url) {
    _logError('The required url is not configured');
    return;
  }
  if (!(0,_src_activities_rules_js__WEBPACK_IMPORTED_MODULE_4__.isActivityAllowed)(_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_5__.ACTIVITY_ENRICH_UFPD, (0,_src_activities_activityParams_js__WEBPACK_IMPORTED_MODULE_6__.activityParams)(_src_activities_modules_js__WEBPACK_IMPORTED_MODULE_7__.MODULE_TYPE_PREBID, 'idImportLibrary'))) {
    _logError('Permission for id import was denied by CMP');
    return;
  }
  if (typeof config.debounce !== 'number') {
    config.debounce = CONF_DEFAULT_OBSERVER_DEBOUNCE_MS;
    _logInfo('Set default observer debounce to ' + CONF_DEFAULT_OBSERVER_DEBOUNCE_MS);
  }
  if (typeof config.fullscan !== 'boolean') {
    config.fullscan = CONF_DEFAULT_FULL_BODY_SCAN;
    _logInfo('Set default fullscan ' + CONF_DEFAULT_FULL_BODY_SCAN);
  }
  if (typeof config.inputscan !== 'boolean') {
    config.inputscan = CONF_DEFAULT_INPUT_SCAN;
    _logInfo('Set default input scan ' + CONF_DEFAULT_INPUT_SCAN);
  }
  if (typeof config.formElementId == 'string') {
    _logInfo('Looking for formElementId ' + config.formElementId);
  }
  conf = config;
  associateIds();
}
_src_config_js__WEBPACK_IMPORTED_MODULE_8__.config.getConfig('idImportLibrary', config => setConfig(config.idImportLibrary));
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_2__.registerModule)('idImportLibrary');

/***/ }),

/***/ "./node_modules/crypto-js/core.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/core.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native crypto in web worker (Browser)
	    if (typeof self !== 'undefined' && self.crypto) {
	        crypto = self.crypto;
	    }

	    // Native crypto from worker
	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
	        crypto = globalThis.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.crypto) {
	        crypto = __webpack_require__.g.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __webpack_require__(/*! crypto */ "?9157");
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }());

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var j = 0; j < thatSigBytes; j += 4) {
	                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),

/***/ "./node_modules/crypto-js/md5.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/md5.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),

/***/ "?9157":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/idImportLibrary.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["openxBidAdapter"],{

/***/ "./modules/openxBidAdapter.js":
/*!************************************!*\
  !*** ./modules/openxBidAdapter.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports REQUEST_URL, SYNC_URL, DEFAULT_PH, spec */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/adapters/bidderFactory.js */ "./src/adapters/bidderFactory.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/mediaTypes.js */ "./src/mediaTypes.js");
/* harmony import */ var _libraries_ortbConverter_converter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../libraries/ortbConverter/converter.js */ "./libraries/ortbConverter/converter.js");







const bidderConfig = 'hb_pb_ortb';
const bidderVersion = '2.0';
const REQUEST_URL = 'https://rtb.openx.net/openrtbb/prebidjs';
const SYNC_URL = 'https://u.openx.net/w/1.0/pd';
const DEFAULT_PH = '2d1251ae-7f3a-47cf-bd2a-2f288854a0ba';
const spec = {
  code: 'openx',
  gvlid: 69,
  supportedMediaTypes: [_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.BANNER, _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO, _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.NATIVE],
  isBidRequestValid,
  buildRequests,
  interpretResponse,
  getUserSyncs
};
(0,_src_adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_1__.registerBidder)(spec);
const converter = (0,_libraries_ortbConverter_converter_js__WEBPACK_IMPORTED_MODULE_2__.ortbConverter)({
  context: {
    netRevenue: true,
    ttl: 300,
    nativeRequest: {
      eventtrackers: [{
        event: 1,
        methods: [1, 2]
      }]
    }
  },
  imp(buildImp, bidRequest, context) {
    const imp = buildImp(bidRequest, context);
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.mergeDeep)(imp, {
      tagid: bidRequest.params.unit,
      ext: {
        divid: bidRequest.adUnitCode
      }
    });
    if (bidRequest.params.customParams) {
      _src_utils_js__WEBPACK_IMPORTED_MODULE_4__.dset(imp, 'ext.customParams', bidRequest.params.customParams);
    }
    if (bidRequest.params.customFloor && !imp.bidfloor) {
      imp.bidfloor = bidRequest.params.customFloor;
    }
    return imp;
  },
  request(buildRequest, imps, bidderRequest, context) {
    const req = buildRequest(imps, bidderRequest, context);
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.mergeDeep)(req, {
      at: 1,
      ext: {
        bc: `${bidderConfig}_${bidderVersion}`,
        pv: "9.49.0-pre"
      }
    });
    const bid = context.bidRequests[0];
    if (bid.params.coppa) {
      _src_utils_js__WEBPACK_IMPORTED_MODULE_4__.dset(req, 'regs.coppa', 1);
    }
    if (bid.params.doNotTrack) {
      _src_utils_js__WEBPACK_IMPORTED_MODULE_4__.dset(req, 'device.dnt', 1);
    }
    if (bid.params.platform) {
      _src_utils_js__WEBPACK_IMPORTED_MODULE_4__.dset(req, 'ext.platform', bid.params.platform);
    }
    if (bid.params.delDomain) {
      _src_utils_js__WEBPACK_IMPORTED_MODULE_4__.dset(req, 'ext.delDomain', bid.params.delDomain);
    }
    if (bid.params.response_template_name) {
      _src_utils_js__WEBPACK_IMPORTED_MODULE_4__.dset(req, 'ext.response_template_name', bid.params.response_template_name);
    }
    if (bid.params.test) {
      req.test = 1;
    }
    return req;
  },
  bidResponse(buildBidResponse, bid, context) {
    const bidResponse = buildBidResponse(bid, context);
    if (bid.ext) {
      bidResponse.meta.networkId = bid.ext.dsp_id;
      bidResponse.meta.advertiserId = bid.ext.buyer_id;
      bidResponse.meta.brandId = bid.ext.brand_id;
    }
    return bidResponse;
  },
  response(buildResponse, bidResponses, ortbResponse, context) {
    // pass these from request to the responses for use in userSync
    const {
      ortbRequest
    } = context;
    if (ortbRequest.ext) {
      if (ortbRequest.ext.delDomain) {
        _src_utils_js__WEBPACK_IMPORTED_MODULE_4__.dset(ortbResponse, 'ext.delDomain', ortbRequest.ext.delDomain);
      }
      if (ortbRequest.ext.platform) {
        _src_utils_js__WEBPACK_IMPORTED_MODULE_4__.dset(ortbResponse, 'ext.platform', ortbRequest.ext.platform);
      }
    }
    const response = buildResponse(bidResponses, ortbResponse, context);
    // TODO: we may want to standardize this and move fledge logic to ortbConverter
    let fledgeAuctionConfigs = _src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"](ortbResponse, 'ext.fledge_auction_configs');
    if (fledgeAuctionConfigs) {
      fledgeAuctionConfigs = Object.entries(fledgeAuctionConfigs).map(_ref => {
        let [bidId, cfg] = _ref;
        return {
          bidId,
          config: (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.mergeDeep)(Object.assign({}, cfg), {
            auctionSignals: {
              ortb2Imp: context.impContext[bidId]?.imp
            }
          })
        };
      });
      return {
        bids: response.bids,
        paapi: fledgeAuctionConfigs
      };
    } else {
      return response;
    }
  },
  overrides: {
    imp: {
      bidfloor(setBidFloor, imp, bidRequest, context) {
        // enforce floors should always be in USD
        // TODO: does it make sense that request.cur can be any currency, but request.imp[].bidfloorcur must be USD?
        const floor = {};
        setBidFloor(floor, bidRequest, {
          ...context,
          currency: 'USD'
        });
        if (floor.bidfloorcur === 'USD') {
          Object.assign(imp, floor);
        }
      },
      video(orig, imp, bidRequest, context) {
        if (true) {
          // `orig` is the video imp processor, which looks at bidRequest.mediaTypes[VIDEO]
          // to populate imp.video
          // alter its input `bidRequest` to also pick up parameters from `bidRequest.params`
          let videoParams = bidRequest.mediaTypes[_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO];
          if (videoParams) {
            videoParams = Object.assign({}, videoParams, bidRequest.params.video);
            bidRequest = {
              ...bidRequest,
              mediaTypes: {
                [_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO]: videoParams
              }
            };
          }
          orig(imp, bidRequest, context);
        }
      }
    }
  }
});
function isBidRequestValid(bidRequest) {
  const hasDelDomainOrPlatform = bidRequest.params.delDomain || bidRequest.params.platform;
  if (_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"](bidRequest, 'mediaTypes.banner') && hasDelDomainOrPlatform) {
    return !!bidRequest.params.unit || _src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"](bidRequest, 'mediaTypes.banner.sizes.length') > 0;
  }
  return !!(bidRequest.params.unit && hasDelDomainOrPlatform);
}
function buildRequests(bidRequests, bidderRequest) {
  let videoRequests = bidRequests.filter(bidRequest => isVideoBidRequest(bidRequest));
  let bannerAndNativeRequests = bidRequests.filter(bidRequest => isBannerBidRequest(bidRequest) || isNativeBidRequest(bidRequest))
  // In case of multi-format bids remove `video` from mediaTypes as for video a separate bid request is built
  .map(bid => ({
    ...bid,
    mediaTypes: {
      ...bid.mediaTypes,
      video: undefined
    }
  }));
  let requests = bannerAndNativeRequests.length ? [createRequest(bannerAndNativeRequests, bidderRequest, null)] : [];
  videoRequests.forEach(bid => {
    requests.push(createRequest([bid], bidderRequest, _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_0__.VIDEO));
  });
  return requests;
}
function createRequest(bidRequests, bidderRequest, mediaType) {
  return {
    method: 'POST',
    url: _src_config_js__WEBPACK_IMPORTED_MODULE_6__.config.getConfig('openxOrtbUrl') || REQUEST_URL,
    data: converter.toORTB({
      bidRequests,
      bidderRequest,
      context: {
        mediaType
      }
    })
  };
}
function isVideoBidRequest(bidRequest) {
  return _src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"](bidRequest, 'mediaTypes.video');
}
function isNativeBidRequest(bidRequest) {
  return _src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"](bidRequest, 'mediaTypes.native');
}
function isBannerBidRequest(bidRequest) {
  const isNotVideoOrNativeBid = !isVideoBidRequest(bidRequest) && !isNativeBidRequest(bidRequest);
  return _src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"](bidRequest, 'mediaTypes.banner') || isNotVideoOrNativeBid;
}
function interpretResponse(resp, req) {
  if (!resp.body) {
    resp.body = {
      nbr: 0
    };
  }
  return converter.fromORTB({
    request: req.data,
    response: resp.body
  });
}

/**
 * @param syncOptions
 * @param responses
 * @param gdprConsent
 * @param uspConsent
 * @return {{type: (string), url: (*|string)}[]}
 */
function getUserSyncs(syncOptions, responses, gdprConsent, uspConsent) {
  if (syncOptions.iframeEnabled || syncOptions.pixelEnabled) {
    let pixelType = syncOptions.iframeEnabled ? 'iframe' : 'image';
    let queryParamStrings = [];
    let syncUrl = SYNC_URL;
    if (gdprConsent) {
      queryParamStrings.push('gdpr=' + (gdprConsent.gdprApplies ? 1 : 0));
      queryParamStrings.push('gdpr_consent=' + encodeURIComponent(gdprConsent.consentString || ''));
    }
    if (uspConsent) {
      queryParamStrings.push('us_privacy=' + encodeURIComponent(uspConsent));
    }
    if (responses.length > 0 && responses[0].body && responses[0].body.ext) {
      const ext = responses[0].body.ext;
      if (ext.delDomain) {
        syncUrl = `https://${ext.delDomain}/w/1.0/pd`;
      } else if (ext.platform) {
        queryParamStrings.push('ph=' + ext.platform);
      }
    } else {
      queryParamStrings.push('ph=' + DEFAULT_PH);
    }
    return [{
      type: pixelType,
      url: `${syncUrl}${queryParamStrings.length > 0 ? '?' + queryParamStrings.join('&') : ''}`
    }];
  }
}
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_7__.registerModule)('openxBidAdapter');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","ortbConverter","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/openxBidAdapter.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["paapi"],{

/***/ "./modules/paapi.js":
/*!**************************!*\
  !*** ./modules/paapi.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports registerSubmodule, reset, init, adAuctionHeadersHook, buyersToAuctionConfigs, addPaapiConfigHook, IGB_TO_CONFIG, mergeBuyers, partitionBuyers, partitionBuyersByBidder, getPAAPIConfig, getPAAPISize, addPaapiData, NAVIGATOR_APIS, markForFledge, ASYNC_SIGNALS, parallelPaapiProcessing, AsyncPAAPIParam, buildPAAPIParams, onAuctionInit, setImpExtAe, parseExtIgi, parseExtPrebidFledge, setResponsePaapiConfigs */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../src/pbjsORTB.js */ "./src/pbjsORTB.js");
/* harmony import */ var _src_events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/events.js */ "./src/events.js");
/* harmony import */ var _src_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/constants.js */ "./src/constants.js");
/* harmony import */ var _libraries_currencyUtils_currency_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../libraries/currencyUtils/currency.js */ "./libraries/currencyUtils/currency.js");
/* harmony import */ var _src_utils_reducers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/utils/reducers.js */ "./src/utils/reducers.js");
/* harmony import */ var _libraries_weakStore_weakStore_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libraries/weakStore/weakStore.js */ "./libraries/weakStore/weakStore.js");
/* harmony import */ var _src_adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/adapters/bidderFactory.js */ "./src/adapters/bidderFactory.js");
/* harmony import */ var _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../src/utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../src/auctionManager.js */ "./src/auctionManager.js");

/**
 * Collect PAAPI component auction configs from bid adapters and make them available through `pbjs.getPAAPIConfig()`
 */













const MODULE = 'PAAPI';
const submodules = [];
const USED = new WeakSet();
function registerSubmodule(submod) {
  submodules.push(submod);
  submod.init && submod.init({
    getPAAPIConfig,
    expandFilters
  });
}
(0,_src_hook_js__WEBPACK_IMPORTED_MODULE_0__.module)('paapi', registerSubmodule);

/* auction configs as returned by getPAAPIConfigs */
const configsForAuction = (0,_libraries_weakStore_weakStore_js__WEBPACK_IMPORTED_MODULE_1__.auctionStore)();

/* auction configs returned by adapters, but waiting for end-of-auction signals before they're added to configsForAuction */
const pendingConfigsForAuction = (0,_libraries_weakStore_weakStore_js__WEBPACK_IMPORTED_MODULE_1__.auctionStore)();

/* igb returned by adapters, waiting for end-of-auction signals before they're merged into configForAuctions */
const pendingBuyersForAuction = (0,_libraries_weakStore_weakStore_js__WEBPACK_IMPORTED_MODULE_1__.auctionStore)();

/* for auction configs that were generated in parallel with auctions (and contain promises), their resolve/reject methods */
const deferredConfigsForAuction = (0,_libraries_weakStore_weakStore_js__WEBPACK_IMPORTED_MODULE_1__.auctionStore)();
let latestAuctionForAdUnit = {};
let moduleConfig = {};
_src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getConfig('paapi', config => {
  init(config.paapi);
});
function reset() {
  submodules.splice(0, submodules.length);
  latestAuctionForAdUnit = {};
}
function init(cfg) {
  if (cfg && cfg.enabled === true) {
    if (!moduleConfig.enabled) {
      attachHandlers();
    }
    moduleConfig = cfg;
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logInfo)(`${MODULE} enabled (browser ${isFledgeSupported() ? 'supports' : 'does NOT support'} runAdAuction)`, cfg);
  } else {
    if (moduleConfig.enabled) {
      detachHandlers();
    }
    moduleConfig = {};
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logInfo)(`${MODULE} disabled`, cfg);
  }
}
function attachHandlers() {
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_0__.getHook)('addPaapiConfig').before(addPaapiConfigHook);
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_0__.getHook)('makeBidRequests').before(addPaapiData);
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_0__.getHook)('makeBidRequests').after(markForFledge);
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_0__.getHook)('processBidderRequests').before(parallelPaapiProcessing, 9);
  // resolve params before parallel processing
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_0__.getHook)('processBidderRequests').before(buildPAAPIParams, 10);
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_0__.getHook)('processBidderRequests').before(adAuctionHeadersHook);
  _src_events_js__WEBPACK_IMPORTED_MODULE_4__.on(_src_constants_js__WEBPACK_IMPORTED_MODULE_5__.EVENTS.AUCTION_INIT, onAuctionInit);
  _src_events_js__WEBPACK_IMPORTED_MODULE_4__.on(_src_constants_js__WEBPACK_IMPORTED_MODULE_5__.EVENTS.AUCTION_END, onAuctionEnd);
}
function detachHandlers() {
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_0__.getHook)('addPaapiConfig').getHooks({
    hook: addPaapiConfigHook
  }).remove();
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_0__.getHook)('makeBidRequests').getHooks({
    hook: addPaapiData
  }).remove();
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_0__.getHook)('makeBidRequests').getHooks({
    hook: markForFledge
  }).remove();
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_0__.getHook)('processBidderRequests').getHooks({
    hook: parallelPaapiProcessing
  }).remove();
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_0__.getHook)('processBidderRequests').getHooks({
    hook: buildPAAPIParams
  }).remove();
  (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_0__.getHook)('processBidderRequests').getHooks({
    hook: adAuctionHeadersHook
  }).remove();
  _src_events_js__WEBPACK_IMPORTED_MODULE_4__.off(_src_constants_js__WEBPACK_IMPORTED_MODULE_5__.EVENTS.AUCTION_INIT, onAuctionInit);
  _src_events_js__WEBPACK_IMPORTED_MODULE_4__.off(_src_constants_js__WEBPACK_IMPORTED_MODULE_5__.EVENTS.AUCTION_END, onAuctionEnd);
}
function adAuctionHeadersHook(next, spec, bids, bidderRequest, ajax) {
  if (bidderRequest.paapi?.enabled) {
    ajax = (orig => {
      return function (url, callback, data, options) {
        options = options ?? {};
        options.adAuctionHeaders = options.adAuctionHeaders ?? true;
        return orig.call(this, url, callback, data, options);
      };
    })(ajax);
  }
  for (var _len = arguments.length, args = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
    args[_key - 5] = arguments[_key];
  }
  return next.call(this, spec, bids, bidderRequest, ajax, ...args);
}
function getStaticSignals() {
  let adUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const cfg = {};
  const requestedSize = getRequestedSize(adUnit);
  if (requestedSize) {
    cfg.requestedSize = requestedSize;
  }
  return cfg;
}
function getSlotSignals() {
  let bidsReceived = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let bidRequests = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let bidfloor, bidfloorcur;
  if (bidsReceived.length > 0) {
    const bestBid = bidsReceived.reduce((0,_src_utils_reducers_js__WEBPACK_IMPORTED_MODULE_6__.maximum)((0,_libraries_currencyUtils_currency_js__WEBPACK_IMPORTED_MODULE_7__.currencyCompare)(bid => [bid.cpm, bid.currency])));
    bidfloor = bestBid.cpm;
    bidfloorcur = bestBid.currency;
  } else {
    const floors = bidRequests.map(bid => typeof bid.getFloor === 'function' && bid.getFloor()).filter(f => f);
    const minFloor = floors.length && floors.reduce((0,_src_utils_reducers_js__WEBPACK_IMPORTED_MODULE_6__.minimum)((0,_libraries_currencyUtils_currency_js__WEBPACK_IMPORTED_MODULE_7__.currencyCompare)(floor => [floor.floor, floor.currency])));
    bidfloor = minFloor?.floor;
    bidfloorcur = minFloor?.currency;
  }
  const cfg = {};
  if (bidfloor) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_8__.dset)(cfg, 'auctionSignals.prebid.bidfloor', bidfloor);
    bidfloorcur && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_8__.dset)(cfg, 'auctionSignals.prebid.bidfloorcur', bidfloorcur);
  }
  return cfg;
}
function buyersToAuctionConfigs(igbRequests) {
  let merge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : mergeBuyers;
  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : moduleConfig?.componentSeller ?? {};
  let partitioners = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
    compact: igbRequests => partitionBuyers(igbRequests.map(req => req[1])).map(part => [{}, part]),
    expand: partitionBuyersByBidder
  };
  if (!config.auctionConfig) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(MODULE, 'Cannot use IG buyers: paapi.componentSeller.auctionConfig not set', igbRequests.map(req => req[1]));
    return [];
  }
  const partition = partitioners[config.separateAuctions ? 'expand' : 'compact'];
  return partition(igbRequests).map(_ref => {
    let [request, igbs] = _ref;
    const auctionConfig = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.mergeDeep)(merge(igbs), config.auctionConfig);
    auctionConfig.auctionSignals = setFPD(auctionConfig.auctionSignals || {}, request);
    return [request, auctionConfig];
  });
}
function onAuctionEnd(_ref2) {
  let {
    auctionId,
    bidsReceived,
    bidderRequests,
    adUnitCodes,
    adUnits
  } = _ref2;
  const adUnitsByCode = Object.fromEntries(adUnits?.map(au => [au.code, au]) || []);
  const allReqs = bidderRequests?.flatMap(br => br.bids);
  const paapiConfigs = configsForAuction(auctionId);
  (adUnitCodes || []).forEach(au => {
    if (!paapiConfigs.hasOwnProperty(au)) {
      paapiConfigs[au] = null;
    }
    !latestAuctionForAdUnit.hasOwnProperty(au) && (latestAuctionForAdUnit[au] = null);
  });
  const pendingConfigs = pendingConfigsForAuction(auctionId);
  const pendingBuyers = pendingBuyersForAuction(auctionId);
  if (pendingConfigs && pendingBuyers) {
    Object.entries(pendingBuyers).forEach(_ref3 => {
      let [adUnitCode, igbRequests] = _ref3;
      buyersToAuctionConfigs(igbRequests).forEach(_ref4 => {
        let [{
          bidder
        }, auctionConfig] = _ref4;
        return append(pendingConfigs, adUnitCode, {
          id: getComponentSellerConfigId(bidder),
          config: auctionConfig
        });
      });
    });
  }
  const deferredConfigs = deferredConfigsForAuction(auctionId);
  const adUnitsWithConfigs = Array.from(new Set(Object.keys(pendingConfigs).concat(Object.keys(deferredConfigs))));
  const signals = Object.fromEntries(adUnitsWithConfigs.map(adUnitCode => {
    latestAuctionForAdUnit[adUnitCode] = auctionId;
    const forThisAdUnit = bid => bid.adUnitCode === adUnitCode;
    return [adUnitCode, {
      ...getStaticSignals(adUnitsByCode[adUnitCode]),
      ...getSlotSignals(bidsReceived?.filter(forThisAdUnit), allReqs?.filter(forThisAdUnit))
    }];
  }));
  const configsById = {};
  Object.entries(pendingConfigs || {}).forEach(_ref5 => {
    let [adUnitCode, auctionConfigs] = _ref5;
    auctionConfigs.forEach(_ref6 => {
      let {
        id,
        config
      } = _ref6;
      return append(configsById, id, {
        adUnitCode,
        config: (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.mergeDeep)({}, signals[adUnitCode], config)
      });
    });
  });
  function resolveSignals(signals, deferrals) {
    Object.entries(deferrals).forEach(_ref7 => {
      let [signal, {
        resolve,
        default: defaultValue
      }] = _ref7;
      let value = signals.hasOwnProperty(signal) ? signals[signal] : null;
      if (value == null && defaultValue == null) {
        value = undefined;
      } else if (typeof defaultValue === 'object' && typeof value === 'object') {
        value = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.mergeDeep)({}, defaultValue, value);
      } else {
        value = value ?? defaultValue;
      }
      resolve(value);
    });
  }
  Object.entries(deferredConfigs).forEach(_ref8 => {
    let [adUnitCode, {
      top,
      components
    }] = _ref8;
    resolveSignals(signals[adUnitCode], top);
    Object.entries(components).forEach(_ref9 => {
      let [configId, {
        deferrals
      }] = _ref9;
      const matchingConfigs = configsById.hasOwnProperty(configId) ? configsById[configId] : [];
      if (matchingConfigs.length > 1) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(`Received multiple PAAPI configs for the same bidder and seller (${configId}), active PAAPI auctions will only see the first`);
      }
      const {
        config
      } = matchingConfigs.shift() ?? {
        config: {
          ...signals[adUnitCode]
        }
      };
      resolveSignals(config, deferrals);
    });
  });
  const newConfigs = Object.values(configsById).flatMap(configs => configs);
  const hasDeferredConfigs = Object.keys(deferredConfigs).length > 0;
  if (moduleConfig.parallel && hasDeferredConfigs && newConfigs.length > 0) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`Received PAAPI configs after PAAPI auctions were already started in parallel with their contextual auction`, newConfigs);
  }
  newConfigs.forEach(_ref10 => {
    let {
      adUnitCode,
      config
    } = _ref10;
    if (paapiConfigs[adUnitCode] == null) {
      paapiConfigs[adUnitCode] = {
        ...signals[adUnitCode],
        componentAuctions: []
      };
    }
    paapiConfigs[adUnitCode].componentAuctions.push((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.mergeDeep)({}, signals[adUnitCode], config));
  });
  if (!moduleConfig.parallel || !hasDeferredConfigs) {
    submodules.forEach(submod => submod.onAuctionConfig?.(auctionId, paapiConfigs));
  }
}
function append(target, key, value) {
  !target.hasOwnProperty(key) && (target[key] = []);
  target[key].push(value);
}
function setFPD(target, _ref11) {
  let {
    ortb2,
    ortb2Imp
  } = _ref11;
  ortb2 != null && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_8__.dset)(target, 'prebid.ortb2', (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.mergeDeep)({}, ortb2, target.prebid?.ortb2));
  ortb2Imp != null && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_8__.dset)(target, 'prebid.ortb2Imp', (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.mergeDeep)({}, ortb2Imp, target.prebid?.ortb2Imp));
  return target;
}
function getConfigId(bidderCode, seller) {
  return `${bidderCode}::${seller}`;
}
function getComponentSellerConfigId(bidderCode) {
  return moduleConfig.componentSeller.separateAuctions ? `igb::${bidderCode}` : 'igb';
}
function addPaapiConfigHook(next, request, paapiConfig) {
  if (getFledgeConfig(_src_config_js__WEBPACK_IMPORTED_MODULE_2__.config.getCurrentBidder()).enabled) {
    const {
      adUnitCode,
      auctionId,
      bidder
    } = request;
    function storePendingData(store, data) {
      const target = store(auctionId);
      if (target != null) {
        append(target, adUnitCode, data);
      } else {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(MODULE, `Received PAAPI config for auction that has closed (auction '${auctionId}', adUnit '${adUnitCode}')`, data);
      }
    }
    const {
      config,
      igb
    } = paapiConfig;
    if (config) {
      config.auctionSignals = setFPD(config.auctionSignals || {}, request);
      const pbs = config.perBuyerSignals = config.perBuyerSignals ?? {};
      (config.interestGroupBuyers || []).forEach(buyer => {
        pbs[buyer] = setFPD(pbs[buyer] ?? {}, request);
      });
      storePendingData(pendingConfigsForAuction, {
        id: getConfigId(bidder, config.seller),
        config
      });
    }
    if (igb && checkOrigin(igb)) {
      igb.pbs = setFPD(igb.pbs || {}, request);
      storePendingData(pendingBuyersForAuction, [request, igb]);
    }
  }
  next(request, paapiConfig);
}
const IGB_TO_CONFIG = {
  cur: 'perBuyerCurrencies',
  pbs: 'perBuyerSignals',
  ps: 'perBuyerPrioritySignals',
  maxbid: 'auctionSignals.prebid.perBuyerMaxbid'
};
function checkOrigin(igb) {
  if (igb.origin) return true;
  (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)('PAAPI buyer does not specify origin and will be ignored', igb);
}

/**
 * Convert a list of InterestGroupBuyer (igb) objects into a partial auction config.
 * https://github.com/InteractiveAdvertisingBureau/openrtb/blob/main/extensions/community_extensions/Protected%20Audience%20Support.md
 */
function mergeBuyers(igbs) {
  const buyers = new Set();
  return Object.assign(igbs.reduce((config, igb) => {
    if (checkOrigin(igb)) {
      if (!buyers.has(igb.origin)) {
        buyers.add(igb.origin);
        Object.entries(IGB_TO_CONFIG).forEach(_ref12 => {
          let [igbField, configField] = _ref12;
          if (igb[igbField] != null) {
            const entry = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_9__["default"])(config, configField) || {};
            entry[igb.origin] = igb[igbField];
            (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_8__.dset)(config, configField, entry);
          }
        });
      } else {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(MODULE, `Duplicate buyer: ${igb.origin}. All but the first will be ignored`, igbs);
      }
    }
    return config;
  }, {}), {
    interestGroupBuyers: Array.from(buyers.keys())
  });
}

/**
 * Partition a list of InterestGroupBuyer (igb) object into sets that can each be merged into a single auction.
 * If the same buyer (origin) appears more than once, it will be split across different partition unless the igb objects
 * are identical.
 */
function partitionBuyers(igbs) {
  return igbs.reduce((partitions, igb) => {
    if (checkOrigin(igb)) {
      let partition = partitions.find(part => !part.hasOwnProperty(igb.origin) || (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.deepEqual)(part[igb.origin], igb));
      if (!partition) {
        partition = {};
        partitions.push(partition);
      }
      partition[igb.origin] = igb;
    }
    return partitions;
  }, []).map(part => Object.values(part));
}
function partitionBuyersByBidder(igbRequests) {
  const requests = {};
  const igbs = {};
  igbRequests.forEach(_ref13 => {
    let [request, igb] = _ref13;
    !requests.hasOwnProperty(request.bidder) && (requests[request.bidder] = request);
    append(igbs, request.bidder, igb);
  });
  return Object.entries(igbs).map(_ref14 => {
    let [bidder, igbs] = _ref14;
    return [requests[bidder], igbs];
  });
}

/**
 * Expand PAAPI api filters into a map from ad unit code to auctionId.
 *
 * @param {Object} [options]
 * @param {string} [options.auctionId] when specified, the result will have this as the value for each entry.
 *   when not specified, each ad unit will map to the latest auction that involved that ad unit.
 * @param {string} [options.adUnitCode] when specified, the result will contain only one entry (for this ad unit) or be empty (if this ad
 * unit was never involved in an auction).
 * when not specified, the result will contain an entry for every ad unit that was involved in any auction.
 * @return {{[adUnitCode: string]: string}}
 */
function expandFilters() {
  let {
    auctionId,
    adUnitCode
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let adUnitCodes = [];
  if (adUnitCode == null) {
    adUnitCodes = Object.keys(latestAuctionForAdUnit);
  } else if (latestAuctionForAdUnit.hasOwnProperty(adUnitCode)) {
    adUnitCodes = [adUnitCode];
  }
  return Object.fromEntries(adUnitCodes.map(au => [au, auctionId ?? latestAuctionForAdUnit[au]]));
}

/**
 * Get PAAPI auction configuration.
 *
 * @param {Object} [filters] - Filters object
 * @param {string} [filters.auctionId] optional auction filter; if omitted, the latest auction for each ad unit is used
 * @param {string} [filters.adUnitCode] optional ad unit filter
 * @param {boolean} [includeBlanks=false] if true, include null entries for ad units that match the given filters but do not have any available auction configs.
 * @returns {Object} a map from ad unit code to auction config for the ad unit.
 */
function getPAAPIConfig() {
  let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let includeBlanks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  const output = {};
  Object.entries(expandFilters(filters)).forEach(_ref15 => {
    let [au, auctionId] = _ref15;
    const auctionConfigs = configsForAuction(auctionId);
    if (auctionConfigs?.hasOwnProperty(au)) {
      // ad unit was involved in a PAAPI auction
      const candidate = auctionConfigs[au];
      if (candidate && !USED.has(candidate)) {
        output[au] = candidate;
        USED.add(candidate);
      } else if (includeBlanks) {
        output[au] = null;
      }
    } else if (auctionId == null && includeBlanks) {
      // ad unit was involved in a non-PAAPI auction
      output[au] = null;
    }
  });
  return output;
}
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_10__.getGlobal)().getPAAPIConfig = filters => getPAAPIConfig(filters);
function isFledgeSupported() {
  return 'runAdAuction' in navigator && 'joinAdInterestGroup' in navigator;
}
function getFledgeConfig(bidder) {
  const enabled = moduleConfig.enabled && (bidder == null || !moduleConfig.bidders?.length || moduleConfig.bidders?.includes(bidder));
  return {
    enabled,
    ae: enabled ? moduleConfig.defaultForSlots : undefined
  };
}

/**
 * Given an array of size tuples, return the one that should be used for PAAPI.
 */
const getPAAPISize = (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_0__.hook)('sync', function (sizes) {
  sizes = sizes?.filter(_ref16 => {
    let [w, h] = _ref16;
    return !(w === h && w <= 5);
  });
  if (sizes?.length) {
    return sizes.reduce((0,_src_utils_reducers_js__WEBPACK_IMPORTED_MODULE_6__.maximum)((0,_src_utils_reducers_js__WEBPACK_IMPORTED_MODULE_6__.keyCompare)(_ref17 => {
      let [w, h] = _ref17;
      return w * h;
    })));
  }
}, 'getPAAPISize');
function getRequestedSize(adUnit) {
  return adUnit.ortb2Imp?.ext?.paapi?.requestedSize || (() => {
    const size = getPAAPISize((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.sizesToSizeTuples)(adUnit.mediaTypes?.banner?.sizes));
    if (size) {
      return {
        width: size[0],
        height: size[1]
      };
    }
  })();
}
function addPaapiData(next, adUnits) {
  if (isFledgeSupported() && moduleConfig.enabled) {
    adUnits.forEach(adUnit => {
      // https://github.com/InteractiveAdvertisingBureau/openrtb/blob/main/extensions/community_extensions/Protected%20Audience%20Support.md
      const igsAe = adUnit.ortb2Imp?.ext?.igs != null ? adUnit.ortb2Imp.ext.igs.ae || 1 : null;
      const extAe = adUnit.ortb2Imp?.ext?.ae;
      if (igsAe !== extAe && igsAe != null && extAe != null) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(MODULE, `Ad unit defines conflicting ortb2Imp.ext.ae and ortb2Imp.ext.igs, using the latter`, adUnit);
      }
      const ae = igsAe ?? extAe ?? moduleConfig.defaultForSlots;
      if (ae) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_8__.dset)(adUnit, 'ortb2Imp.ext.ae', ae);
        adUnit.ortb2Imp.ext.igs = Object.assign({
          ae: ae,
          biddable: 1
        }, adUnit.ortb2Imp.ext.igs);
        const requestedSize = getRequestedSize(adUnit);
        if (requestedSize) {
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_8__.dset)(adUnit, 'ortb2Imp.ext.paapi.requestedSize', requestedSize);
        }
        adUnit.bids.forEach(bidReq => {
          if (!getFledgeConfig(bidReq.bidder).enabled) {
            (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_8__.dset)(bidReq, 'ortb2Imp.ext.ae', 0);
            bidReq.ortb2Imp.ext.igs = {
              ae: 0,
              biddable: 0
            };
          }
        });
      }
    });
  }
  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    args[_key2 - 2] = arguments[_key2];
  }
  next(adUnits, ...args);
}
const NAVIGATOR_APIS = ['createAuctionNonce', 'getInterestGroupAdAuctionData'];
function markForFledge(next, bidderRequests) {
  if (isFledgeSupported()) {
    bidderRequests.forEach(bidderReq => {
      const {
        enabled
      } = getFledgeConfig(bidderReq.bidderCode);
      Object.assign(bidderReq, {
        paapi: {
          enabled,
          componentSeller: !!moduleConfig.componentSeller?.auctionConfig
        }
      });
      if (enabled) {
        NAVIGATOR_APIS.forEach(method => {
          bidderReq.paapi[method] = function () {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }
            return new AsyncPAAPIParam(() => navigator[method](...args));
          };
        });
      }
    });
  }
  next(bidderRequests);
}
const ASYNC_SIGNALS = ['auctionSignals', 'sellerSignals', 'perBuyerSignals', 'perBuyerTimeouts', 'directFromSellerSignals', 'perBuyerCurrencies', 'perBuyerCumulativeTimeouts', 'serverResponse'];
const validatePartialConfig = (() => {
  const REQUIRED_SYNC_SIGNALS = [{
    props: ['seller'],
    validate: val => typeof val === 'string'
  }, {
    props: ['interestGroupBuyers'],
    validate: val => Array.isArray(val) && val.length > 0
  }, {
    props: ['decisionLogicURL', 'decisionLogicUrl'],
    validate: val => typeof val === 'string'
  }];
  return function (config) {
    const invalid = REQUIRED_SYNC_SIGNALS.find(_ref18 => {
      let {
        props,
        validate
      } = _ref18;
      return props.every(prop => !config.hasOwnProperty(prop) || !config[prop] || !validate(config[prop]));
    });
    if (invalid) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`Partial PAAPI config has missing or invalid property "${invalid.props[0]}"`, config);
      return false;
    }
    return true;
  };
})();
function callAdapterApi(spec, method, bids, bidderRequest) {
  const metrics = (0,_src_adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_11__.adapterMetrics)(bidderRequest);
  const tidGuard = (0,_src_adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_11__.guardTids)(bidderRequest);
  let result;
  metrics.measureTime(method, () => {
    try {
      result = spec[method](bids.map(tidGuard.bidRequest), tidGuard.bidderRequest(bidderRequest));
    } catch (e) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`Error invoking "${method}":`, e);
    }
  });
  return result;
}

/**
 * Adapters can provide a `spec.buildPAAPIConfigs(validBidRequests, bidderRequest)` to be included in PAAPI auctions
 * that can be started in parallel with contextual auctions.
 *
 * If PAAPI is enabled, and an adapter provides `buildPAAPIConfigs`, it is invoked just before `buildRequests`,
 * and takes the same arguments. It should return an array of PAAPI configuration objects with the same format
 * as in `interpretResponse` (`{bidId, config?, igb?}`).
 *
 * Everything returned by `buildPAAPIConfigs` is treated in the same way as if it was returned by `interpretResponse` -
 * except for signals that can be provided asynchronously (cfr. `ASYNC_SIGNALS`), which are replaced by promises.
 * When the (contextual) auction ends, the promises are resolved.
 *
 * If during the auction the adapter's `interpretResponse` returned matching configurations (same `bidId`,
 * and a `config` with the same `seller`, or an `igb` with the same `origin`), the promises resolve to their contents.
 * Otherwise, they resolve to the values provided by `buildPAAPIConfigs`, or an empty object if no value was provided.
 *
 * Promisified auction configs are available from `getPAAPIConfig` immediately after `requestBids`.
 * If the `paapi.parallel` config flag is set, PAAPI submodules are also triggered at the same time
 * (instead of when the auction ends).
 */
function parallelPaapiProcessing(next, spec, bids, bidderRequest) {
  function makeDeferrals() {
    let defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let promises = {};
    const deferrals = Object.fromEntries(ASYNC_SIGNALS.map(signal => {
      const def = (0,_src_utils_promise_js__WEBPACK_IMPORTED_MODULE_12__.defer)({
        promiseFactory: resolver => new Promise(resolver)
      });
      def.default = defaults.hasOwnProperty(signal) ? defaults[signal] : null;
      promises[signal] = def.promise;
      return [signal, def];
    }));
    return [deferrals, promises];
  }
  const {
    auctionId,
    paapi: {
      enabled,
      componentSeller
    } = {}
  } = bidderRequest;
  const auctionConfigs = configsForAuction(auctionId);
  bids.map(bid => bid.adUnitCode).forEach(adUnitCode => {
    latestAuctionForAdUnit[adUnitCode] = auctionId;
    if (!auctionConfigs.hasOwnProperty(adUnitCode)) {
      auctionConfigs[adUnitCode] = null;
    }
  });
  if (enabled && spec.buildPAAPIConfigs) {
    const partialConfigs = callAdapterApi(spec, 'buildPAAPIConfigs', bids, bidderRequest);
    const requestsById = Object.fromEntries(bids.map(bid => [bid.bidId, bid]));
    (partialConfigs ?? []).forEach(_ref19 => {
      let {
        bidId,
        config,
        igb
      } = _ref19;
      const bidRequest = requestsById.hasOwnProperty(bidId) && requestsById[bidId];
      if (!bidRequest) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`Received partial PAAPI config for unknown bidId`, {
          bidId,
          config
        });
      } else {
        const adUnitCode = bidRequest.adUnitCode;
        latestAuctionForAdUnit[adUnitCode] = auctionId;
        const deferredConfigs = deferredConfigsForAuction(auctionId);
        const getDeferredConfig = () => {
          if (!deferredConfigs.hasOwnProperty(adUnitCode)) {
            const [deferrals, promises] = makeDeferrals();
            auctionConfigs[adUnitCode] = {
              ...getStaticSignals(_src_auctionManager_js__WEBPACK_IMPORTED_MODULE_13__.auctionManager.index.getAdUnit(bidRequest)),
              ...promises,
              componentAuctions: []
            };
            deferredConfigs[adUnitCode] = {
              top: deferrals,
              components: {},
              auctionConfig: auctionConfigs[adUnitCode]
            };
          }
          return deferredConfigs[adUnitCode];
        };
        if (config && validatePartialConfig(config)) {
          const configId = getConfigId(bidRequest.bidder, config.seller);
          const deferredConfig = getDeferredConfig();
          if (deferredConfig.components.hasOwnProperty(configId)) {
            (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(`Received multiple PAAPI configs for the same bidder and seller; config will be ignored`, {
              config,
              bidder: bidRequest.bidder
            });
          } else {
            const [deferrals, promises] = makeDeferrals(config);
            const auctionConfig = {
              ...getStaticSignals(bidRequest),
              ...config,
              ...promises
            };
            deferredConfig.auctionConfig.componentAuctions.push(auctionConfig);
            deferredConfig.components[configId] = {
              auctionConfig,
              deferrals
            };
          }
        }
        if (componentSeller && igb && checkOrigin(igb)) {
          const configId = getComponentSellerConfigId(spec.code);
          const deferredConfig = getDeferredConfig();
          const partialConfig = buyersToAuctionConfigs([[bidRequest, igb]])[0][1];
          if (deferredConfig.components.hasOwnProperty(configId)) {
            const {
              auctionConfig,
              deferrals
            } = deferredConfig.components[configId];
            if (!auctionConfig.interestGroupBuyers.includes(igb.origin)) {
              const immediate = {};
              Object.entries(partialConfig).forEach(_ref20 => {
                let [key, value] = _ref20;
                if (deferrals.hasOwnProperty(key)) {
                  (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.mergeDeep)(deferrals[key], {
                    default: value
                  });
                } else {
                  immediate[key] = value;
                }
              });
              (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.mergeDeep)(auctionConfig, immediate);
            } else {
              (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(`Received the same PAAPI buyer multiple times for the same PAAPI auction. Consider setting paapi.componentSeller.separateAuctions: true`, igb);
            }
          } else {
            const [deferrals, promises] = makeDeferrals(partialConfig);
            const auctionConfig = {
              ...partialConfig,
              ...getStaticSignals(bidRequest),
              ...promises
            };
            deferredConfig.components[configId] = {
              auctionConfig,
              deferrals
            };
            deferredConfig.auctionConfig.componentAuctions.push(auctionConfig);
          }
        }
      }
    });
  }
  for (var _len4 = arguments.length, args = new Array(_len4 > 4 ? _len4 - 4 : 0), _key4 = 4; _key4 < _len4; _key4++) {
    args[_key4 - 4] = arguments[_key4];
  }
  return next.call(this, spec, bids, bidderRequest, ...args);
}
class AsyncPAAPIParam {
  constructor(resolve) {
    this.resolve = resolve;
  }
}
function buildPAAPIParams(next, spec, bids, bidderRequest) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 4 ? _len5 - 4 : 0), _key5 = 4; _key5 < _len5; _key5++) {
    args[_key5 - 4] = arguments[_key5];
  }
  if (bidderRequest.paapi?.enabled && spec.paapiParameters) {
    const params = callAdapterApi(spec, 'paapiParameters', bids, bidderRequest);
    return _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_12__.PbPromise.all(Object.entries(params ?? {}).map(_ref21 => {
      let [key, value] = _ref21;
      return value instanceof AsyncPAAPIParam ? value.resolve().then(result => [key, result]) : Promise.resolve([key, value]);
    })).then(resolved => {
      bidderRequest.paapi.params = Object.fromEntries(resolved);
    }).catch(err => {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`Could not resolve PAAPI parameters`, err);
    }).then(() => {
      next.call(this, spec, bids, bidderRequest, ...args);
    });
  } else {
    next.call(this, spec, bids, bidderRequest, ...args);
  }
}
function onAuctionInit(_ref22) {
  let {
    auctionId
  } = _ref22;
  if (moduleConfig.parallel) {
    _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_13__.auctionManager.index.getAuction({
      auctionId
    }).requestsDone.then(() => {
      if (Object.keys(deferredConfigsForAuction(auctionId)).length > 0) {
        submodules.forEach(submod => submod.onAuctionConfig?.(auctionId, configsForAuction(auctionId)));
      }
    });
  }
}
function setImpExtAe(imp, bidRequest, context) {
  if (!context.bidderRequest.paapi?.enabled) {
    delete imp.ext?.ae;
    delete imp.ext?.igs;
  }
}
(0,_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_14__.registerOrtbProcessor)({
  type: _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_14__.IMP,
  name: 'impExtAe',
  fn: setImpExtAe
});
function parseExtIgi(response, ortbResponse, context) {
  paapiResponseParser((ortbResponse.ext?.igi || []).flatMap(igi => {
    return (igi?.igs || []).map(igs => {
      if (igs.impid !== igi.impid && igs.impid != null && igi.impid != null) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(MODULE, 'ORTB response ext.igi.igs.impid conflicts with parent\'s impid', igi);
      }
      return {
        config: igs.config,
        impid: igs.impid ?? igi.impid
      };
    }).concat((igi?.igb || []).map(igb => ({
      igb,
      impid: igi.impid
    })));
  }), response, context);
}
function paapiResponseParser(configs, response, context) {
  configs.forEach(config => {
    const impCtx = context.impContext[config.impid];
    if (!impCtx?.imp?.ext?.ae) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(MODULE, 'Received auction configuration for an impression that was not in the request or did not ask for it', config, impCtx?.imp);
    } else {
      impCtx.paapiConfigs = impCtx.paapiConfigs || [];
      impCtx.paapiConfigs.push(config);
    }
  });
}

// to make it easier to share code between the PBS adapter and adapters whose backend is PBS, break up
// fledge response processing in two steps: first aggregate all the auction configs by their imp...

function parseExtPrebidFledge(response, ortbResponse, context) {
  paapiResponseParser(ortbResponse.ext?.prebid?.fledge?.auctionconfigs || [], response, context);
}
(0,_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_14__.registerOrtbProcessor)({
  type: _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_14__.RESPONSE,
  name: 'extPrebidFledge',
  fn: parseExtPrebidFledge,
  dialects: [_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_14__.PBS]
});
(0,_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_14__.registerOrtbProcessor)({
  type: _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_14__.RESPONSE,
  name: 'extIgiIgs',
  fn: parseExtIgi
});

// ...then, make them available in the adapter's response. This is the client side version, for which the
// interpretResponse api is {fledgeAuctionConfigs: [{bidId, config}]}

function setResponsePaapiConfigs(response, ortbResponse, context) {
  const configs = Object.values(context.impContext).flatMap(impCtx => (impCtx.paapiConfigs || []).map(cfg => ({
    bidId: impCtx.bidRequest.bidId,
    ...cfg
  })));
  if (configs.length > 0) {
    response.paapi = configs;
  }
}
(0,_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_14__.registerOrtbProcessor)({
  type: _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_14__.RESPONSE,
  name: 'paapiConfigs',
  priority: -1,
  fn: setResponsePaapiConfigs
});
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_10__.registerModule)('paapi');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","currencyUtils","weakStore","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/paapi.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["paapiForGpt"],{

/***/ "./modules/paapiForGpt.js":
/*!********************************!*\
  !*** ./modules/paapiForGpt.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports setTargetingHookFactory, slotConfigurator, getPAAPISizeHook, setPAAPIConfigFactory */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_utils_reducers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/utils/reducers.js */ "./src/utils/reducers.js");
/* harmony import */ var _src_targeting_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/targeting.js */ "./src/targeting.js");

/**
 * GPT-specific slot configuration logic for PAAPI.
 */






const MODULE = 'paapiForGpt';
let getPAAPIConfig;
_src_config_js__WEBPACK_IMPORTED_MODULE_0__.config.getConfig('paapi', cfg => {
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"])(cfg, 'paapi.gpt.configWithTargeting', true)) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)(MODULE, 'enabling PAAPI configuration with setTargetingForGPTAsync');
    _src_targeting_js__WEBPACK_IMPORTED_MODULE_3__.targeting.setTargetingForGPT.before(setTargetingHook);
  } else {
    _src_targeting_js__WEBPACK_IMPORTED_MODULE_3__.targeting.setTargetingForGPT.getHooks({
      hook: setTargetingHook
    }).remove();
  }
});
function setTargetingHookFactory() {
  let setPaapiConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_4__.getGlobal)().setPAAPIConfigForGPT;
  return function (next, adUnit, customSlotMatching) {
    const adUnitCodes = Array.isArray(adUnit) ? adUnit : [adUnit];
    adUnitCodes.map(adUnitCode => adUnitCode == null ? undefined : {
      adUnitCode
    }).forEach(filters => setPaapiConfig(filters, customSlotMatching));
    next(adUnit, customSlotMatching);
  };
}
function slotConfigurator() {
  const PREVIOUSLY_SET = {};
  return function setComponentAuction(adUnitCode, gptSlots, auctionConfigs) {
    let reset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    if (gptSlots.length > 0) {
      let previous = PREVIOUSLY_SET[adUnitCode] ?? {};
      let configsBySeller = Object.fromEntries(auctionConfigs.map(cfg => [cfg.seller, cfg]));
      const sellers = Object.keys(configsBySeller);
      if (reset) {
        configsBySeller = Object.assign(previous, configsBySeller);
        previous = Object.fromEntries(sellers.map(seller => [seller, null]));
      } else {
        sellers.forEach(seller => {
          previous[seller] = null;
        });
      }
      Object.keys(previous).length ? PREVIOUSLY_SET[adUnitCode] = previous : delete PREVIOUSLY_SET[adUnitCode];
      const componentAuction = Object.entries(configsBySeller).map(_ref => {
        let [configKey, auctionConfig] = _ref;
        return {
          configKey,
          auctionConfig
        };
      });
      if (componentAuction.length > 0) {
        gptSlots.forEach(gptSlot => {
          gptSlot.setConfig({
            componentAuction
          });
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)(MODULE, `register component auction configs for: ${adUnitCode}: ${gptSlot.getAdUnitPath()}`, auctionConfigs);
          // reference https://developers.google.com/publisher-tag/reference#googletag.config.ComponentAuctionConfig
        });
      }
    } else if (auctionConfigs.length > 0) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)(MODULE, `unable to register component auction config for ${adUnitCode}`, auctionConfigs);
    }
  };
}
const setComponentAuction = slotConfigurator();
const getPAAPISizeHook = (() => {
  /*
    https://github.com/google/ads-privacy/tree/master/proposals/fledge-multiple-seller-testing#faq
    https://support.google.com/admanager/answer/1100453?hl=en
      Ignore any placeholder sizes, where placeholder is defined as a square creative with a side of <= 5 pixels
    Look if there are any sizes that are part of the set of supported ad sizes defined here. If there are, choose the largest supported size by area (width * height)
        For clarity, the set of supported ad sizes includes all of the ad sizes listed under “Top-performing ad sizes”, “Other supported ad sizes”, and “Regional ad sizes”.
    If not, choose the largest remaining size (i.e. that isn’t in the list of supported ad sizes) by area (width * height)
   */
  const SUPPORTED_SIZES = [[728, 90], [336, 280], [300, 250], [300, 50], [160, 600], [1024, 768], [970, 250], [970, 90], [768, 1024], [480, 320], [468, 60], [320, 480], [320, 100], [320, 50], [300, 600], [300, 100], [250, 250], [234, 60], [200, 200], [180, 150], [125, 125], [120, 600], [120, 240], [120, 60], [88, 31], [980, 120], [980, 90], [950, 90], [930, 180], [750, 300], [750, 200], [750, 100], [580, 400], [250, 360], [240, 400]].sort((0,_src_utils_reducers_js__WEBPACK_IMPORTED_MODULE_5__.keyCompare)(_ref2 => {
    let [w, h] = _ref2;
    return -(w * h);
  })).map(size => [size, (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.sizeTupleToSizeString)(size)]);
  return function (next, sizes) {
    if (sizes?.length) {
      const sizeStrings = new Set(sizes.map(_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.sizeTupleToSizeString));
      const preferredSize = SUPPORTED_SIZES.find(_ref3 => {
        let [_, sizeStr] = _ref3;
        return sizeStrings.has(sizeStr);
      });
      if (preferredSize) {
        next.bail(preferredSize[0]);
        return;
      }
    }
    next(sizes);
  };
})();
function setPAAPIConfigFactory() {
  let getConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : filters => getPAAPIConfig(filters, true);
  let setGptConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : setComponentAuction;
  let getSlots = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _src_targeting_js__WEBPACK_IMPORTED_MODULE_3__.getGPTSlotsForAdUnits;
  /**
   * Configure GPT slots with PAAPI auction configs.
   * `filters` are the same filters accepted by `pbjs.getPAAPIConfig`;
   */
  return function () {
    let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let customSlotMatching = arguments.length > 1 ? arguments[1] : undefined;
    let some = false;
    const cfg = getConfig(filters) || {};
    const auToSlots = getSlots(Object.keys(cfg), customSlotMatching);
    Object.entries(cfg).forEach(_ref4 => {
      let [au, config] = _ref4;
      if (config != null) {
        some = true;
      }
      setGptConfig(au, auToSlots[au], config?.componentAuctions || [], true);
    });
    if (!some) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)(`${MODULE}: No component auctions available to set`);
    }
  };
}
/**
 * Configure GPT slots with PAAPI component auctions. Accepts the same filter arguments as `pbjs.getPAAPIConfig`.
 */
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_4__.getGlobal)().setPAAPIConfigForGPT = setPAAPIConfigFactory();
const setTargetingHook = setTargetingHookFactory();
(0,_src_hook_js__WEBPACK_IMPORTED_MODULE_6__.submodule)('paapi', {
  name: 'gpt',
  init(params) {
    getPAAPIConfig = params.getPAAPIConfig;
    (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_6__.getHook)('getPAAPISize').before(getPAAPISizeHook);
  }
});
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_4__.registerModule)('paapiForGpt');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/paapiForGpt.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["prebidServerBidAdapter"],{

/***/ "./modules/prebidServerBidAdapter/bidderConfig.js":
/*!********************************************************!*\
  !*** ./modules/prebidServerBidAdapter/bidderConfig.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   premergeFpd: () => (/* binding */ premergeFpd)
/* harmony export */ });
/* unused harmony exports getPBSBidderConfig, extractEids, consolidateEids */
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _src_activities_redactor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/activities/redactor.js */ "./src/activities/redactor.js");



/**
 * Perform a partial pre-merge of bidder config for PBS.
 *
 * Prebid.js and Prebid Server use different strategies for merging global and bidder-specific config; JS attemps to
 * merge arrays (concatenating them, with some deduping, cfr. mergeDeep), while PBS only merges objects -
 * a bidder-specific array will replace a global array.
 *
 * This returns bidder config (from `bidder`) where arrays are replaced with what you get from merging them with `global`,
 * so that the result of merging in PBS is the same as in JS.
 */
function getPBSBidderConfig(_ref) {
  let {
    global,
    bidder
  } = _ref;
  return Object.fromEntries(Object.entries(bidder).map(_ref2 => {
    let [bidderCode, bidderConfig] = _ref2;
    return [bidderCode, replaceArrays(bidderConfig, (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.mergeDeep)({}, global, bidderConfig))];
  }));
}
function replaceArrays(config, mergedConfig) {
  return Object.fromEntries(Object.entries(config).map(_ref3 => {
    let [key, value] = _ref3;
    const mergedValue = mergedConfig[key];
    if (Array.isArray(value)) {
      if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepEqual)(value, mergedValue) && Array.isArray(mergedValue)) {
        value = mergedValue;
      }
    } else if (value != null && typeof value === 'object') {
      value = replaceArrays(value, mergedValue);
    }
    return [key, value];
  }));
}

/**
 * Extract all EIDs from FPD.
 *
 * Returns {eids, conflicts}, where:
 *
 *  - `eids` contains an object of the form `{eid, bidders}` for each unique EID object found anywhere in FPD;
 *      `bidders` is a list of all the bidders that refer to that specific EID object, or false if that EID object is defined globally.
 *   - `conflicts` is a set containing all EID sources that appear in multiple, otherwise different, EID objects.
 */
function extractEids(_ref4) {
  let {
    global,
    bidder
  } = _ref4;
  const entries = [];
  const bySource = {};
  const conflicts = new Set();
  function getEntry(eid) {
    let entry = entries.find(candidate => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepEqual)(candidate.eid, eid));
    if (entry == null) {
      entry = {
        eid,
        bidders: new Set()
      };
      entries.push(entry);
    }
    if (bySource[eid.source] == null) {
      bySource[eid.source] = entry.eid;
    } else if (entry.eid === eid) {
      // if this is the first time we see this eid, but not the first time we see its source, we have a conflict
      conflicts.add(eid.source);
    }
    return entry;
  }
  _src_activities_redactor_js__WEBPACK_IMPORTED_MODULE_1__.ORTB_EIDS_PATHS.forEach(path => {
    ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__["default"])(global, path) || []).forEach(eid => {
      getEntry(eid).bidders = false;
    });
  });
  Object.entries(bidder).forEach(_ref5 => {
    let [bidderCode, bidderConfig] = _ref5;
    _src_activities_redactor_js__WEBPACK_IMPORTED_MODULE_1__.ORTB_EIDS_PATHS.forEach(path => {
      ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__["default"])(bidderConfig, path) || []).forEach(eid => {
        const entry = getEntry(eid);
        if (entry.bidders !== false) {
          entry.bidders.add(bidderCode);
        }
      });
    });
  });
  return {
    eids: entries.map(_ref6 => {
      let {
        eid,
        bidders
      } = _ref6;
      return {
        eid,
        bidders: bidders && Array.from(bidders)
      };
    }),
    conflicts
  };
}

/**
 * Consolidate extracted EIDs to take advantage of PBS's eidpermissions feature:
 * https://docs.prebid.org/prebid-server/endpoints/openrtb2/pbs-endpoint-auction.html#eid-permissions
 *
 * If different bidders have different EID configurations, in most cases we can avoid repeating it in each bidder's
 * specific config. As long as there are no conflicts (different EID objects that refer to the same source constitute a conflict),
 * the EID can be set as global, and eidpermissions can restrict its access only to specific bidders.
 *
 * Returns {global, bidder, permissions}, where:
 *  - `global` is a list of global EID objects (some of which may be restricted through `permissions`
 *  - `bidder` is a map from bidder code to EID objects that are specific to that bidder, and cannot be restricted through `permissions`
 *  - `permissions` is a list of EID permissions as expected by PBS.
 */
function consolidateEids(_ref7) {
  let {
    eids,
    conflicts = new Set()
  } = _ref7;
  const globalEntries = [];
  const bidderEntries = [];
  const byBidder = {};
  eids.forEach(eid => {
    (eid.bidders === false ? globalEntries : bidderEntries).push(eid);
  });
  bidderEntries.forEach(_ref8 => {
    let {
      eid,
      bidders
    } = _ref8;
    if (!conflicts.has(eid.source)) {
      globalEntries.push({
        eid,
        bidders
      });
    } else {
      bidders.forEach(bidderCode => {
        (byBidder[bidderCode] = byBidder[bidderCode] || []).push(eid);
      });
    }
  });
  return {
    global: globalEntries.map(_ref9 => {
      let {
        eid
      } = _ref9;
      return eid;
    }),
    permissions: globalEntries.filter(_ref10 => {
      let {
        bidders
      } = _ref10;
      return bidders !== false;
    }).map(_ref11 => {
      let {
        eid,
        bidders
      } = _ref11;
      return {
        source: eid.source,
        bidders
      };
    }),
    bidder: byBidder
  };
}
function replaceEids(_ref12, requestedBidders) {
  let {
    global,
    bidder
  } = _ref12;
  const consolidated = consolidateEids(extractEids({
    global,
    bidder
  }));
  global = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepClone)(global);
  bidder = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepClone)(bidder);
  function removeEids(target) {
    delete target?.user?.eids;
    delete target?.user?.ext?.eids;
  }
  removeEids(global);
  Object.values(bidder).forEach(removeEids);
  if (consolidated.global.length) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.dset)(global, 'user.ext.eids', consolidated.global);
  }
  if (requestedBidders?.length) {
    consolidated.permissions.forEach(permission => permission.bidders = permission.bidders.filter(bidder => requestedBidders.includes(bidder)));
  }
  if (consolidated.permissions.length) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.dset)(global, 'ext.prebid.data.eidpermissions', consolidated.permissions);
  }
  Object.entries(consolidated.bidder).forEach(_ref13 => {
    let [bidderCode, bidderEids] = _ref13;
    if (bidderEids.length) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.dset)(bidder[bidderCode], 'user.ext.eids', bidderEids);
    }
  });
  return {
    global,
    bidder
  };
}
function premergeFpd(ortb2Fragments, requestedBidders) {
  if (ortb2Fragments == null || Object.keys(ortb2Fragments.bidder || {}).length === 0) {
    return ortb2Fragments;
  } else {
    ortb2Fragments = replaceEids(ortb2Fragments, requestedBidders);
    return {
      ...ortb2Fragments,
      bidder: getPBSBidderConfig(ortb2Fragments)
    };
  }
}

/***/ }),

/***/ "./modules/prebidServerBidAdapter/config.js":
/*!**************************************************!*\
  !*** ./modules/prebidServerBidAdapter/config.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S2S_VENDORS: () => (/* binding */ S2S_VENDORS)
/* harmony export */ });
// accountId and bidders params are not included here, should be configured by end-user
const S2S_VENDORS = {
  'appnexuspsp': {
    adapter: 'prebidServer',
    enabled: true,
    endpoint: {
      p1Consent: 'https://ib.adnxs.com/openrtb2/prebid',
      noP1Consent: 'https://ib.adnxs-simple.com/openrtb2/prebid'
    },
    syncEndpoint: {
      p1Consent: 'https://prebid.adnxs.com/pbs/v1/cookie_sync',
      noP1Consent: 'https://prebid.adnxs-simple.com/pbs/v1/cookie_sync'
    },
    maxTimeout: 1000
  },
  'rubicon': {
    adapter: 'prebidServer',
    enabled: true,
    endpoint: {
      p1Consent: 'https://prebid-server.rubiconproject.com/openrtb2/auction',
      noP1Consent: 'https://prebid-server.rubiconproject.com/openrtb2/auction'
    },
    syncEndpoint: {
      p1Consent: 'https://prebid-server.rubiconproject.com/cookie_sync',
      noP1Consent: 'https://prebid-server.rubiconproject.com/cookie_sync'
    },
    maxTimeout: 500
  },
  'openwrap': {
    adapter: 'prebidServer',
    enabled: true,
    endpoint: {
      p1Consent: 'https://ow.pubmatic.com/openrtb2/auction?source=pbjs',
      noP1Consent: 'https://ow.pubmatic.com/openrtb2/auction?source=pbjs'
    },
    maxTimeout: 500
  }
};

/***/ }),

/***/ "./modules/prebidServerBidAdapter/index.js":
/*!*************************************************!*\
  !*** ./modules/prebidServerBidAdapter/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   s2sDefaultConfig: () => (/* binding */ s2sDefaultConfig)
/* harmony export */ });
/* unused harmony exports validateConfig, resetSyncedStatus, PrebidServer, processPBSRequest */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_adapter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../src/adapter.js */ "./src/adapter.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/constants.js */ "./src/constants.js");
/* harmony import */ var _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../src/adapterManager.js */ "./src/adapterManager.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/config.js */ "./src/config.js");
/* harmony import */ var _src_adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../src/adapters/bidderFactory.js */ "./src/adapters/bidderFactory.js");
/* harmony import */ var _src_events_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../src/events.js */ "./src/events.js");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config.js */ "./modules/prebidServerBidAdapter/config.js");
/* harmony import */ var _src_ajax_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../src/ajax.js */ "./src/ajax.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_utils_gdpr_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../src/utils/gdpr.js */ "./src/utils/gdpr.js");
/* harmony import */ var _ortbConverter_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ortbConverter.js */ "./modules/prebidServerBidAdapter/ortbConverter.js");
/* harmony import */ var _src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../src/utils/perfMetrics.js */ "./src/utils/perfMetrics.js");
/* harmony import */ var _src_activities_rules_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../src/activities/rules.js */ "./src/activities/rules.js");
/* harmony import */ var _src_activities_activities_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../src/activities/activities.js */ "./src/activities/activities.js");
















const getConfig = _src_config_js__WEBPACK_IMPORTED_MODULE_0__.config.getConfig;
const TYPE = _src_constants_js__WEBPACK_IMPORTED_MODULE_1__.S2S.SRC;
let _syncCount = 0;
let _s2sConfigs;

/**
 * @typedef {Object} AdapterOptions
 * @summary s2sConfig parameter that adds arguments to resulting OpenRTB payload that goes to Prebid Server
 * @property {string} adapter
 * @property {boolean} enabled
 * @property {string} endpoint
 * @property {string} syncEndpoint
 * @property {number} timeout
 * @example
 * // example of multiple bidder configuration
 * pbjs.setConfig({
 *    s2sConfig: {
 *       adapterOptions: {
 *          rubicon: {singleRequest: false}
 *          appnexus: {key: "value"}
 *       }
 *    }
 * });
 */

/**
 * @typedef {Object} S2SDefaultConfig
 * @summary Base config properties for server to server header bidding
 * @property {string} [adapter='prebidServer'] adapter code to use for S2S
 * @property {boolean} [allowUnknownBidderCodes=false] allow bids from bidders that were not explicitly requested
 * @property {boolean} [enabled=false] enables S2S bidding
 * @property {number} [timeout=1000] timeout for S2S bidders - should be lower than `pbjs.requestBids({timeout})`
 * @property {number} [syncTimeout=1000] timeout for cookie sync iframe / image rendering
 * @property {number} [maxBids=1]
 * @property {AdapterOptions} [adapterOptions] adds arguments to resulting OpenRTB payload to Prebid Server
 * @property {Object} [syncUrlModifier]
 */

/**
 * @typedef {S2SDefaultConfig} S2SConfig
 * @summary Configuration for server to server header bidding
 * @property {string[]} bidders bidders to request S2S
 * @property {string} endpoint endpoint to contact
 * @property {string} [defaultVendor] used as key to select the bidder's default config from ßprebidServer/config.js
 * @property {boolean} [cacheMarkup] whether to cache the adm result
 * @property {string} [syncEndpoint] endpoint URL for syncing cookies
 * @property {Object} [extPrebid] properties will be merged into request.ext.prebid
 * @property {Object} [ortbNative] base value for imp.native.request
 * @property {Number} [maxTimeout]
 */

/**
 * @type {S2SDefaultConfig}
 */
const s2sDefaultConfig = {
  bidders: Object.freeze([]),
  syncTimeout: 1000,
  maxBids: 1,
  adapter: 'prebidServer',
  allowUnknownBidderCodes: false,
  adapterOptions: {},
  syncUrlModifier: {},
  ortbNative: {
    eventtrackers: [{
      event: 1,
      methods: [1, 2]
    }]
  },
  maxTimeout: 1500
};
_src_config_js__WEBPACK_IMPORTED_MODULE_0__.config.setDefaults({
  's2sConfig': s2sDefaultConfig
});

/**
 * @param {S2SConfig} s2sConfig
 * @return {boolean}
 */
function updateConfigDefaults(s2sConfig) {
  if (s2sConfig.defaultVendor) {
    let vendor = s2sConfig.defaultVendor;
    let optionKeys = Object.keys(s2sConfig);
    if (_config_js__WEBPACK_IMPORTED_MODULE_2__.S2S_VENDORS[vendor]) {
      // vendor keys will be set if either: the key was not specified by user
      // or if the user did not set their own distinct value (ie using the system default) to override the vendor
      Object.keys(_config_js__WEBPACK_IMPORTED_MODULE_2__.S2S_VENDORS[vendor]).forEach(vendorKey => {
        if (s2sDefaultConfig[vendorKey] === s2sConfig[vendorKey] || !optionKeys.includes(vendorKey)) {
          s2sConfig[vendorKey] = _config_js__WEBPACK_IMPORTED_MODULE_2__.S2S_VENDORS[vendor][vendorKey];
        }
      });
    } else {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)('Incorrect or unavailable prebid server default vendor option: ' + vendor);
      return false;
    }
  } else {
    if (s2sConfig.adapter == null) {
      s2sConfig.adapter = 'prebidServer';
    }
  }
  return true;
}

/**
 * @param {S2SConfig} s2sConfig
 * @return {boolean}
 */
function validateConfigRequiredProps(s2sConfig) {
  for (const key of ['accountId', 'endpoint']) {
    if (s2sConfig[key] == null) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(key + ' missing in server to server config');
      return false;
    }
  }
  return true;
}

// temporary change to modify the s2sConfig for new format used for endpoint URLs;
// could be removed later as part of a major release, if we decide to not support the old format
function formatUrlParams(option) {
  ['endpoint', 'syncEndpoint'].forEach(prop => {
    if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.isStr)(option[prop])) {
      let temp = option[prop];
      option[prop] = {
        p1Consent: temp,
        noP1Consent: temp
      };
    }
    if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(option[prop]) && (!option[prop].p1Consent || !option[prop].noP1Consent)) {
      ['p1Consent', 'noP1Consent'].forEach(conUrl => {
        if (!option[prop][conUrl]) {
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(`s2sConfig.${prop}.${conUrl} not defined.  PBS request will be skipped in some P1 scenarios.`);
        }
      });
    }
  });
}
function validateConfig(options) {
  if (!options) {
    return;
  }
  options = Array.isArray(options) ? options : [options];
  const activeBidders = new Set();
  return options.filter(s2sConfig => {
    formatUrlParams(s2sConfig);
    if (updateConfigDefaults(s2sConfig) && validateConfigRequiredProps(s2sConfig) && s2sConfig.enabled) {
      if (Array.isArray(s2sConfig.bidders)) {
        s2sConfig.bidders = s2sConfig.bidders.filter(bidder => {
          if (activeBidders.has(bidder)) {
            return false;
          } else {
            activeBidders.add(bidder);
            return true;
          }
        });
      }
      return true;
    } else {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)('prebidServer: s2s config is disabled', s2sConfig);
    }
  });
}

/**
 * @param {(S2SConfig[]|S2SConfig)} options
 */
function setS2sConfig(options) {
  options = validateConfig(options);
  if (options.length) {
    _s2sConfigs = options;
  }
}
getConfig('s2sConfig', _ref => {
  let {
    s2sConfig
  } = _ref;
  return setS2sConfig(s2sConfig);
});

/**
 * resets the _synced variable back to false, primiarily used for testing purposes
 */
function resetSyncedStatus() {
  _syncCount = 0;
}

/**
 * @param  {Array} bidderCodes list of bidders to request user syncs for.
 */
function queueSync(bidderCodes, gdprConsent, uspConsent, gppConsent, s2sConfig) {
  if (_s2sConfigs.length === _syncCount) {
    return;
  }
  _syncCount++;
  let filterSettings = {};
  const userSyncFilterSettings = getConfig('userSync.filterSettings');
  if (userSyncFilterSettings) {
    const {
      all,
      iframe,
      image
    } = userSyncFilterSettings;
    const ifrm = iframe || all;
    const img = image || all;
    if (ifrm) filterSettings = Object.assign({
      iframe: ifrm
    }, filterSettings);
    if (img) filterSettings = Object.assign({
      image: img
    }, filterSettings);
  }
  const payload = {
    uuid: (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.generateUUID)(),
    bidders: bidderCodes,
    account: s2sConfig.accountId,
    filterSettings
  };
  let userSyncLimit = s2sConfig.userSyncLimit;
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.isNumber)(userSyncLimit) && userSyncLimit > 0) {
    payload['limit'] = userSyncLimit;
  }
  if (gdprConsent) {
    payload.gdpr = gdprConsent.gdprApplies ? 1 : 0;
    // attempt to populate gdpr_consent if we know gdprApplies or it may apply
    if (gdprConsent.gdprApplies !== false) {
      payload.gdpr_consent = gdprConsent.consentString;
    }
  }

  // US Privacy (CCPA) support
  if (uspConsent) {
    payload.us_privacy = uspConsent;
  }
  if (gppConsent) {
    payload.gpp_sid = gppConsent.applicableSections.join();
    // should we add check if applicableSections was not equal to -1 (where user was out of scope)?
    //   this would be similar to what was done above for TCF
    payload.gpp = gppConsent.gppString;
  }
  if (typeof s2sConfig.coopSync === 'boolean') {
    payload.coopSync = s2sConfig.coopSync;
  }
  const jsonPayload = JSON.stringify(payload);
  (0,_src_ajax_js__WEBPACK_IMPORTED_MODULE_4__.ajax)(getMatchingConsentUrl(s2sConfig.syncEndpoint, gdprConsent), response => {
    try {
      response = JSON.parse(response);
      doAllSyncs(response.bidder_status, s2sConfig);
    } catch (e) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(e);
    }
  }, jsonPayload, {
    contentType: 'text/plain',
    withCredentials: true
  });
}
function doAllSyncs(bidders, s2sConfig) {
  if (bidders.length === 0) {
    return;
  }

  // pull the syncs off the list in the order that prebid server sends them
  const thisSync = bidders.shift();

  // if PBS reports this bidder doesn't have an ID, then call the sync and recurse to the next sync entry
  if (thisSync.no_cookie) {
    doPreBidderSync(thisSync.usersync.type, thisSync.usersync.url, thisSync.bidder, doAllSyncs.bind(null, bidders, s2sConfig), s2sConfig);
  } else {
    // bidder already has an ID, so just recurse to the next sync entry
    doAllSyncs(bidders, s2sConfig);
  }
}

/**
 * Modify the cookie sync url from prebid server to add new params.
 *
 * @param {string} type the type of sync, "image", "redirect", "iframe"
 * @param {string} url the url to sync
 * @param {string} bidder name of bidder doing sync for
 * @param {function} done an exit callback; to signify this pixel has either: finished rendering or something went wrong
 * @param {S2SConfig} s2sConfig
 */
function doPreBidderSync(type, url, bidder, done, s2sConfig) {
  if (s2sConfig.syncUrlModifier && typeof s2sConfig.syncUrlModifier[bidder] === 'function') {
    url = s2sConfig.syncUrlModifier[bidder](type, url, bidder);
  }
  doBidderSync(type, url, bidder, done, s2sConfig.syncTimeout);
}

/**
 * Run a cookie sync for the given type, url, and bidder
 *
 * @param {string} type the type of sync, "image", "redirect", "iframe"
 * @param {string} url the url to sync
 * @param {string} bidder name of bidder doing sync for
 * @param {function} done an exit callback; to signify this pixel has either: finished rendering or something went wrong
 * @param {number} timeout maximum time to wait for rendering in milliseconds
 */
function doBidderSync(type, url, bidder, done, timeout) {
  if (!url) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`No sync url for bidder "${bidder}": ${url}`);
    done();
  } else if (type === 'image' || type === 'redirect') {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logMessage)(`Invoking image pixel user sync for bidder: "${bidder}"`);
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.triggerPixel)(url, done, timeout);
  } else if (type === 'iframe') {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logMessage)(`Invoking iframe user sync for bidder: "${bidder}"`);
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.insertUserSyncIframe)(url, done, timeout);
  } else {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`User sync type "${type}" not supported for bidder: "${bidder}"`);
    done();
  }
}

/**
 * Do client-side syncs for bidders.
 *
 * @param {Array} bidders a list of bidder names
 */
function doClientSideSyncs(bidders, gdprConsent, uspConsent, gppConsent) {
  bidders.forEach(bidder => {
    let clientAdapter = _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_5__["default"].getBidAdapter(bidder);
    if (clientAdapter && clientAdapter.registerSyncs) {
      _src_config_js__WEBPACK_IMPORTED_MODULE_0__.config.runWithBidder(bidder, clientAdapter.registerSyncs.bind(clientAdapter, [], gdprConsent, uspConsent, gppConsent));
    }
  });
}
function getMatchingConsentUrl(urlProp, gdprConsent) {
  const hasPurpose = (0,_src_utils_gdpr_js__WEBPACK_IMPORTED_MODULE_6__.hasPurpose1Consent)(gdprConsent);
  const url = hasPurpose ? urlProp.p1Consent : urlProp.noP1Consent;
  if (!url) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)('Missing matching consent URL when gdpr=' + hasPurpose);
  }
  return url;
}
function getConsentData(bidRequests) {
  let gdprConsent, uspConsent, gppConsent;
  if (Array.isArray(bidRequests) && bidRequests.length > 0) {
    gdprConsent = bidRequests[0].gdprConsent;
    uspConsent = bidRequests[0].uspConsent;
    gppConsent = bidRequests[0].gppConsent;
  }
  return {
    gdprConsent,
    uspConsent,
    gppConsent
  };
}

/**
 * Bidder adapter for Prebid Server
 */
function PrebidServer() {
  const baseAdapter = new _src_adapter_js__WEBPACK_IMPORTED_MODULE_7__["default"]('prebidServer');

  /* Prebid executes this function when the page asks to send out bid requests */
  baseAdapter.callBids = function (s2sBidRequest, bidRequests, addBidResponse, done, ajax) {
    const adapterMetrics = s2sBidRequest.metrics = (0,_src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_8__.useMetrics)(bidRequests?.[0]?.metrics).newMetrics().renameWith(n => [`adapter.s2s.${n}`, `adapters.s2s.${s2sBidRequest.s2sConfig.defaultVendor}.${n}`]);
    done = adapterMetrics.startTiming('total').stopBefore(done);
    bidRequests.forEach(req => (0,_src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_8__.useMetrics)(req.metrics).join(adapterMetrics, {
      continuePropagation: false
    }));
    let {
      gdprConsent,
      uspConsent,
      gppConsent
    } = getConsentData(bidRequests);
    if (Array.isArray(_s2sConfigs)) {
      if (s2sBidRequest.s2sConfig && s2sBidRequest.s2sConfig.syncEndpoint && getMatchingConsentUrl(s2sBidRequest.s2sConfig.syncEndpoint, gdprConsent)) {
        const s2sAliases = (s2sBidRequest.s2sConfig.extPrebid && s2sBidRequest.s2sConfig.extPrebid.aliases) ?? {};
        let syncBidders = s2sBidRequest.s2sConfig.bidders.map(bidder => _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_5__["default"].aliasRegistry[bidder] || s2sAliases[bidder] || bidder).filter((bidder, index, array) => array.indexOf(bidder) === index);
        queueSync(syncBidders, gdprConsent, uspConsent, gppConsent, s2sBidRequest.s2sConfig);
      }
      processPBSRequest(s2sBidRequest, bidRequests, ajax, {
        onResponse: function (isValid, requestedBidders, response) {
          if (isValid) {
            bidRequests.forEach(bidderRequest => _src_events_js__WEBPACK_IMPORTED_MODULE_9__.emit(_src_constants_js__WEBPACK_IMPORTED_MODULE_1__.EVENTS.BIDDER_DONE, bidderRequest));
          }
          const {
            seatNonBidData,
            atagData
          } = getAnalyticsFlags(s2sBidRequest.s2sConfig, response);
          if (seatNonBidData) {
            _src_events_js__WEBPACK_IMPORTED_MODULE_9__.emit(_src_constants_js__WEBPACK_IMPORTED_MODULE_1__.EVENTS.SEAT_NON_BID, {
              seatnonbid: response.ext.seatnonbid,
              auctionId: bidRequests[0].auctionId,
              requestedBidders,
              response,
              adapterMetrics
            });
          }
          // pbs analytics event
          if (seatNonBidData || atagData) {
            const data = {
              seatnonbid: seatNonBidData,
              atag: atagData,
              auctionId: bidRequests[0].auctionId,
              requestedBidders,
              response,
              adapterMetrics
            };
            _src_events_js__WEBPACK_IMPORTED_MODULE_9__.emit(_src_constants_js__WEBPACK_IMPORTED_MODULE_1__.EVENTS.PBS_ANALYTICS, data);
          }
          done(false);
          doClientSideSyncs(requestedBidders, gdprConsent, uspConsent, gppConsent);
        },
        onError(msg, error) {
          const {
            p1Consent = '',
            noP1Consent = ''
          } = s2sBidRequest?.s2sConfig?.endpoint || {};
          if (p1Consent === noP1Consent) {
            (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`Prebid server call failed: '${msg}'. Endpoint: "${p1Consent}"}`, error);
          } else {
            (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`Prebid server call failed: '${msg}'. Endpoints: p1Consent "${p1Consent}", noP1Consent "${noP1Consent}"}`, error);
          }
          bidRequests.forEach(bidderRequest => _src_events_js__WEBPACK_IMPORTED_MODULE_9__.emit(_src_constants_js__WEBPACK_IMPORTED_MODULE_1__.EVENTS.BIDDER_ERROR, {
            error,
            bidderRequest
          }));
          done(error.timedOut);
        },
        onBid: function (_ref2) {
          let {
            adUnit,
            bid
          } = _ref2;
          const metrics = bid.metrics = s2sBidRequest.metrics.fork().renameWith();
          metrics.checkpoint('addBidResponse');
          if ((bid.requestId == null || bid.requestBidder == null) && !s2sBidRequest.s2sConfig.allowUnknownBidderCodes) {
            (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(`PBS adapter received bid from unknown bidder (${bid.bidder}), but 's2sConfig.allowUnknownBidderCodes' is not set. Ignoring bid.`);
            addBidResponse.reject(adUnit, bid, _src_constants_js__WEBPACK_IMPORTED_MODULE_1__.REJECTION_REASON.BIDDER_DISALLOWED);
          } else {
            if (metrics.measureTime('addBidResponse.validate', () => (0,_src_adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_10__.isValid)(adUnit, bid))) {
              addBidResponse(adUnit, bid);
            } else {
              addBidResponse.reject(adUnit, bid, _src_constants_js__WEBPACK_IMPORTED_MODULE_1__.REJECTION_REASON.INVALID);
            }
          }
        },
        onFledge: params => {
          _src_config_js__WEBPACK_IMPORTED_MODULE_0__.config.runWithBidder(params.bidder, () => {
            (0,_src_adapters_bidderFactory_js__WEBPACK_IMPORTED_MODULE_10__.addPaapiConfig)({
              auctionId: bidRequests[0].auctionId,
              ...params
            }, {
              config: params.config
            });
          });
        }
      });
    }
  };
  return Object.assign(this, {
    callBids: baseAdapter.callBids,
    setBidderCode: baseAdapter.setBidderCode,
    type: TYPE
  });
}

/**
 * Build and send the appropriate HTTP request over the network, then interpret the response.
 * @param s2sBidRequest
 * @param bidRequests
 * @param ajax
 * @param onResponse {function(boolean, Array[String])} invoked on a successful HTTP response - with a flag indicating whether it was successful,
 * and a list of the unique bidder codes that were sent in the request
 * @param onError {function(String, {})} invoked on HTTP failure - with status message and XHR error
 * @param onBid {function({})} invoked once for each bid in the response - with the bid as returned by interpretResponse
 */
const processPBSRequest = (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_11__.hook)('async', function (s2sBidRequest, bidRequests, ajax, _ref3) {
  let {
    onResponse,
    onError,
    onBid,
    onFledge
  } = _ref3;
  let {
    gdprConsent
  } = getConsentData(bidRequests);
  const adUnits = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.deepClone)(s2sBidRequest.ad_units);

  // in case config.bidders contains invalid bidders, we only process those we sent requests for
  const requestedBidders = adUnits.map(adUnit => adUnit.bids.map(bid => bid.bidder).filter(_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.uniques)).reduce(_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.flatten, []).filter(_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.uniques);
  const request = s2sBidRequest.metrics.measureTime('buildRequests', () => (0,_ortbConverter_js__WEBPACK_IMPORTED_MODULE_12__.buildPBSRequest)(s2sBidRequest, bidRequests, adUnits, requestedBidders));
  const requestData = {
    endpointUrl: getMatchingConsentUrl(s2sBidRequest.s2sConfig.endpoint, gdprConsent),
    requestJson: request && JSON.stringify(request),
    customHeaders: s2sBidRequest?.s2sConfig?.customHeaders ?? {}
  };
  _src_events_js__WEBPACK_IMPORTED_MODULE_9__.emit(_src_constants_js__WEBPACK_IMPORTED_MODULE_1__.EVENTS.BEFORE_PBS_HTTP, requestData);
  (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logInfo)('BidRequest: ' + requestData);
  if (request && requestData.requestJson && requestData.endpointUrl) {
    const networkDone = s2sBidRequest.metrics.startTiming('net');
    ajax(requestData.endpointUrl, {
      success: function (response) {
        networkDone();
        let result;
        try {
          result = JSON.parse(response);
          const {
            bids,
            paapi
          } = s2sBidRequest.metrics.measureTime('interpretResponse', () => (0,_ortbConverter_js__WEBPACK_IMPORTED_MODULE_12__.interpretPBSResponse)(result, request));
          bids.forEach(onBid);
          if (paapi) {
            paapi.forEach(onFledge);
          }
        } catch (error) {
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(error);
        }
        if (!result || result.status && result.status.includes('Error')) {
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)('error parsing response: ', result ? result.status : 'not valid JSON');
          onResponse(false, requestedBidders);
        } else {
          onResponse(true, requestedBidders, result);
        }
      },
      error: function () {
        networkDone();
        onError.apply(this, arguments);
      }
    }, requestData.requestJson, {
      contentType: 'text/plain',
      withCredentials: true,
      browsingTopics: (0,_src_activities_rules_js__WEBPACK_IMPORTED_MODULE_13__.isActivityAllowed)(_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_14__.ACTIVITY_TRANSMIT_UFPD, (0,_src_adapterManager_js__WEBPACK_IMPORTED_MODULE_5__.s2sActivityParams)(s2sBidRequest.s2sConfig)),
      customHeaders: requestData.customHeaders
    });
  } else {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)('PBS request not made.  Check endpoints.');
  }
}, 'processPBSRequest');
function getAnalyticsFlags(s2sConfig, response) {
  return {
    atagData: getAtagData(response),
    seatNonBidData: getNonBidData(s2sConfig, response)
  };
}
function getNonBidData(s2sConfig, response) {
  return s2sConfig?.extPrebid?.returnallbidstatus ? response?.ext?.seatnonbid : undefined;
}
function getAtagData(response) {
  return response?.ext?.prebid?.analytics?.tags;
}
_src_adapterManager_js__WEBPACK_IMPORTED_MODULE_5__["default"].registerBidAdapter(new PrebidServer(), 'prebidServer');
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_15__.registerModule)('prebidServerBidAdapter');

/***/ }),

/***/ "./modules/prebidServerBidAdapter/ortbConverter.js":
/*!*********************************************************!*\
  !*** ./modules/prebidServerBidAdapter/ortbConverter.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildPBSRequest: () => (/* binding */ buildPBSRequest),
/* harmony export */   interpretPBSResponse: () => (/* binding */ interpretPBSResponse)
/* harmony export */ });
/* harmony import */ var _libraries_ortbConverter_converter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../libraries/ortbConverter/converter.js */ "./libraries/ortbConverter/converter.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../src/utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../src/config.js */ "./src/config.js");
/* harmony import */ var _src_constants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../src/constants.js */ "./src/constants.js");
/* harmony import */ var _src_bidfactory_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../src/bidfactory.js */ "./src/bidfactory.js");
/* harmony import */ var _libraries_pbsExtensions_pbsExtensions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../libraries/pbsExtensions/pbsExtensions.js */ "./libraries/pbsExtensions/pbsExtensions.js");
/* harmony import */ var _libraries_pbsExtensions_processors_params_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../libraries/pbsExtensions/processors/params.js */ "./libraries/pbsExtensions/processors/params.js");
/* harmony import */ var _libraries_pbsExtensions_processors_mediaType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../libraries/pbsExtensions/processors/mediaType.js */ "./libraries/pbsExtensions/processors/mediaType.js");
/* harmony import */ var _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../src/pbjsORTB.js */ "./src/pbjsORTB.js");
/* harmony import */ var _src_activities_redactor_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../src/activities/redactor.js */ "./src/activities/redactor.js");
/* harmony import */ var _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../src/adapterManager.js */ "./src/adapterManager.js");
/* harmony import */ var _src_activities_activityParams_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../src/activities/activityParams.js */ "./src/activities/activityParams.js");
/* harmony import */ var _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../src/activities/modules.js */ "./src/activities/modules.js");
/* harmony import */ var _src_activities_rules_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../src/activities/rules.js */ "./src/activities/rules.js");
/* harmony import */ var _src_activities_activities_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../src/activities/activities.js */ "./src/activities/activities.js");
/* harmony import */ var _libraries_currencyUtils_currency_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../libraries/currencyUtils/currency.js */ "./libraries/currencyUtils/currency.js");
/* harmony import */ var _src_utils_reducers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/utils/reducers.js */ "./src/utils/reducers.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./modules/prebidServerBidAdapter/index.js");
/* harmony import */ var _bidderConfig_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./bidderConfig.js */ "./modules/prebidServerBidAdapter/bidderConfig.js");
/* harmony import */ var _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../src/mediaTypes.js */ "./src/mediaTypes.js");




















const DEFAULT_S2S_TTL = 60;
const DEFAULT_S2S_CURRENCY = 'USD';
const DEFAULT_S2S_NETREVENUE = true;
const BIDDER_SPECIFIC_REQUEST_PROPS = new Set(['bidderCode', 'bidderRequestId', 'uniquePbsTid', 'bids', 'timeout']);
const getMinimumFloor = (() => {
  const getMin = (0,_src_utils_reducers_js__WEBPACK_IMPORTED_MODULE_1__.minimum)((0,_libraries_currencyUtils_currency_js__WEBPACK_IMPORTED_MODULE_2__.currencyCompare)(floor => [floor.bidfloor, floor.bidfloorcur]));
  return function (candidates) {
    let min;
    for (const candidate of candidates) {
      if (candidate?.bidfloorcur == null || candidate?.bidfloor == null) return null;
      min = min == null ? candidate : getMin(min, candidate);
    }
    return min;
  };
})();
const PBS_CONVERTER = (0,_libraries_ortbConverter_converter_js__WEBPACK_IMPORTED_MODULE_3__.ortbConverter)({
  processors: _libraries_pbsExtensions_pbsExtensions_js__WEBPACK_IMPORTED_MODULE_4__.pbsExtensions,
  context: {
    netRevenue: DEFAULT_S2S_NETREVENUE
  },
  imp(buildImp, proxyBidRequest, context) {
    Object.assign(context, proxyBidRequest.pbsData);
    const imp = buildImp(proxyBidRequest, context);
    (proxyBidRequest.bids || []).forEach(bid => {
      if (bid.ortb2Imp && Object.keys(bid.ortb2Imp).length > 0) {
        // set bidder-level imp attributes; see https://github.com/prebid/prebid-server/issues/2335
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.dset)(imp, `ext.prebid.imp.${bid.bidder}`, bid.ortb2Imp);
      }
    });
    if (Object.values(_libraries_pbsExtensions_processors_mediaType_js__WEBPACK_IMPORTED_MODULE_6__.SUPPORTED_MEDIA_TYPES).some(mtype => imp[mtype])) {
      imp.secure = proxyBidRequest.ortb2Imp?.secure ?? 1;
      return imp;
    }
  },
  request(buildRequest, imps, proxyBidderRequest, context) {
    if (!imps.length) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__.logError)('Request to Prebid Server rejected due to invalid media type(s) in adUnit.');
    } else {
      let {
        s2sBidRequest
      } = context;
      const request = buildRequest(imps, proxyBidderRequest, context);
      request.tmax = Math.floor(s2sBidRequest.s2sConfig.timeout ?? Math.min(s2sBidRequest.requestBidsTimeout * 0.75, s2sBidRequest.s2sConfig.maxTimeout ?? _index_js__WEBPACK_IMPORTED_MODULE_0__.s2sDefaultConfig.maxTimeout));
      request.ext.tmaxmax = request.ext.tmaxmax || s2sBidRequest.requestBidsTimeout;
      [request.app, request.dooh, request.site].forEach(section => {
        if (section && !section.publisher?.id) {
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.dset)(section, 'publisher.id', s2sBidRequest.s2sConfig.accountId);
        }
      });
      if (!context.transmitTids) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.dset)(request, 'ext.prebid.createtids', false);
      }
      return request;
    }
  },
  bidResponse(buildBidResponse, bid, context) {
    // before sending the response throgh "stock" ortb conversion, here we need to:
    // - filter out ones that come from an "unknown" bidder (if allowUnknownBidderCode is not set)
    // - overwrite context.bidRequest with the actual bid request for this seat / imp combination

    let bidRequest = context.actualBidRequests.get(context.seatbid.seat);
    if (bidRequest == null) {
      // for stored impressions, a request was made with bidder code `null`. Pick it up here so that NO_BID, BID_WON, etc events
      // can work as expected (otherwise, the original request will always result in NO_BID).
      bidRequest = context.actualBidRequests.get(null);
    }
    if (bidRequest) {
      Object.assign(context, {
        bidRequest,
        bidderRequest: context.actualBidderRequests.find(req => req.bidderCode === bidRequest.bidder)
      });
    }
    const bidResponse = buildBidResponse(bid, context);
    bidResponse.requestBidder = bidRequest?.bidder;
    if (bidResponse.native?.ortb) {
      // TODO: do we need to set bidResponse.adm here?
      // Any consumers can now get the same object from bidResponse.native.ortb;
      // I could not find any, which raises the question - who is looking for this?
      bidResponse.adm = bidResponse.native.ortb;
    }

    // because core has special treatment for PBS adapter responses, we need some additional processing
    bidResponse.requestTimestamp = context.requestTimestamp;
    return {
      bid: Object.assign((0,_src_bidfactory_js__WEBPACK_IMPORTED_MODULE_8__.createBid)(_src_constants_js__WEBPACK_IMPORTED_MODULE_9__.STATUS.GOOD, {
        src: _src_constants_js__WEBPACK_IMPORTED_MODULE_9__.S2S.SRC,
        bidId: bidRequest ? bidRequest.bidId || bidRequest.bid_Id : null,
        transactionId: context.adUnit.transactionId,
        adUnitId: context.adUnit.adUnitId,
        auctionId: context.bidderRequest.auctionId
      }), bidResponse, {
        deferRendering: !!context.adUnit.deferBilling,
        deferBilling: !!context.adUnit.deferBilling
      }),
      adUnit: context.adUnit.code
    };
  },
  overrides: {
    [_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_10__.IMP]: {
      id(orig, imp, proxyBidRequest, context) {
        imp.id = context.impId;
      },
      params(orig, imp, proxyBidRequest, context) {
        // override params processing to do it for each bidRequest in this imp;
        // also, take overrides from s2sConfig.adapterOptions
        const adapterOptions = context.s2sBidRequest.s2sConfig.adapterOptions;
        for (const req of context.actualBidRequests.values()) {
          (0,_libraries_pbsExtensions_processors_params_js__WEBPACK_IMPORTED_MODULE_11__.setImpBidParams)(imp, req, context, context);
          if (adapterOptions && adapterOptions[req.bidder]) {
            Object.assign(imp.ext.prebid.bidder[req.bidder], adapterOptions[req.bidder]);
          }
        }
      },
      // for bid floors, we pass each bidRequest associated with this imp through normal bidfloor/extBidfloor processing,
      // and aggregate all of them into a single, minimum floor to put in the request
      bidfloor(orig, imp, proxyBidRequest, context) {
        const min = getMinimumFloor(function* () {
          for (const req of context.actualBidRequests.values()) {
            const floor = {};
            orig(floor, req, context);
            yield floor;
          }
        }());
        if (min != null) {
          Object.assign(imp, min);
        }
      },
      extBidfloor(orig, imp, proxyBidRequest, context) {
        function setExtFloor(target, minFloor) {
          if (minFloor != null) {
            (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.dset)(target, 'ext.bidfloor', minFloor.bidfloor);
            (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.dset)(target, 'ext.bidfloorcur', minFloor.bidfloorcur);
          }
        }
        const imps = Array.from(context.actualBidRequests.values()).map(request => {
          const requestImp = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__.deepClone)(imp);
          orig(requestImp, request, context);
          return requestImp;
        });
        Object.values(_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_12__.ALL_MEDIATYPES).forEach(mediaType => {
          setExtFloor(imp[mediaType], getMinimumFloor(imps.map(imp => imp[mediaType]?.ext)));
        });
        (imp[_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_12__.BANNER]?.format || []).forEach((format, i) => {
          setExtFloor(format, getMinimumFloor(imps.map(imp => imp[_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_12__.BANNER].format[i]?.ext)));
        });
      }
    },
    [_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_10__.REQUEST]: {
      fpd(orig, ortbRequest, proxyBidderRequest, context) {
        // FPD is handled different for PBS - the base request will only contain global FPD;
        // bidder-specific values are set in ext.prebid.bidderconfig

        if (context.transmitTids) {
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.dset)(ortbRequest, 'source.tid', proxyBidderRequest.auctionId);
        }
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__.mergeDeep)(ortbRequest, context.s2sBidRequest.ortb2Fragments?.global);

        // also merge in s2sConfig.extPrebid
        if (context.s2sBidRequest.s2sConfig.extPrebid && typeof context.s2sBidRequest.s2sConfig.extPrebid === 'object') {
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.dset)(ortbRequest, 'ext.prebid', (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__.mergeDeep)(ortbRequest.ext?.prebid || {}, context.s2sBidRequest.s2sConfig.extPrebid));
        }

        // for global FPD, check allowed activities against "prebid.pbsBidAdapter"...
        context.getRedactor().ortb2(ortbRequest);
        const fpdConfigs = Object.entries(context.s2sBidRequest.ortb2Fragments?.bidder || {}).filter(_ref => {
          let [bidder] = _ref;
          const bidders = context.s2sBidRequest.s2sConfig.bidders;
          const allowUnknownBidderCodes = context.s2sBidRequest.s2sConfig.allowUnknownBidderCodes;
          return allowUnknownBidderCodes || bidders && bidders.includes(bidder);
        }).map(_ref2 => {
          let [bidder, ortb2] = _ref2;
          return {
            // ... but for bidder specific FPD we can use the actual bidder
            bidders: [bidder],
            config: {
              ortb2: context.getRedactor(bidder).ortb2(ortb2)
            }
          };
        });
        if (fpdConfigs.length) {
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.dset)(ortbRequest, 'ext.prebid.bidderconfig', fpdConfigs);
        }
      },
      extPrebidAliases(orig, ortbRequest, proxyBidderRequest, context) {
        // override alias processing to do it for each bidder in the request
        context.actualBidderRequests.forEach(req => orig(ortbRequest, req, context));
      },
      sourceExtSchain(orig, ortbRequest, proxyBidderRequest, context) {
        // pass schains in ext.prebid.schains
        let chains = ortbRequest?.ext?.prebid?.schains || [];
        const chainBidders = new Set(chains.flatMap(item => item.bidders));
        chains = Object.values(chains.concat(context.actualBidderRequests.filter(req => !chainBidders.has(req.bidderCode)) // schain defined in s2sConfig.extPrebid takes precedence
        .map(req => ({
          bidders: [req.bidderCode],
          schain: req?.bids?.[0]?.schain
        }))).filter(_ref3 => {
          let {
            bidders,
            schain
          } = _ref3;
          return bidders?.length > 0 && schain;
        }).reduce((chains, _ref4) => {
          let {
            bidders,
            schain
          } = _ref4;
          const key = JSON.stringify(schain);
          if (!chains.hasOwnProperty(key)) {
            chains[key] = {
              bidders: new Set(),
              schain
            };
          }
          bidders.forEach(bidder => chains[key].bidders.add(bidder));
          return chains;
        }, {})).map(_ref5 => {
          let {
            bidders,
            schain
          } = _ref5;
          return {
            bidders: Array.from(bidders),
            schain
          };
        });
        if (chains.length) {
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__.dset)(ortbRequest, 'ext.prebid.schains', chains);
        }
      }
    },
    [_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_10__.RESPONSE]: {
      serverSideStats(orig, response, ortbResponse, context) {
        // override to process each request
        context.actualBidderRequests.forEach(req => orig(response, ortbResponse, {
          ...context,
          bidderRequest: req,
          bidRequests: req.bids
        }));
      },
      paapiConfigs(orig, response, ortbResponse, context) {
        const configs = Object.values(context.impContext).flatMap(impCtx => (impCtx.paapiConfigs || []).map(cfg => {
          const bidderReq = impCtx.actualBidderRequests.find(br => br.bidderCode === cfg.bidder);
          const bidReq = impCtx.actualBidRequests.get(cfg.bidder);
          return {
            adUnitCode: impCtx.adUnit.code,
            ortb2: bidderReq?.ortb2,
            ortb2Imp: bidReq?.ortb2Imp,
            bidder: cfg.bidder,
            config: cfg.config
          };
        }));
        if (configs.length > 0) {
          response.paapi = configs;
        }
      }
    }
  }
});
function buildPBSRequest(s2sBidRequest, bidderRequests, adUnits, requestedBidders) {
  const requestTimestamp = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__.timestamp)();
  const impIds = new Set();
  const proxyBidRequests = [];
  const s2sParams = (0,_src_adapterManager_js__WEBPACK_IMPORTED_MODULE_13__.s2sActivityParams)(s2sBidRequest.s2sConfig);
  const getRedactor = (() => {
    const global = (0,_src_activities_redactor_js__WEBPACK_IMPORTED_MODULE_14__.redactor)(s2sParams);
    const bidders = {};
    return bidder => {
      if (bidder == null) return global;
      if (!bidders.hasOwnProperty(bidder)) {
        bidders[bidder] = (0,_src_activities_redactor_js__WEBPACK_IMPORTED_MODULE_14__.redactor)((0,_src_activities_activityParams_js__WEBPACK_IMPORTED_MODULE_15__.activityParams)(_src_activities_modules_js__WEBPACK_IMPORTED_MODULE_16__.MODULE_TYPE_BIDDER, bidder));
      }
      return bidders[bidder];
    };
  })();
  adUnits = adUnits.map(au => getRedactor().bidRequest(au));
  adUnits.forEach(adUnit => {
    const actualBidRequests = new Map();
    adUnits.bids = adUnit.bids.map(br => getRedactor(br.bidder).bidRequest(br));
    adUnit.bids.forEach(bid => {
      if (bid.mediaTypes != null) {
        // TODO: support labels / conditional bids
        // for now, just warn about them
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__.logWarn)(`Prebid Server adapter does not (yet) support bidder-specific mediaTypes for the same adUnit. Size mapping configuration will be ignored for adUnit: ${adUnit.code}, bidder: ${bid.bidder}`);
      }
      actualBidRequests.set(bid.bidder, (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__.getBidRequest)(bid.bid_id, bidderRequests));
    });
    let impId = adUnit.code;
    let i = 1;
    while (impIds.has(impId)) {
      i++;
      impId = `${adUnit.code}-${i}`;
    }
    impIds.add(impId);
    proxyBidRequests.push({
      ...adUnit,
      adUnitCode: adUnit.code,
      pbsData: {
        impId,
        actualBidRequests,
        adUnit
      }
    });
  });
  const proxyBidderRequest = {
    ...Object.fromEntries(Object.entries(bidderRequests[0]).filter(_ref6 => {
      let [k] = _ref6;
      return !BIDDER_SPECIFIC_REQUEST_PROPS.has(k);
    })),
    paapi: {
      enabled: bidderRequests.some(br => br.paapi?.enabled)
    }
  };
  return PBS_CONVERTER.toORTB({
    bidderRequest: proxyBidderRequest,
    bidRequests: proxyBidRequests,
    context: {
      currency: _src_config_js__WEBPACK_IMPORTED_MODULE_17__.config.getConfig('currency.adServerCurrency') || DEFAULT_S2S_CURRENCY,
      ttl: s2sBidRequest.s2sConfig.defaultTtl || DEFAULT_S2S_TTL,
      requestTimestamp,
      s2sBidRequest: {
        ...s2sBidRequest,
        ortb2Fragments: (0,_bidderConfig_js__WEBPACK_IMPORTED_MODULE_18__.premergeFpd)(s2sBidRequest.ortb2Fragments, requestedBidders)
      },
      requestedBidders,
      actualBidderRequests: bidderRequests,
      nativeRequest: s2sBidRequest.s2sConfig.ortbNative,
      getRedactor,
      transmitTids: (0,_src_activities_rules_js__WEBPACK_IMPORTED_MODULE_19__.isActivityAllowed)(_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_20__.ACTIVITY_TRANSMIT_TID, s2sParams)
    }
  });
}
function interpretPBSResponse(response, request) {
  return PBS_CONVERTER.fromORTB({
    response,
    request
  });
}

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","ortbConverter","currencyUtils","pbsExtensions","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/prebidServerBidAdapter/index.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["priceFloors"],{

/***/ "./modules/priceFloors.js":
/*!********************************!*\
  !*** ./modules/priceFloors.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports FLOOR_SKIPPED_REASON, allowedFields, _floorDataForAuction, fieldMatchingFunctions, getFirstMatchingFloor, getBiddersCpmAdjustment, calculateAdjustedFloor, getFloor, getFloorsDataForAuction, getFloorDataFromAdUnits, updateAdUnitsForAuction, pickRandomModel, createFloorsDataForAuction, continueAuction, normalizeDefault, isFloorsDataValid, parseFloorData, requestBidsHook, handleFetchResponse, generateAndHandleFetch, handleSetFloorsConfig, addBidResponseHook, setOrtbImpBidFloor, setGranularBidfloors, setImpExtPrebidFloors, setOrtbExtPrebidFloors */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_ajax_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/ajax.js */ "./src/ajax.js");
/* harmony import */ var _src_events_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../src/events.js */ "./src/events.js");
/* harmony import */ var _src_constants_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../src/constants.js */ "./src/constants.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_refererDetection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/refererDetection.js */ "./src/refererDetection.js");
/* harmony import */ var _src_bidderSettings_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/bidderSettings.js */ "./src/bidderSettings.js");
/* harmony import */ var _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/auctionManager.js */ "./src/auctionManager.js");
/* harmony import */ var _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../src/pbjsORTB.js */ "./src/pbjsORTB.js");
/* harmony import */ var _src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/utils/perfMetrics.js */ "./src/utils/perfMetrics.js");
/* harmony import */ var _src_utils_cpm_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/utils/cpm.js */ "./src/utils/cpm.js");
/* harmony import */ var _libraries_gptUtils_gptUtils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../libraries/gptUtils/gptUtils.js */ "./libraries/gptUtils/gptUtils.js");
/* harmony import */ var _libraries_currencyUtils_currency_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../libraries/currencyUtils/currency.js */ "./libraries/currencyUtils/currency.js");
/* harmony import */ var _libraries_timeoutQueue_timeoutQueue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libraries/timeoutQueue/timeoutQueue.js */ "./libraries/timeoutQueue/timeoutQueue.js");
/* harmony import */ var _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../src/mediaTypes.js */ "./src/mediaTypes.js");


















const FLOOR_SKIPPED_REASON = {
  NOT_FOUND: 'not_found',
  RANDOM: 'random'
};

/**
 * @summary This Module is intended to provide users with the ability to dynamically set and enforce price floors on a per auction basis.
 */
const MODULE_NAME = 'Price Floors';

/**
 * @summary Instantiate Ajax so we control the timeout
 */
const ajax = (0,_src_ajax_js__WEBPACK_IMPORTED_MODULE_0__.ajaxBuilder)(10000);

// eslint-disable-next-line symbol-description
const SYN_FIELD = Symbol();

/**
 * @summary Allowed fields for rules to have
 */
let allowedFields = [SYN_FIELD, 'gptSlot', 'adUnitCode', 'size', 'domain', 'mediaType'];

/**
 * @summary This is a flag to indicate if a AJAX call is processing for a floors request
 */
let fetching = false;

/**
 * @summary so we only register for our hooks once
 */
let addedFloorsHook = false;

/**
 * @summary The config to be used. Can be updated via: setConfig or a real time fetch
 */
let _floorsConfig = {};

/**
 * @summary If a auction is to be delayed by an ongoing fetch we hold it here until it can be resumed
 */
const _delayedAuctions = (0,_libraries_timeoutQueue_timeoutQueue_js__WEBPACK_IMPORTED_MODULE_1__.timeoutQueue)();

/**
 * @summary Each auction can have differing floors data depending on execution time or per adunit setup
 * So we will be saving each auction offset by it's auctionId in order to make sure data is not changed
 * Once the auction commences
 */
let _floorDataForAuction = {};

/**
 * @summary Simple function to round up to a certain decimal degree
 */
function roundUp(number, precision) {
  return Math.ceil((parseFloat(number) * Math.pow(10, precision)).toFixed(1)) / Math.pow(10, precision);
}
const getHostname = (() => {
  let domain;
  return function () {
    if (domain == null) {
      domain = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.parseUrl)((0,_src_refererDetection_js__WEBPACK_IMPORTED_MODULE_3__.getRefererInfo)().topmostLocation, {
        noDecodeWholeURL: true
      }).hostname;
    }
    return domain;
  };
})();

// First look into bidRequest!
function getGptSlotFromAdUnit(adUnitId) {
  let {
    index = _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_4__.auctionManager.index
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const adUnit = index.getAdUnit({
    adUnitId
  });
  const isGam = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(adUnit, 'ortb2Imp.ext.data.adserver.name') === 'gam';
  return isGam && adUnit.ortb2Imp.ext.data.adserver.adslot;
}
function getAdUnitCode(request, response) {
  let {
    index = _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_4__.auctionManager.index
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return request?.adUnitCode || index.getAdUnit(response).code;
}

/**
 * @summary floor field types with their matching functions to resolve the actual matched value
 */
let fieldMatchingFunctions = {
  [SYN_FIELD]: () => '*',
  'size': (bidRequest, bidResponse) => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.parseGPTSingleSizeArray)(bidResponse.size) || '*',
  'mediaType': (bidRequest, bidResponse) => bidResponse.mediaType || 'banner',
  'gptSlot': (bidRequest, bidResponse) => getGptSlotFromAdUnit((bidRequest || bidResponse).adUnitId) || (0,_libraries_gptUtils_gptUtils_js__WEBPACK_IMPORTED_MODULE_6__.getGptSlotInfoForAdUnitCode)(getAdUnitCode(bidRequest, bidResponse)).gptSlot,
  'domain': getHostname,
  'adUnitCode': (bidRequest, bidResponse) => getAdUnitCode(bidRequest, bidResponse)
};

/**
 * @summary Based on the fields array in floors data, it enumerates all possible matches based on exact match coupled with
 * a "*" catch-all match
 * Returns array of Tuple [exact match, catch all] for each field in rules file
 */
function enumeratePossibleFieldValues(floorFields, bidObject, responseObject) {
  if (!floorFields.length) return [];
  // generate combination of all exact matches and catch all for each field type
  return floorFields.reduce((accum, field) => {
    let exactMatch = fieldMatchingFunctions[field](bidObject, responseObject) || '*';
    // storing exact matches as lowerCase since we want to compare case insensitively
    accum.push(exactMatch === '*' ? ['*'] : [exactMatch.toLowerCase(), '*']);
    return accum;
  }, []);
}

/**
 * @summary get's the first matching floor based on context provided.
 * Generates all possible rule matches and picks the first matching one.
 */
function getFirstMatchingFloor(floorData, bidObject) {
  let responseObject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let fieldValues = enumeratePossibleFieldValues((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(floorData, 'schema.fields') || [], bidObject, responseObject);
  if (!fieldValues.length) {
    return {
      matchingFloor: undefined
    };
  }

  // look to see if a request for this context was made already
  let matchingInput = fieldValues.map(field => field[0]).join('-');
  // if we already have gotten the matching rule from this matching input then use it! No need to look again
  let previousMatch = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(floorData, `matchingInputs.${matchingInput}`);
  if (previousMatch) {
    return {
      ...previousMatch
    };
  }
  let allPossibleMatches = generatePossibleEnumerations(fieldValues, (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(floorData, 'schema.delimiter') || '|');
  let matchingRule = (allPossibleMatches || []).find(hashValue => floorData.values.hasOwnProperty(hashValue));
  let matchingData = {
    floorMin: floorData.floorMin || 0,
    floorRuleValue: floorData.values[matchingRule],
    matchingData: allPossibleMatches[0],
    // the first possible match is an "exact" so contains all data relevant for anlaytics adapters
    matchingRule: matchingRule === floorData.meta?.defaultRule ? undefined : matchingRule
  };
  // use adUnit floorMin as priority!
  const floorMin = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(bidObject, 'ortb2Imp.ext.prebid.floors.floorMin');
  if (typeof floorMin === 'number') {
    matchingData.floorMin = floorMin;
  }
  matchingData.matchingFloor = Math.max(matchingData.floorMin, matchingData.floorRuleValue);
  // save for later lookup if needed
  (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__.dset)(floorData, `matchingInputs.${matchingInput}`, {
    ...matchingData
  });
  return matchingData;
}

/**
 * @summary Generates all possible rule hash's based on input array of array's
 * The generated list is of all possible key matches based on fields input
 * The list is sorted by least amount of * in rule to most with left most fields taking precedence
 */
function generatePossibleEnumerations(arrayOfFields, delimiter) {
  return arrayOfFields.reduce((accum, currentVal) => {
    let ret = [];
    accum.map(obj => {
      currentVal.map(obj1 => {
        ret.push(obj + delimiter + obj1);
      });
    });
    return ret;
  }).sort((left, right) => left.split('*').length - right.split('*').length);
}

/**
 * @summary If a the input bidder has a registered cpmadjustment it returns the input CPM after being adjusted
 */
function getBiddersCpmAdjustment(inputCpm, bid, bidRequest) {
  return parseFloat((0,_src_utils_cpm_js__WEBPACK_IMPORTED_MODULE_8__.adjustCpm)(inputCpm, {
    ...bid,
    cpm: inputCpm
  }, bidRequest));
}

/**
 * @summary This function takes the original floor and the adjusted floor in order to determine the bidders actual floor
 * With js rounding errors with decimal division we utilize similar method as shown in cpmBucketManager.js
 */
function calculateAdjustedFloor(oldFloor, newFloor) {
  const pow = Math.pow(10, 10);
  return oldFloor * pow / (newFloor * pow) * (oldFloor * pow) / pow;
}

/**
 * @summary gets the prebid set sizes depending on the input mediaType
 */
const getMediaTypesSizes = {
  banner: bid => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(bid, 'mediaTypes.banner.sizes') || [],
  video: bid => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(bid, 'mediaTypes.video.playerSize') || [],
  native: bid => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(bid, 'mediaTypes.native.image.sizes') ? [(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(bid, 'mediaTypes.native.image.sizes')] : []
};

/**
 * @summary for getFloor only, before selecting a rule, if a bidAdapter asks for * in their getFloor params
 * Then we may be able to get a better rule than the * ones depending on context of the adUnit
 */
function updateRequestParamsFromContext(bidRequest, requestParams) {
  // if adapter asks for *'s then we can do some logic to infer if we can get a more specific rule based on context of bid
  let mediaTypesOnBid = Object.keys(bidRequest.mediaTypes || {});
  // if there is only one mediaType then we can just use it
  if (requestParams.mediaType === '*' && mediaTypesOnBid.length === 1) {
    requestParams.mediaType = mediaTypesOnBid[0];
  }
  // if they asked for * size, but for the given mediaType there is only one size, we can just use it
  if (requestParams.size === '*' && mediaTypesOnBid.indexOf(requestParams.mediaType) !== -1 && getMediaTypesSizes[requestParams.mediaType] && getMediaTypesSizes[requestParams.mediaType](bidRequest).length === 1) {
    requestParams.size = getMediaTypesSizes[requestParams.mediaType](bidRequest)[0];
  }
  return requestParams;
}

/**
 * @summary This is the function which will return a single floor based on the input requests
 * and matching it to a rule for the current auction
 */
function getFloor() {
  let requestParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    currency: 'USD',
    mediaType: '*',
    size: '*'
  };
  let bidRequest = this;
  let floorData = _floorDataForAuction[bidRequest.auctionId];
  if (!floorData || floorData.skipped) return {};
  requestParams = updateRequestParamsFromContext(bidRequest, requestParams);
  let floorInfo = getFirstMatchingFloor(floorData.data, {
    ...bidRequest
  }, {
    mediaType: requestParams.mediaType,
    size: requestParams.size
  });
  let currency = requestParams.currency || floorData.data.currency;

  // if bidder asked for a currency which is not what floors are set in convert
  if (floorInfo.matchingFloor && currency !== floorData.data.currency) {
    try {
      floorInfo.matchingFloor = (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_9__.getGlobal)().convertCurrency(floorInfo.matchingFloor, floorData.data.currency, currency);
    } catch (err) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)(`${MODULE_NAME}: Unable to get currency conversion for getFloor for bidder ${bidRequest.bidder}. You must have currency module enabled with defaultRates in your currency config`);
      // since we were unable to convert to the bidders requested currency, we send back just the actual floors currency to them
      currency = floorData.data.currency;
    }
  }

  // if cpmAdjustment flag is true and we have a valid floor then run the adjustment on it
  if (floorData.enforcement.bidAdjustment && floorInfo.matchingFloor) {
    // pub provided inverse function takes precedence, otherwise do old adjustment stuff
    const inverseFunction = _src_bidderSettings_js__WEBPACK_IMPORTED_MODULE_10__.bidderSettings.get(bidRequest.bidder, 'inverseBidAdjustment');
    if (inverseFunction) {
      const definedParams = Object.fromEntries(Object.entries(requestParams).filter(_ref => {
        let [key, val] = _ref;
        return val !== '*' && ['mediaType', 'size'].includes(key);
      }));
      floorInfo.matchingFloor = inverseFunction(floorInfo.matchingFloor, bidRequest, definedParams);
    } else {
      let cpmAdjustment = getBiddersCpmAdjustment(floorInfo.matchingFloor, null, bidRequest);
      floorInfo.matchingFloor = cpmAdjustment ? calculateAdjustedFloor(floorInfo.matchingFloor, cpmAdjustment) : floorInfo.matchingFloor;
    }
  }
  if (floorInfo.floorRuleValue === null) {
    return null;
  }
  if (floorInfo.matchingFloor) {
    return {
      floor: roundUp(floorInfo.matchingFloor, 4),
      currency
    };
  }
  return {};
}

/**
 * @summary Takes a floorsData object and converts it into a hash map with appropriate keys
 */
function getFloorsDataForAuction(floorData, adUnitCode) {
  let auctionFloorData = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.deepClone)(floorData);
  auctionFloorData.schema.delimiter = floorData.schema.delimiter || '|';
  auctionFloorData.values = normalizeRulesForAuction(auctionFloorData, adUnitCode);
  // default the currency to USD if not passed in
  auctionFloorData.currency = auctionFloorData.currency || 'USD';
  return auctionFloorData;
}

/**
 * @summary if adUnitCode needs to be added to the offset then it will add it else just return the values
 */
function normalizeRulesForAuction(floorData, adUnitCode) {
  let fields = floorData.schema.fields;
  let delimiter = floorData.schema.delimiter;

  // if we are building the floor data form an ad unit, we need to append adUnit code as to not cause collisions
  let prependAdUnitCode = adUnitCode && fields.indexOf('adUnitCode') === -1 && fields.unshift('adUnitCode');
  return Object.keys(floorData.values).reduce((rulesHash, oldKey) => {
    let newKey = prependAdUnitCode ? `${adUnitCode}${delimiter}${oldKey}` : oldKey;
    // we store the rule keys as lower case for case insensitive compare
    rulesHash[newKey.toLowerCase()] = floorData.values[oldKey];
    return rulesHash;
  }, {});
}

/**
 * @summary This function will take the adUnits and generate a floor data object to be used during the auction
 * Only called if no set config or fetch level data has returned
 */
function getFloorDataFromAdUnits(adUnits) {
  const schemaAu = adUnits.find(au => au.floors?.schema != null);
  return adUnits.reduce((accum, adUnit) => {
    if (adUnit.floors?.schema != null && !(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(adUnit.floors.schema, schemaAu?.floors?.schema)) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)(`${MODULE_NAME}: adUnit '${adUnit.code}' declares a different schema from one previously declared by adUnit '${schemaAu.code}'. Floor config for '${adUnit.code}' will be ignored.`);
      return accum;
    }
    const floors = Object.assign({}, schemaAu?.floors, {
      values: undefined
    }, adUnit.floors);
    if (isFloorsDataValid(floors)) {
      // if values already exist we want to not overwrite them
      if (!accum.values) {
        accum = getFloorsDataForAuction(floors, adUnit.code);
        accum.location = 'adUnit';
      } else {
        let newRules = getFloorsDataForAuction(floors, adUnit.code).values;
        // copy over the new rules into our values object
        Object.assign(accum.values, newRules);
      }
    } else if (adUnit.floors != null) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)(`adUnit '${adUnit.code}' provides an invalid \`floor\` definition, it will be ignored for floor calculations`, adUnit);
    }
    return accum;
  }, {});
}
function getNoFloorSignalBidersArray(floorData) {
  const {
    data,
    enforcement
  } = floorData;
  // The data.noFloorSignalBidders higher priority then the enforcment
  if (data?.noFloorSignalBidders?.length > 0) {
    return data.noFloorSignalBidders;
  } else if (enforcement?.noFloorSignalBidders?.length > 0) {
    return enforcement.noFloorSignalBidders;
  }
  return [];
}

/**
 * @summary This function takes the adUnits for the auction and update them accordingly as well as returns the rules hashmap for the auction
 */
function updateAdUnitsForAuction(adUnits, floorData, auctionId) {
  const noFloorSignalBiddersArray = getNoFloorSignalBidersArray(floorData);
  adUnits.forEach(adUnit => {
    adUnit.bids.forEach(bid => {
      // check if the bidder is in the no signal list
      const isNoFloorSignaled = noFloorSignalBiddersArray.some(bidderName => bidderName === bid.bidder);
      if (floorData.skipped || isNoFloorSignaled) {
        isNoFloorSignaled && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)(`noFloorSignal to ${bid.bidder}`);
        delete bid.getFloor;
      } else {
        bid.getFloor = getFloor;
      }
      // information for bid and analytics adapters
      bid.auctionId = auctionId;
      bid.floorData = {
        noFloorSignaled: isNoFloorSignaled,
        skipped: floorData.skipped,
        skipRate: (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(floorData, 'data.skipRate') ?? floorData.skipRate,
        skippedReason: floorData.skippedReason,
        floorMin: floorData.floorMin,
        modelVersion: (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(floorData, 'data.modelVersion'),
        modelWeight: (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(floorData, 'data.modelWeight'),
        modelTimestamp: (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(floorData, 'data.modelTimestamp'),
        location: (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(floorData, 'data.location', 'noData'),
        floorProvider: floorData.floorProvider,
        fetchStatus: _floorsConfig.fetchStatus
      };
    });
  });
}
function pickRandomModel(modelGroups, weightSum) {
  // we loop through the models subtracting the current model weight from our random number
  // once we are at or below zero, we return the associated model
  let random = Math.floor(Math.random() * weightSum + 1);
  for (let i = 0; i < modelGroups.length; i++) {
    random -= modelGroups[i].modelWeight;
    if (random <= 0) {
      return modelGroups[i];
    }
  }
}
;

/**
 * @summary Updates the adUnits accordingly and returns the necessary floorsData for the current auction
 */
function createFloorsDataForAuction(adUnits, auctionId) {
  let resolvedFloorsData = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.deepClone)(_floorsConfig);
  // if using schema 2 pick a model here:
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(resolvedFloorsData, 'data.floorsSchemaVersion') === 2) {
    // merge the models specific stuff into the top level data settings (now it looks like floorsSchemaVersion 1!)
    let {
      modelGroups,
      ...rest
    } = resolvedFloorsData.data;
    resolvedFloorsData.data = Object.assign(rest, pickRandomModel(modelGroups, rest.modelWeightSum));
  }

  // if we do not have a floors data set, we will try to use data set on adUnits
  let useAdUnitData = Object.keys((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(resolvedFloorsData, 'data.values') || {}).length === 0;
  if (useAdUnitData) {
    resolvedFloorsData.data = getFloorDataFromAdUnits(adUnits);
  } else {
    resolvedFloorsData.data = getFloorsDataForAuction(resolvedFloorsData.data);
  }
  // if we still do not have a valid floor data then floors is not on for this auction, so skip
  if (Object.keys((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(resolvedFloorsData, 'data.values') || {}).length === 0) {
    resolvedFloorsData.skipped = true;
    resolvedFloorsData.skippedReason = FLOOR_SKIPPED_REASON.NOT_FOUND;
  } else {
    // determine the skip rate now
    const auctionSkipRate = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.getParameterByName)('pbjs_skipRate') || ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(resolvedFloorsData, 'data.skipRate') ?? resolvedFloorsData.skipRate);
    const isSkipped = Math.random() * 100 < parseFloat(auctionSkipRate);
    resolvedFloorsData.skipped = isSkipped;
    if (isSkipped) resolvedFloorsData.skippedReason = FLOOR_SKIPPED_REASON.RANDOM;
  }
  // copy FloorMin to floorData.data
  if (resolvedFloorsData.hasOwnProperty('floorMin')) resolvedFloorsData.data.floorMin = resolvedFloorsData.floorMin;
  // add floorData to bids
  updateAdUnitsForAuction(adUnits, resolvedFloorsData, auctionId);
  return resolvedFloorsData;
}

/**
 * @summary This is the function which will be called to exit our module and continue the auction.
 */
function continueAuction(hookConfig) {
  if (!hookConfig.hasExited) {
    // We need to know the auctionId at this time. So we will use the passed in one or generate and set it ourselves
    hookConfig.reqBidsConfigObj.auctionId = hookConfig.reqBidsConfigObj.auctionId || (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.generateUUID)();
    // now we do what we need to with adUnits and save the data object to be used for getFloor and enforcement calls
    _floorDataForAuction[hookConfig.reqBidsConfigObj.auctionId] = createFloorsDataForAuction(hookConfig.reqBidsConfigObj.adUnits || (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_9__.getGlobal)().adUnits, hookConfig.reqBidsConfigObj.auctionId);
    hookConfig.nextFn.apply(hookConfig.context, [hookConfig.reqBidsConfigObj]);
    hookConfig.hasExited = true;
  }
}
function validateSchemaFields(fields) {
  if (Array.isArray(fields) && fields.length > 0) {
    if (fields.every(field => allowedFields.includes(field))) {
      return true;
    } else {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)(`${MODULE_NAME}: Fields received do not match allowed fields`);
    }
  }
  return false;
}
function isValidRule(key, floor, numFields, delimiter) {
  if (typeof key !== 'string' || key.split(delimiter).length !== numFields) {
    return false;
  }
  return typeof floor === 'number' || floor === null;
}
function validateRules(floorsData, numFields, delimiter) {
  if (typeof floorsData.values !== 'object') {
    return false;
  }
  // if an invalid rule exists we remove it
  floorsData.values = Object.keys(floorsData.values).reduce((filteredRules, key) => {
    if (isValidRule(key, floorsData.values[key], numFields, delimiter)) {
      filteredRules[key] = floorsData.values[key];
    }
    return filteredRules;
  }, {});
  // rules is only valid if at least one rule remains
  return Object.keys(floorsData.values).length > 0;
}
function normalizeDefault(model) {
  if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.isNumber)(model.default)) {
    let defaultRule = '*';
    const numFields = (model.schema?.fields || []).length;
    if (!numFields) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__.dset)(model, 'schema.fields', [SYN_FIELD]);
    } else {
      defaultRule = Array(numFields).fill('*').join(model.schema?.delimiter || '|');
    }
    model.values = model.values || {};
    if (model.values[defaultRule] == null) {
      model.values[defaultRule] = model.default;
      model.meta = {
        defaultRule
      };
    }
  }
  return model;
}
function modelIsValid(model) {
  model = normalizeDefault(model);
  // schema.fields has only allowed attributes
  if (!validateSchemaFields((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(model, 'schema.fields'))) {
    return false;
  }
  return validateRules(model, model.schema.fields.length, model.schema.delimiter || '|');
}

/**
 * @summary Mapping of floor schema version to it's corresponding validation
 */
const floorsSchemaValidation = {
  1: data => modelIsValid(data),
  2: data => {
    // model groups should be an array with at least one element
    if (!Array.isArray(data.modelGroups) || data.modelGroups.length === 0) {
      return false;
    }
    // every model should have valid schema, as well as an accompanying modelWeight
    data.modelWeightSum = 0;
    return data.modelGroups.every(model => {
      if (typeof model.modelWeight === 'number' && modelIsValid(model)) {
        data.modelWeightSum += model.modelWeight;
        return true;
      }
      return false;
    });
  }
};

/**
 * @summary Fields array should have at least one entry and all should match allowed fields
 * Each rule in the values array should have a 'key' and 'floor' param
 * And each 'key' should have the correct number of 'fields' after splitting
 * on the delim. If rule does not match remove it. return if still at least 1 rule
 */
function isFloorsDataValid(floorsData) {
  if (typeof floorsData !== 'object') {
    return false;
  }
  floorsData.floorsSchemaVersion = floorsData.floorsSchemaVersion || 1;
  if (typeof floorsSchemaValidation[floorsData.floorsSchemaVersion] !== 'function') {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)(`${MODULE_NAME}: Unknown floorsSchemaVersion: `, floorsData.floorsSchemaVersion);
    return false;
  }
  return floorsSchemaValidation[floorsData.floorsSchemaVersion](floorsData);
}

/**
 * @summary This function updates the global Floors Data field based on the new one passed in if it is valid
 */
function parseFloorData(floorsData, location) {
  if (floorsData && typeof floorsData === 'object' && isFloorsDataValid(floorsData)) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)(`${MODULE_NAME}: A ${location} set the auction floor data set to `, floorsData);
    return {
      ...floorsData,
      location
    };
  }
  (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)(`${MODULE_NAME}: The floors data did not contain correct values`, floorsData);
}

/**
 *
 * @param {Object} reqBidsConfigObj required; This is the same param that's used in pbjs.requestBids.
 * @param {function} fn required; The next function in the chain, used by hook.js
 */
const requestBidsHook = (0,_src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_11__.timedAuctionHook)('priceFloors', function requestBidsHook(fn, reqBidsConfigObj) {
  // preserves all module related variables for the current auction instance (used primiarily for concurrent auctions)
  const hookConfig = {
    reqBidsConfigObj,
    context: this,
    nextFn: fn,
    hasExited: false,
    timer: null
  };

  // If auction delay > 0 AND we are fetching -> Then wait until it finishes
  if (_floorsConfig.auctionDelay > 0 && fetching) {
    _delayedAuctions.submit(_floorsConfig.auctionDelay, () => continueAuction(hookConfig), () => {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)(`${MODULE_NAME}: Fetch attempt did not return in time for auction`);
      _floorsConfig.fetchStatus = 'timeout';
      continueAuction(hookConfig);
    });
  } else {
    continueAuction(hookConfig);
  }
});

/**
 * This function handles the ajax response which comes from the user set URL to fetch floors data from
 * @param {object} fetchResponse The floors data response which came back from the url configured in config.floors
 */
function handleFetchResponse(fetchResponse) {
  fetching = false;
  _floorsConfig.fetchStatus = 'success';
  let floorResponse;
  try {
    floorResponse = JSON.parse(fetchResponse);
  } catch (ex) {
    floorResponse = fetchResponse;
  }
  // Update the global floors object according to the fetched data
  const fetchData = parseFloorData(floorResponse, 'fetch');
  if (fetchData) {
    // set .data to it
    _floorsConfig.data = fetchData;
    // set skipRate override if necessary
    _floorsConfig.skipRate = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.isNumber)(fetchData.skipRate) ? fetchData.skipRate : _floorsConfig.skipRate;
    _floorsConfig.floorProvider = fetchData.floorProvider || _floorsConfig.floorProvider;
  }

  // if any auctions are waiting for fetch to finish, we need to continue them!
  _delayedAuctions.resume();
}
function handleFetchError(status) {
  fetching = false;
  _floorsConfig.fetchStatus = 'error';
  (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)(`${MODULE_NAME}: Fetch errored with: `, status);

  // if any auctions are waiting for fetch to finish, we need to continue them!
  _delayedAuctions.resume();
}

/**
 * This function handles sending and receiving the AJAX call for a floors fetch
 * @param {object} floorEndpoint the floors config coming from setConfig
 */
function generateAndHandleFetch(floorEndpoint) {
  // if a fetch url is defined and one is not already occurring, fire it!
  if (floorEndpoint.url && !fetching) {
    // default to GET and we only support GET for now
    let requestMethod = floorEndpoint.method || 'GET';
    if (requestMethod !== 'GET') {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)(`${MODULE_NAME}: 'GET' is the only request method supported at this time!`);
    } else {
      ajax(floorEndpoint.url, {
        success: handleFetchResponse,
        error: handleFetchError
      }, null, {
        method: 'GET'
      });
      fetching = true;
    }
  } else if (fetching) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)(`${MODULE_NAME}: A fetch is already occurring. Skipping.`);
  }
}

/**
 * @summary Updates our allowedFields and fieldMatchingFunctions with the publisher defined new ones
 */
function addFieldOverrides(overrides) {
  Object.keys(overrides).forEach(override => {
    // we only add it if it is not already in the allowed fields and if the passed in value is a function
    if (allowedFields.indexOf(override) === -1 && typeof overrides[override] === 'function') {
      allowedFields.push(override);
      fieldMatchingFunctions[override] = overrides[override];
    }
  });
}

/**
 * @summary This is the function which controls what happens during a pbjs.setConfig({...floors: {}}) is called
 */
function handleSetFloorsConfig(config) {
  _floorsConfig = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.pick)(config, ['floorMin', 'enabled', enabled => enabled !== false,
  // defaults to true
  'auctionDelay', auctionDelay => auctionDelay || 0, 'floorProvider', floorProvider => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(config, 'data.floorProvider', floorProvider), 'endpoint', endpoint => endpoint || {}, 'skipRate', () => !isNaN((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(config, 'data.skipRate')) ? config.data.skipRate : config.skipRate || 0, 'enforcement', enforcement => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.pick)(enforcement || {}, ['enforceJS', enforceJS => enforceJS !== false,
  // defaults to true
  'enforcePBS', enforcePBS => enforcePBS === true,
  // defaults to false
  'floorDeals', floorDeals => floorDeals === true,
  // defaults to false
  'bidAdjustment', bidAdjustment => bidAdjustment !== false,
  // defaults to true,
  'noFloorSignalBidders', noFloorSignalBidders => noFloorSignalBidders || []]), 'additionalSchemaFields', additionalSchemaFields => typeof additionalSchemaFields === 'object' && Object.keys(additionalSchemaFields).length > 0 ? addFieldOverrides(additionalSchemaFields) : undefined, 'data', data => data && parseFloorData(data, 'setConfig') || undefined]);

  // if enabled then do some stuff
  if (_floorsConfig.enabled) {
    // handle the floors fetch
    generateAndHandleFetch(_floorsConfig.endpoint);
    if (!addedFloorsHook) {
      // register hooks / listening events
      // when auction finishes remove it's associated floor data after 3 seconds so we stil have it for latent responses
      _src_events_js__WEBPACK_IMPORTED_MODULE_12__.on(_src_constants_js__WEBPACK_IMPORTED_MODULE_13__.EVENTS.AUCTION_END, args => {
        setTimeout(() => delete _floorDataForAuction[args.auctionId], 3000);
      });

      // we want our hooks to run after the currency hooks
      (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_9__.getGlobal)().requestBids.before(requestBidsHook, 50);
      // if user has debug on then we want to allow the debugging module to run before this, assuming they are testing priceFloors
      // debugging is currently set at 5 priority
      (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_14__.getHook)('addBidResponse').before(addBidResponseHook, (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.debugTurnedOn)() ? 4 : 50);
      addedFloorsHook = true;
    }
  } else {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)(`${MODULE_NAME}: Turning off module`);
    _floorsConfig = {};
    _floorDataForAuction = {};
    (0,_src_hook_js__WEBPACK_IMPORTED_MODULE_14__.getHook)('addBidResponse').getHooks({
      hook: addBidResponseHook
    }).remove();
    (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_9__.getGlobal)().requestBids.getHooks({
      hook: requestBidsHook
    }).remove();
    addedFloorsHook = false;
  }
}

/**
 * @summary Analytics adapters especially need context of what the floors module is doing in order
 * to best create informed models. This function attaches necessary information to the bidResponse object for processing
 */
function addFloorDataToBid(floorData, floorInfo, bid, adjustedCpm) {
  bid.floorData = {
    floorValue: floorInfo.matchingFloor,
    floorRule: floorInfo.matchingRule,
    floorRuleValue: floorInfo.floorRuleValue,
    floorCurrency: floorData.data.currency,
    cpmAfterAdjustments: adjustedCpm,
    enforcements: {
      ...floorData.enforcement
    },
    matchedFields: {}
  };
  floorData.data.schema.fields.forEach((field, index) => {
    let matchedValue = floorInfo.matchingData.split(floorData.data.schema.delimiter)[index];
    bid.floorData.matchedFields[field] = matchedValue;
  });
}

/**
 * @summary takes the enforcement flags and the bid itself and determines if it should be floored
 */
function shouldFloorBid(floorData, floorInfo, bid) {
  let enforceJS = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(floorData, 'enforcement.enforceJS') !== false;
  let shouldFloorDeal = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(floorData, 'enforcement.floorDeals') === true || !bid.dealId;
  let bidBelowFloor = bid.floorData.cpmAfterAdjustments < floorInfo.matchingFloor;
  return enforceJS && bidBelowFloor && shouldFloorDeal;
}

/**
 * @summary The main driving force of floors. On bidResponse we hook in and intercept bidResponses.
 * And if the rule we find determines a bid should be floored we will do so.
 */
const addBidResponseHook = (0,_src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_11__.timedBidResponseHook)('priceFloors', function addBidResponseHook(fn, adUnitCode, bid, reject) {
  let floorData = _floorDataForAuction[bid.auctionId];
  // if no floor data then bail
  if (!floorData || !bid || floorData.skipped) {
    return fn.call(this, adUnitCode, bid, reject);
  }
  const matchingBidRequest = _src_auctionManager_js__WEBPACK_IMPORTED_MODULE_4__.auctionManager.index.getBidRequest(bid);

  // get the matching rule
  let floorInfo = getFirstMatchingFloor(floorData.data, matchingBidRequest, {
    ...bid,
    size: [bid.width, bid.height]
  });
  if (!floorInfo.matchingFloor) {
    if (floorInfo.matchingFloor !== 0) (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)(`${MODULE_NAME}: unable to determine a matching price floor for bidResponse`, bid);
    return fn.call(this, adUnitCode, bid, reject);
  }

  // determine the base cpm to use based on if the currency matches the floor currency
  let adjustedCpm;
  let floorCurrency = floorData.data.currency.toUpperCase();
  let bidResponseCurrency = bid.currency || 'USD'; // if an adapter does not set a bid currency and currency module not on it may come in as undefined
  if (floorCurrency === bidResponseCurrency.toUpperCase()) {
    adjustedCpm = bid.cpm;
  } else if (bid.originalCurrency && floorCurrency === bid.originalCurrency.toUpperCase()) {
    adjustedCpm = bid.originalCpm;
  } else {
    try {
      adjustedCpm = (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_9__.getGlobal)().convertCurrency(bid.cpm, bidResponseCurrency.toUpperCase(), floorCurrency);
    } catch (err) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)(`${MODULE_NAME}: Unable do get currency conversion for bidResponse to Floor Currency. Do you have Currency module enabled? ${bid}`);
      return fn.call(this, adUnitCode, bid, reject);
    }
  }

  // ok we got the bid response cpm in our desired currency. Now we need to run the bidders CPMAdjustment function if it exists
  adjustedCpm = getBiddersCpmAdjustment(adjustedCpm, bid, matchingBidRequest);

  // add necessary data information for analytics adapters / floor providers would possibly need
  addFloorDataToBid(floorData, floorInfo, bid, adjustedCpm);

  // now do the compare!
  if (shouldFloorBid(floorData, floorInfo, bid)) {
    // bid fails floor -> throw it out
    reject(_src_constants_js__WEBPACK_IMPORTED_MODULE_13__.REJECTION_REASON.FLOOR_NOT_MET);
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)(`${MODULE_NAME}: ${bid.bidderCode}'s Bid Response for ${adUnitCode} was rejected due to floor not met (adjusted cpm: ${bid?.floorData?.cpmAfterAdjustments}, floor: ${floorInfo?.matchingFloor})`, bid);
    return;
  }
  return fn.call(this, adUnitCode, bid, reject);
});
_src_config_js__WEBPACK_IMPORTED_MODULE_15__.config.getConfig('floors', config => handleSetFloorsConfig(config.floors));
function tryGetFloor(bidRequest, _ref2, fn) {
  let {
    currency = _src_config_js__WEBPACK_IMPORTED_MODULE_15__.config.getConfig('currency.adServerCurrency') || 'USD',
    mediaType = '*',
    size = '*'
  } = _ref2;
  if (typeof bidRequest.getFloor === 'function') {
    let floor;
    try {
      floor = bidRequest.getFloor({
        currency,
        mediaType,
        size
      }) || {};
    } catch (e) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logWarn)('Cannot compute floor for bid', bidRequest);
      return;
    }
    floor.floor = parseFloat(floor.floor);
    if (floor.currency != null && floor.floor && !isNaN(floor.floor)) {
      fn(floor.floor, floor.currency);
    }
  }
}

/**
 * Sets bidfloor and bidfloorcur for ORTB imp objects
 */
function setOrtbImpBidFloor(imp, bidRequest, context) {
  tryGetFloor(bidRequest, {
    currency: context.currency,
    mediaType: context.mediaType || '*',
    size: '*'
  }, (bidfloor, bidfloorcur) => {
    Object.assign(imp, {
      bidfloor,
      bidfloorcur
    });
  });
}

/**
 * Set per-mediatype and per-format bidfloor
 */
function setGranularBidfloors(imp, bidRequest, context) {
  function setIfDifferent(bidfloor, bidfloorcur) {
    if (bidfloor !== imp.bidfloor || bidfloorcur !== imp.bidfloorcur) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__.dset)(this, 'ext.bidfloor', bidfloor);
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__.dset)(this, 'ext.bidfloorcur', bidfloorcur);
    }
  }
  Object.values(_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_16__.ALL_MEDIATYPES).filter(mediaType => imp[mediaType] != null).forEach(mediaType => {
    tryGetFloor(bidRequest, {
      currency: imp.bidfloorcur || context?.currency,
      mediaType
    }, setIfDifferent.bind(imp[mediaType]));
  });
  (imp[_src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_16__.BANNER]?.format || []).filter(_ref3 => {
    let {
      w,
      h
    } = _ref3;
    return w != null && h != null;
  }).forEach(format => {
    tryGetFloor(bidRequest, {
      currency: imp.bidfloorcur || context?.currency,
      mediaType: _src_mediaTypes_js__WEBPACK_IMPORTED_MODULE_16__.BANNER,
      size: [format.w, format.h]
    }, setIfDifferent.bind(format));
  });
}
function setImpExtPrebidFloors(imp, bidRequest, context) {
  // logic below relates to https://github.com/prebid/Prebid.js/issues/8749 and does the following:
  // 1. check client-side floors (ref bidfloor/bidfloorcur & ortb2Imp floorMin/floorMinCur (if present))
  // 2. set pbs req wide floorMinCur to the first floor currency found when iterating over imp's
  //    (if currency conversion logic present, convert all imp floor values to this currency)
  // 3. compare/store ref to lowest floorMin value as each imp is iterated over
  // 4. set req wide floorMin and floorMinCur values for pbs after iterations are done

  if (imp.bidfloor != null) {
    let {
      floorMinCur,
      floorMin
    } = context.reqContext.floorMin || {};
    if (floorMinCur == null) {
      floorMinCur = imp.bidfloorcur;
    }
    const ortb2ImpFloorCur = imp.ext?.prebid?.floors?.floorMinCur || imp.ext?.prebid?.floorMinCur || floorMinCur;
    const ortb2ImpFloorMin = imp.ext?.prebid?.floors?.floorMin || imp.ext?.prebid?.floorMin;
    const convertedFloorMinValue = (0,_libraries_currencyUtils_currency_js__WEBPACK_IMPORTED_MODULE_17__.convertCurrency)(imp.bidfloor, imp.bidfloorcur, floorMinCur);
    const convertedOrtb2ImpFloorMinValue = ortb2ImpFloorMin && ortb2ImpFloorCur ? (0,_libraries_currencyUtils_currency_js__WEBPACK_IMPORTED_MODULE_17__.convertCurrency)(ortb2ImpFloorMin, ortb2ImpFloorCur, floorMinCur) : false;
    const lowestImpFloorMin = convertedOrtb2ImpFloorMinValue && convertedOrtb2ImpFloorMinValue < convertedFloorMinValue ? convertedOrtb2ImpFloorMinValue : convertedFloorMinValue;
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__.dset)(imp, 'ext.prebid.floors.floorMin', lowestImpFloorMin);
    if (floorMin == null || floorMin > lowestImpFloorMin) {
      floorMin = lowestImpFloorMin;
    }
    context.reqContext.floorMin = {
      floorMin,
      floorMinCur
    };
  }
}

/**
 * PBS specific extension: set ext.prebid.floors.enabled = false if floors are processed client-side
 */
function setOrtbExtPrebidFloors(ortbRequest, bidderRequest, context) {
  if (addedFloorsHook) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_7__.dset)(ortbRequest, 'ext.prebid.floors.enabled', ortbRequest.ext?.prebid?.floors?.enabled || false);
  }
  if (context?.floorMin) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeDeep)(ortbRequest, {
      ext: {
        prebid: {
          floors: context.floorMin
        }
      }
    });
  }
}
(0,_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_18__.registerOrtbProcessor)({
  type: _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_18__.IMP,
  name: 'bidfloor',
  fn: setOrtbImpBidFloor
});
// granular floors should be set after both "normal" bidfloors and mediaypes
(0,_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_18__.registerOrtbProcessor)({
  type: _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_18__.IMP,
  name: 'extBidfloor',
  fn: setGranularBidfloors,
  priority: -10
});
(0,_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_18__.registerOrtbProcessor)({
  type: _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_18__.IMP,
  name: 'extPrebidFloors',
  fn: setImpExtPrebidFloors,
  dialects: [_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_18__.PBS],
  priority: -1
});
(0,_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_18__.registerOrtbProcessor)({
  type: _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_18__.REQUEST,
  name: 'extPrebidFloors',
  fn: setOrtbExtPrebidFloors,
  dialects: [_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_18__.PBS]
});
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_9__.registerModule)('priceFloors');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","gptUtils","currencyUtils","timeoutQueue","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/priceFloors.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["publinkIdSystem"],{

/***/ "./modules/publinkIdSystem.js":
/*!************************************!*\
  !*** ./modules/publinkIdSystem.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports storage, publinkIdSubmodule */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_storageManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/storageManager.js */ "./src/storageManager.js");
/* harmony import */ var _src_ajax_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/ajax.js */ "./src/ajax.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/activities/modules.js */ "./src/activities/modules.js");

/**
 * This module adds the PublinkId to the User ID module
 * The {@link module:modules/userId} module is required
 * @module modules/publinkIdSystem
 * @requires module:modules/userId
 */







/**
 * @typedef {import('../modules/userId/index.js').Submodule} Submodule
 * @typedef {import('../modules/userId/index.js').SubmoduleConfig} SubmoduleConfig
 * @typedef {import('../modules/userId/index.js').ConsentData} ConsentData
 * @typedef {import('../modules/userId/index.js').IdResponse} IdResponse
 */

const MODULE_NAME = 'publinkId';
const GVLID = 24;
const PUBLINK_COOKIE = '_publink';
const PUBLINK_S2S_COOKIE = '_publink_srv';
const PUBLINK_REQUEST_PATH = '/cvx/client/sync/publink';
const PUBLINK_REFRESH_PATH = '/cvx/client/sync/publink/refresh';
const storage = (0,_src_storageManager_js__WEBPACK_IMPORTED_MODULE_0__.getStorageManager)({
  moduleType: _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_1__.MODULE_TYPE_UID,
  moduleName: MODULE_NAME
});
function isHex(s) {
  return /^[A-F0-9]+$/i.test(s);
}
function publinkIdUrl(params, consentData, storedId) {
  let url = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.parseUrl)('https://proc.ad.cpe.dotomi.com' + PUBLINK_REFRESH_PATH);
  url.search = {
    mpn: 'Prebid.js',
    mpv: "9.49.0-pre"
  };
  if (consentData?.gdpr) {
    url.search.gdpr = consentData.gdpr.gdprApplies ? 1 : 0;
    url.search.gdpr_consent = consentData.gdpr.consentString;
  }
  if (params) {
    if (params.e) {
      // if there's an email parameter call the request path
      url.search.deh = params.e;
      url.pathname = PUBLINK_REQUEST_PATH;
    }
    if (params.site_id) {
      url.search.sid = params.site_id;
    }
    if (params.api_key) {
      url.search.apikey = params.api_key;
    }
  }
  if (storedId) {
    url.search.publink = storedId;
  }
  const usPrivacyString = consentData?.usp;
  if (usPrivacyString && typeof usPrivacyString === 'string') {
    url.search.us_privacy = usPrivacyString;
  }
  return (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.buildUrl)(url);
}
function makeCallback() {
  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let consentData = arguments.length > 1 ? arguments[1] : undefined;
  let storedId = arguments.length > 2 ? arguments[2] : undefined;
  return function (prebidCallback) {
    const options = {
      method: 'GET',
      withCredentials: true
    };
    let handleResponse = function (responseText, xhr) {
      if (xhr.status === 200) {
        let response = JSON.parse(responseText);
        if (response) {
          prebidCallback(response.publink);
        }
      }
    };
    if (config.params && config.params.e && isHex(config.params.e) || storedId) {
      (0,_src_ajax_js__WEBPACK_IMPORTED_MODULE_3__.ajax)(publinkIdUrl(config.params, consentData, storedId), handleResponse, undefined, options);
    } else if (config.params.e) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)('params.e must be a hex string');
    }
  };
}
function getlocalValue() {
  let result;
  function getData(key) {
    let value;
    if (storage.hasLocalStorage()) {
      value = storage.getDataFromLocalStorage(key);
    }
    if (!value) {
      value = storage.getCookie(key);
    }
    if (typeof value === 'string') {
      // if it's a json object parse it and return the publink value, otherwise assume the value is the id
      if (value.charAt(0) === '{') {
        try {
          const obj = JSON.parse(value);
          if (obj) {
            return obj.publink;
          }
        } catch (e) {
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logError)(e);
        }
      } else {
        return value;
      }
    }
  }
  result = getData(PUBLINK_S2S_COOKIE);
  if (!result) {
    result = getData(PUBLINK_COOKIE);
  }
  return result;
}

/** @type {Submodule} */
const publinkIdSubmodule = {
  /**
   * used to link submodule with config
   * @type {string}
   */
  name: MODULE_NAME,
  gvlid: GVLID,
  /**
   * decode the stored id value for passing to bid requests
   * @function
   * @param {string} publinkId encrypted userid
   * @returns {{publinkId: string} | undefined}
   */
  decode(publinkId) {
    return {
      publinkId: publinkId
    };
  },
  /**
   * performs action to obtain id
   * Use a publink cookie first if it is present, otherwise use prebids copy, if neither are available callout to get a new id
   * @function
   * @param {SubmoduleConfig} [config] Config object with params and storage properties
   * @param {ConsentData|undefined} consentData GDPR consent
   * @param {(Object|undefined)} storedId Previously cached id
   * @returns {IdResponse}
   */
  getId: function (config, consentData, storedId) {
    const localValue = getlocalValue();
    if (localValue) {
      return {
        id: localValue
      };
    }
    return {
      callback: makeCallback(config, consentData, storedId)
    };
  },
  eids: {
    'publinkId': {
      source: 'epsilon.com',
      atype: 3
    }
  }
};
(0,_src_hook_js__WEBPACK_IMPORTED_MODULE_4__.submodule)('userId', publinkIdSubmodule);
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_5__.registerModule)('publinkIdSystem');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/publinkIdSystem.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["schain"],{

/***/ "./modules/schain.js":
/*!***************************!*\
  !*** ./modules/schain.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports isSchainObjectValid, isValidSchainConfig, makeBidRequestsHook, init, setOrtbSourceExtSchain */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/adapterManager.js */ "./src/adapterManager.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/pbjsORTB.js */ "./src/pbjsORTB.js");






// https://github.com/InteractiveAdvertisingBureau/openrtb/blob/master/supplychainobject.md

const schainErrorPrefix = 'Invalid schain object found: ';
const shouldBeAString = ' should be a string';
const shouldBeAnInteger = ' should be an Integer';
const shouldBeAnObject = ' should be an object';
const shouldBeAnArray = ' should be an Array';
const MODE = {
  STRICT: 'strict',
  RELAXED: 'relaxed',
  OFF: 'off'
};
const MODES = []; // an array of modes
(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__._each)(MODE, mode => MODES.push(mode));

// validate the supply chain object
function isSchainObjectValid(schainObject, returnOnError) {
  let failPrefix = 'Detected something wrong within an schain config:';
  let failMsg = '';
  function appendFailMsg(msg) {
    failMsg += '\n' + msg;
  }
  function printFailMsg() {
    if (returnOnError === true) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError)(failPrefix, schainObject, failMsg);
    } else {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.logWarn)(failPrefix, schainObject, failMsg);
    }
  }
  if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(schainObject)) {
    appendFailMsg(`schain.config` + shouldBeAnObject);
    printFailMsg();
    if (returnOnError) return false;
  }

  // complete: Integer
  if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(schainObject.complete) || !(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(schainObject.complete)) {
    appendFailMsg(`schain.config.complete` + shouldBeAnInteger);
  }

  // ver: String
  if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr)(schainObject.ver)) {
    appendFailMsg(`schain.config.ver` + shouldBeAString);
  }

  // ext: Object [optional]
  if (schainObject.hasOwnProperty('ext')) {
    if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(schainObject.ext)) {
      appendFailMsg(`schain.config.ext` + shouldBeAnObject);
    }
  }

  // nodes: Array of objects
  if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(schainObject.nodes)) {
    appendFailMsg(`schain.config.nodes` + shouldBeAnArray);
    printFailMsg();
    if (returnOnError) return false;
  } else {
    schainObject.nodes.forEach((node, index) => {
      // asi: String
      if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr)(node.asi)) {
        appendFailMsg(`schain.config.nodes[${index}].asi` + shouldBeAString);
      }

      // sid: String
      if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr)(node.sid)) {
        appendFailMsg(`schain.config.nodes[${index}].sid` + shouldBeAString);
      }

      // hp: Integer
      if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(node.hp) || !(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(node.hp)) {
        appendFailMsg(`schain.config.nodes[${index}].hp` + shouldBeAnInteger);
      }

      // rid: String [Optional]
      if (node.hasOwnProperty('rid')) {
        if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr)(node.rid)) {
          appendFailMsg(`schain.config.nodes[${index}].rid` + shouldBeAString);
        }
      }

      // name: String [Optional]
      if (node.hasOwnProperty('name')) {
        if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr)(node.name)) {
          appendFailMsg(`schain.config.nodes[${index}].name` + shouldBeAString);
        }
      }

      // domain: String [Optional]
      if (node.hasOwnProperty('domain')) {
        if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr)(node.domain)) {
          appendFailMsg(`schain.config.nodes[${index}].domain` + shouldBeAString);
        }
      }

      // ext: Object [Optional]
      if (node.hasOwnProperty('ext')) {
        if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(node.ext)) {
          appendFailMsg(`schain.config.nodes[${index}].ext` + shouldBeAnObject);
        }
      }
    });
  }
  if (failMsg.length > 0) {
    printFailMsg();
    if (returnOnError) {
      return false;
    }
  }
  return true;
}
function isValidSchainConfig(schainObject) {
  if (schainObject === undefined) {
    return false;
  }
  if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(schainObject)) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError)(schainErrorPrefix + 'the following schain config will not be used as schain is not an object.', schainObject);
    return false;
  }
  return true;
}
function resolveSchainConfig(schainObject, bidder) {
  let mode = MODE.STRICT;
  if (isValidSchainConfig(schainObject)) {
    if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr)(schainObject.validation) && MODES.indexOf(schainObject.validation) != -1) {
      mode = schainObject.validation;
    }
    if (mode === MODE.OFF) {
      // no need to validate
      return schainObject.config;
    } else {
      // if strict mode and config is invalid, reject config + throw error; otherwise allow config to go through
      if (isSchainObjectValid(schainObject.config, !!(mode === MODE.STRICT))) {
        return schainObject.config;
      } else {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError)(schainErrorPrefix + `due to the 'strict' validation setting, this schain config will not be passed to bidder '${bidder}'.  See above error for details.`);
      }
    }
  }
  return null;
}
function makeBidRequestsHook(fn, bidderRequests) {
  function getSchainForBidder(bidder) {
    let bidderSchain = bidderConfigs[bidder] && bidderConfigs[bidder].schain;
    return bidderSchain || globalSchainConfig;
  }
  const globalSchainConfig = _src_config_js__WEBPACK_IMPORTED_MODULE_1__.config.getConfig('schain');
  const bidderConfigs = _src_config_js__WEBPACK_IMPORTED_MODULE_1__.config.getBidderConfig();
  bidderRequests.forEach(bidderRequest => {
    let bidder = bidderRequest.bidderCode;
    let schainConfig = getSchainForBidder(bidder);
    bidderRequest.bids.forEach(bid => {
      let result = resolveSchainConfig(schainConfig, bidder);
      if (result) {
        bid.schain = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepClone)(result);
      }
    });
  });
  fn(bidderRequests);
}
function init() {
  _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_2__["default"].makeBidRequests.after(makeBidRequestsHook);
}
init();
function setOrtbSourceExtSchain(ortbRequest, bidderRequest, context) {
  if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(ortbRequest, 'source.ext.schain')) {
    const schain = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"])(context, 'bidRequests.0.schain');
    if (schain) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.dset)(ortbRequest, 'source.ext.schain', schain);
    }
  }
}
(0,_src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_5__.registerOrtbProcessor)({
  type: _src_pbjsORTB_js__WEBPACK_IMPORTED_MODULE_5__.REQUEST,
  name: 'sourceExtSchain',
  fn: setOrtbSourceExtSchain
});
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_6__.registerModule)('schain');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/schain.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["sharedIdSystem"],{

/***/ "./modules/sharedIdSystem.js":
/*!***********************************!*\
  !*** ./modules/sharedIdSystem.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports storage, sharedIdSystemSubmodule */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_storageManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/storageManager.js */ "./src/storageManager.js");
/* harmony import */ var _src_consentHandler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/consentHandler.js */ "./src/consentHandler.js");
/* harmony import */ var _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/activities/modules.js */ "./src/activities/modules.js");
/* harmony import */ var _libraries_domainOverrideToRootDomain_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../libraries/domainOverrideToRootDomain/index.js */ "./libraries/domainOverrideToRootDomain/index.js");

/**
 * This module adds SharedId to the User ID module
 * The {@link module:modules/userId} module is required
 * @module modules/sharedIdSystem
 * @requires module:modules/userId
 */








/**
 * @typedef {import('../modules/userId/index.js').Submodule} Submodule
 * @typedef {import('../modules/userId/index.js').SubmoduleConfig} SubmoduleConfig
 * @typedef {import('../modules/userId/index.js').SubmoduleParams} SubmoduleParams
 * @typedef {import('../modules/userId/index.js').ConsentData} ConsentData
 * @typedef {import('../modules/userId/index.js').IdResponse} IdResponse
 */

const storage = (0,_src_storageManager_js__WEBPACK_IMPORTED_MODULE_0__.getStorageManager)({
  moduleType: _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_1__.MODULE_TYPE_UID,
  moduleName: 'sharedId'
});
const COOKIE = 'cookie';
const LOCAL_STORAGE = 'html5';
const OPTOUT_NAME = '_pubcid_optout';
const PUB_COMMON_ID = 'PublisherCommonId';

/**
 * Read a value either from cookie or local storage
 * @param {string} name Name of the item
 * @param {string} type storage type override
 * @returns {string|null} a string if item exists
 */
function readValue(name, type) {
  if (type === COOKIE) {
    return storage.getCookie(name);
  } else if (type === LOCAL_STORAGE) {
    if (storage.hasLocalStorage()) {
      const expValue = storage.getDataFromLocalStorage(`${name}_exp`);
      if (!expValue) {
        return storage.getDataFromLocalStorage(name);
      } else if (new Date(expValue).getTime() - Date.now() > 0) {
        return storage.getDataFromLocalStorage(name);
      }
    }
  }
}
function getIdCallback(pubcid, pixelUrl) {
  return function (callback, getStoredId) {
    if (pixelUrl) {
      queuePixelCallback(pixelUrl, pubcid, () => {
        callback(getStoredId() || pubcid);
      })();
    } else {
      callback(pubcid);
    }
  };
}
function queuePixelCallback(pixelUrl) {
  let id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  let callback = arguments.length > 2 ? arguments[2] : undefined;
  if (!pixelUrl) {
    return;
  }

  // Use pubcid as a cache buster
  const urlInfo = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.parseUrl)(pixelUrl);
  urlInfo.search.id = encodeURIComponent('pubcid:' + id);
  const targetUrl = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.buildUrl)(urlInfo);
  return function () {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.triggerPixel)(targetUrl, callback);
  };
}
function hasOptedOut() {
  return !!(storage.cookiesAreEnabled() && readValue(OPTOUT_NAME, COOKIE) || storage.hasLocalStorage() && readValue(OPTOUT_NAME, LOCAL_STORAGE));
}
const sharedIdSystemSubmodule = {
  /**
   * used to link submodule with config
   * @type {string}
   */
  name: 'sharedId',
  aliasName: 'pubCommonId',
  gvlid: _src_consentHandler_js__WEBPACK_IMPORTED_MODULE_3__.VENDORLESS_GVLID,
  /**
   * decode the stored id value for passing to bid requests
   * @function
   * @param {string} value
   * @param {SubmoduleConfig} config
   * @returns {{pubcid:string}}
   */
  decode(value, config) {
    if (hasOptedOut()) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)('PubCommonId decode: Has opted-out');
      return undefined;
    }
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)(' Decoded value PubCommonId ' + value);
    const idObj = {
      'pubcid': value
    };
    return idObj;
  },
  /**
   * performs action to obtain id
   * @function
   * @param {SubmoduleConfig} [config] Config object with params and storage properties
   * @param {Object} consentData
   * @param {string} storedId Existing pubcommon id
   * @returns {IdResponse}
   */
  getId: function () {
    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let consentData = arguments.length > 1 ? arguments[1] : undefined;
    let storedId = arguments.length > 2 ? arguments[2] : undefined;
    if (hasOptedOut()) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)('PubCommonId: Has opted-out');
      return;
    }
    if (consentData?.coppa) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)('PubCommonId: IDs not provided for coppa requests, exiting PubCommonId');
      return;
    }
    const {
      params: {
        create = true,
        pixelUrl
      } = {}
    } = config;
    let newId = storedId;
    if (!newId) {
      try {
        if (typeof window[PUB_COMMON_ID] === 'object') {
          // If the page includes its own pubcid module, then save a copy of id.
          newId = window[PUB_COMMON_ID].getId();
        }
      } catch (e) {}
      if (!newId) newId = create && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.hasDeviceAccess)() ? (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.generateUUID)() : undefined;
    }
    return {
      id: newId,
      callback: getIdCallback(newId, pixelUrl)
    };
  },
  /**
   * performs action to extend an id.  There are generally two ways to extend the expiration time
   * of stored id: using pixelUrl or return the id and let main user id module write it again with
   * the new expiration time.
   *
   * PixelUrl, if defined, should point back to a first party domain endpoint.  On the server
   * side, there is either a plugin, or customized logic to read and write back the pubcid cookie.
   * The extendId function itself should return only the callback, and not the id itself to avoid
   * having the script-side overwriting server-side.  This applies to both pubcid and sharedid.
   *
   * On the other hand, if there is no pixelUrl, then the extendId should return storedId so that
   * its expiration time is updated.
   *
   * @function
   * @param {SubmoduleParams} [config]
   * @param {ConsentData|undefined} consentData
   * @param {Object} storedId existing id
   * @returns {IdResponse|undefined}
   */
  extendId: function () {
    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let consentData = arguments.length > 1 ? arguments[1] : undefined;
    let storedId = arguments.length > 2 ? arguments[2] : undefined;
    if (hasOptedOut()) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)('PubCommonId: Has opted-out');
      return {
        id: undefined
      };
    }
    if (consentData?.coppa) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.logInfo)('PubCommonId: IDs not provided for coppa requests, exiting PubCommonId');
      return;
    }
    const {
      params: {
        extend = false,
        pixelUrl
      } = {}
    } = config;
    if (extend) {
      if (pixelUrl) {
        const callback = queuePixelCallback(pixelUrl, storedId);
        return {
          callback: callback
        };
      } else {
        return {
          id: storedId
        };
      }
    }
  },
  domainOverride: (0,_libraries_domainOverrideToRootDomain_index_js__WEBPACK_IMPORTED_MODULE_4__.domainOverrideToRootDomain)(storage, 'sharedId'),
  eids: {
    'pubcid'(values, config) {
      const eid = {
        source: 'pubcid.org',
        uids: values.map(id => ({
          id,
          atype: 1
        }))
      };
      if (config?.params?.inserter != null) {
        eid.inserter = config.params.inserter;
      }
      return eid;
    }
  }
};
(0,_src_hook_js__WEBPACK_IMPORTED_MODULE_5__.submodule)('userId', sharedIdSystemSubmodule);
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_6__.registerModule)('sharedIdSystem');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["domainOverrideToRootDomain","chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/sharedIdSystem.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["tcfControl"],{

/***/ "./modules/tcfControl.js":
/*!*******************************!*\
  !*** ./modules/tcfControl.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports STRICT_STORAGE_ENFORCEMENT, ACTIVE_RULES, getGvlid, getGvlidFromAnalyticsAdapter, shouldEnforce, validateRules, accessDeviceRule, syncUserRule, enrichEidsRule, fetchBidsRule, reportAnalyticsRule, ufpdRule, transmitEidsRule, transmitPreciseGeoRule, setEnforcementConfig, uninstall */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/utils.js */ "./node_modules/dlv/index.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/adapterManager.js */ "./src/adapterManager.js");
/* harmony import */ var _src_consentHandler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/consentHandler.js */ "./src/consentHandler.js");
/* harmony import */ var _src_events_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/events.js */ "./src/events.js");
/* harmony import */ var _src_constants_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/constants.js */ "./src/constants.js");
/* harmony import */ var _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/activities/modules.js */ "./src/activities/modules.js");
/* harmony import */ var _src_activities_params_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/activities/params.js */ "./src/activities/params.js");
/* harmony import */ var _src_activities_rules_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/activities/rules.js */ "./src/activities/rules.js");
/* harmony import */ var _src_activities_activities_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/activities/activities.js */ "./src/activities/activities.js");

/**
 * This module gives publishers extra set of features to enforce individual purposes of TCF v2
 */











const STRICT_STORAGE_ENFORCEMENT = 'strictStorageEnforcement';
const ACTIVE_RULES = {
  purpose: {},
  feature: {}
};
const CONSENT_PATHS = {
  purpose: false,
  feature: 'specialFeatureOptins'
};
const CONFIGURABLE_RULES = {
  storage: {
    type: 'purpose',
    default: {
      purpose: 'storage',
      enforcePurpose: true,
      enforceVendor: true,
      vendorExceptions: []
    },
    id: 1
  },
  basicAds: {
    type: 'purpose',
    id: 2,
    default: {
      purpose: 'basicAds',
      enforcePurpose: true,
      enforceVendor: true,
      vendorExceptions: []
    }
  },
  personalizedAds: {
    type: 'purpose',
    id: 4
  },
  measurement: {
    type: 'purpose',
    id: 7
  },
  transmitPreciseGeo: {
    type: 'feature',
    id: 1
  }
};
const storageBlocked = new Set();
const biddersBlocked = new Set();
const analyticsBlocked = new Set();
const ufpdBlocked = new Set();
const eidsBlocked = new Set();
const geoBlocked = new Set();
let hooksAdded = false;
let strictStorageEnforcement = false;
const GVLID_LOOKUP_PRIORITY = [_src_activities_modules_js__WEBPACK_IMPORTED_MODULE_0__.MODULE_TYPE_BIDDER, _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_0__.MODULE_TYPE_UID, _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_0__.MODULE_TYPE_ANALYTICS, _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_0__.MODULE_TYPE_RTD];
const RULE_NAME = 'TCF2';
const RULE_HANDLES = [];

// in JS we do not have access to the GVL; assume that everyone declares legitimate interest for basic ads
const LI_PURPOSES = [2];
const PUBLISHER_LI_PURPOSES = [2, 7, 9, 10];

/**
 * Retrieve a module's GVL ID.
 */
function getGvlid(moduleType, moduleName, fallbackFn) {
  if (moduleName) {
    // Check user defined GVL Mapping in pbjs.setConfig()
    const gvlMapping = _src_config_js__WEBPACK_IMPORTED_MODULE_1__.config.getConfig('gvlMapping');

    // Return GVL ID from user defined gvlMapping
    if (gvlMapping && gvlMapping[moduleName]) {
      return gvlMapping[moduleName];
    } else if (moduleType === _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_0__.MODULE_TYPE_PREBID) {
      return _src_consentHandler_js__WEBPACK_IMPORTED_MODULE_2__.VENDORLESS_GVLID;
    } else {
      let {
        gvlid,
        modules
      } = _src_consentHandler_js__WEBPACK_IMPORTED_MODULE_2__.GDPR_GVLIDS.get(moduleName);
      if (gvlid == null && Object.keys(modules).length > 0) {
        // this behavior is for backwards compatibility; if multiple modules with the same
        // name declare different GVL IDs, pick the bidder's first, then userId, then analytics
        for (const type of GVLID_LOOKUP_PRIORITY) {
          if (modules.hasOwnProperty(type)) {
            gvlid = modules[type];
            if (type !== moduleType) {
              (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(`Multiple GVL IDs found for module '${moduleName}'; using the ${type} module's ID (${gvlid}) instead of the ${moduleType}'s ID (${modules[moduleType]})`);
            }
            break;
          }
        }
      }
      if (gvlid == null && fallbackFn) {
        gvlid = fallbackFn();
      }
      return gvlid || null;
    }
  }
  return null;
}

/**
 * Retrieve GVL IDs that are dynamically set on analytics adapters.
 */
function getGvlidFromAnalyticsAdapter(code, config) {
  const adapter = _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_4__["default"].getAnalyticsAdapter(code);
  return (gvlid => {
    if (typeof gvlid !== 'function') return gvlid;
    try {
      return gvlid.call(adapter.adapter, config);
    } catch (e) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(`Error invoking ${code} adapter.gvlid()`, e);
    }
  })(adapter?.adapter?.gvlid);
}
function shouldEnforce(consentData, purpose, name) {
  if (consentData == null && _src_consentHandler_js__WEBPACK_IMPORTED_MODULE_2__.gdprDataHandler.enabled) {
    // there is no consent data, but the GDPR module has been installed and configured
    // NOTE: this check is not foolproof, as when Prebid first loads, enforcement hooks have not been attached yet
    // This piece of code would not run at all, and `gdprDataHandler.enabled` would be false, until the first
    // `setConfig({consentManagement})`
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(`Attempting operation that requires purpose ${purpose} consent while consent data is not available${name ? ` (module: ${name})` : ''}. Assuming no consent was given.`);
    return true;
  }
  return consentData && consentData.gdprApplies;
}
function getConsentOrLI(consentData, path, id, acceptLI) {
  const data = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(consentData, `vendorData.${path}`);
  return !!data?.consents?.[id] || acceptLI && !!data?.legitimateInterests?.[id];
}
function getConsent(consentData, type, purposeNo, gvlId) {
  let purpose;
  if (CONSENT_PATHS[type] !== false) {
    purpose = !!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(consentData, `vendorData.${CONSENT_PATHS[type]}.${purposeNo}`);
  } else {
    const [path, liPurposes] = gvlId === _src_consentHandler_js__WEBPACK_IMPORTED_MODULE_2__.VENDORLESS_GVLID ? ['publisher', PUBLISHER_LI_PURPOSES] : ['purpose', LI_PURPOSES];
    purpose = getConsentOrLI(consentData, path, purposeNo, liPurposes.includes(purposeNo));
  }
  return {
    purpose,
    vendor: getConsentOrLI(consentData, 'vendor', gvlId, LI_PURPOSES.includes(purposeNo))
  };
}

/**
 * This function takes in a rule and consentData and validates against the consentData provided. Depending on what it returns,
 * the caller may decide to suppress a TCF-sensitive activity.
 * @param {Object} rule - enforcement rules set in config
 * @param {Object} consentData - gdpr consent data
 * @param {string=} currentModule - Bidder code of the current module
 * @param {number=} gvlId - GVL ID for the module
 * @returns {boolean}
 */
function validateRules(rule, consentData, currentModule, gvlId) {
  const ruleOptions = CONFIGURABLE_RULES[rule.purpose];

  // return 'true' if vendor present in 'vendorExceptions'
  if ((rule.vendorExceptions || []).includes(currentModule)) {
    return true;
  }
  const vendorConsentRequred = rule.enforceVendor && !(gvlId === _src_consentHandler_js__WEBPACK_IMPORTED_MODULE_2__.VENDORLESS_GVLID || (rule.softVendorExceptions || []).includes(currentModule));
  const {
    purpose,
    vendor
  } = getConsent(consentData, ruleOptions.type, ruleOptions.id, gvlId);
  return (!rule.enforcePurpose || purpose) && (!vendorConsentRequred || vendor);
}
function gdprRule(purposeNo, checkConsent) {
  let blocked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  let gvlidFallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => null;
  return function (params) {
    const consentData = _src_consentHandler_js__WEBPACK_IMPORTED_MODULE_2__.gdprDataHandler.getConsentData();
    const modName = params[_src_activities_params_js__WEBPACK_IMPORTED_MODULE_6__.ACTIVITY_PARAM_COMPONENT_NAME];
    if (shouldEnforce(consentData, purposeNo, modName)) {
      const gvlid = getGvlid(params[_src_activities_params_js__WEBPACK_IMPORTED_MODULE_6__.ACTIVITY_PARAM_COMPONENT_TYPE], modName, gvlidFallback(params));
      let allow = !!checkConsent(consentData, modName, gvlid);
      if (!allow) {
        blocked && blocked.add(modName);
        return {
          allow
        };
      }
    }
  };
}
function singlePurposeGdprRule(purposeNo) {
  let blocked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  let gvlidFallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => null;
  return gdprRule(purposeNo, (cd, modName, gvlid) => !!validateRules(ACTIVE_RULES.purpose[purposeNo], cd, modName, gvlid), blocked, gvlidFallback);
}
function exceptPrebidModules(ruleFn) {
  return function (params) {
    if (params[_src_activities_params_js__WEBPACK_IMPORTED_MODULE_6__.ACTIVITY_PARAM_COMPONENT_TYPE] === _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_0__.MODULE_TYPE_PREBID) {
      // TODO: this special case is for the PBS adapter (componentType is 'prebid')
      // we should check for generic purpose 2 consent & vendor consent based on the PBS vendor's GVL ID;
      // that is, however, a breaking change and skipped for now
      return;
    }
    return ruleFn(params);
  };
}
const accessDeviceRule = (rule => {
  return function (params) {
    // for vendorless (core) storage, do not enforce rules unless strictStorageEnforcement is set
    if (params[_src_activities_params_js__WEBPACK_IMPORTED_MODULE_6__.ACTIVITY_PARAM_COMPONENT_TYPE] === _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_0__.MODULE_TYPE_PREBID && !strictStorageEnforcement) return;
    return rule(params);
  };
})(singlePurposeGdprRule(1, storageBlocked));
const syncUserRule = singlePurposeGdprRule(1, storageBlocked);
const enrichEidsRule = singlePurposeGdprRule(1, storageBlocked);
const fetchBidsRule = exceptPrebidModules(singlePurposeGdprRule(2, biddersBlocked));
const reportAnalyticsRule = singlePurposeGdprRule(7, analyticsBlocked, params => getGvlidFromAnalyticsAdapter(params[_src_activities_params_js__WEBPACK_IMPORTED_MODULE_6__.ACTIVITY_PARAM_COMPONENT_NAME], params[_src_activities_params_js__WEBPACK_IMPORTED_MODULE_6__.ACTIVITY_PARAM_ANL_CONFIG]));
const ufpdRule = singlePurposeGdprRule(4, ufpdBlocked);
const transmitEidsRule = exceptPrebidModules((() => {
  // Transmit EID special case:
  // by default, legal basis or vendor exceptions for any purpose between 2 and 10
  // (but disregarding enforcePurpose and enforceVendor config) is enough to allow EIDs through
  function check2to10Consent(consentData, modName, gvlId) {
    for (let pno = 2; pno <= 10; pno++) {
      if (ACTIVE_RULES.purpose[pno]?.vendorExceptions?.includes(modName)) {
        return true;
      }
      const {
        purpose,
        vendor
      } = getConsent(consentData, 'purpose', pno, gvlId);
      if (purpose && (vendor || ACTIVE_RULES.purpose[pno]?.softVendorExceptions?.includes(modName))) {
        return true;
      }
    }
    return false;
  }
  const defaultBehavior = gdprRule('2-10', check2to10Consent, eidsBlocked);
  const p4Behavior = singlePurposeGdprRule(4, eidsBlocked);
  return function () {
    const fn = ACTIVE_RULES.purpose[4]?.eidsRequireP4Consent ? p4Behavior : defaultBehavior;
    return fn.apply(this, arguments);
  };
})());
const transmitPreciseGeoRule = gdprRule('Special Feature 1', (cd, modName, gvlId) => validateRules(ACTIVE_RULES.feature[1], cd, modName, gvlId), geoBlocked);

/**
 * Compiles the TCF2.0 enforcement results into an object, which is emitted as an event payload to "tcf2Enforcement" event.
 */
function emitTCF2FinalResults() {
  // remove null and duplicate values
  const formatSet = function (st) {
    return Array.from(st.keys()).filter(el => el != null);
  };
  const tcf2FinalResults = {
    storageBlocked: formatSet(storageBlocked),
    biddersBlocked: formatSet(biddersBlocked),
    analyticsBlocked: formatSet(analyticsBlocked),
    ufpdBlocked: formatSet(ufpdBlocked),
    eidsBlocked: formatSet(eidsBlocked),
    geoBlocked: formatSet(geoBlocked)
  };
  _src_events_js__WEBPACK_IMPORTED_MODULE_7__.emit(_src_constants_js__WEBPACK_IMPORTED_MODULE_8__.EVENTS.TCF2_ENFORCEMENT, tcf2FinalResults);
  [storageBlocked, biddersBlocked, analyticsBlocked, ufpdBlocked, eidsBlocked, geoBlocked].forEach(el => el.clear());
}
_src_events_js__WEBPACK_IMPORTED_MODULE_7__.on(_src_constants_js__WEBPACK_IMPORTED_MODULE_8__.EVENTS.AUCTION_END, emitTCF2FinalResults);

/**
 * A configuration function that initializes some module variables, as well as adds hooks
 * @param {Object} config - GDPR enforcement config object
 */
function setEnforcementConfig(config) {
  let rules = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(config, 'gdpr.rules');
  if (!rules) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)('TCF2: enforcing P1 and P2 by default');
  }
  rules = Object.fromEntries((rules || []).map(r => [r.purpose, r]));
  strictStorageEnforcement = !!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"])(config, STRICT_STORAGE_ENFORCEMENT);
  Object.entries(CONFIGURABLE_RULES).forEach(_ref => {
    let [name, opts] = _ref;
    ACTIVE_RULES[opts.type][opts.id] = rules[name] ?? opts.default;
  });
  if (!hooksAdded) {
    if (ACTIVE_RULES.purpose[1] != null) {
      hooksAdded = true;
      RULE_HANDLES.push((0,_src_activities_rules_js__WEBPACK_IMPORTED_MODULE_9__.registerActivityControl)(_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_10__.ACTIVITY_ACCESS_DEVICE, RULE_NAME, accessDeviceRule));
      RULE_HANDLES.push((0,_src_activities_rules_js__WEBPACK_IMPORTED_MODULE_9__.registerActivityControl)(_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_10__.ACTIVITY_SYNC_USER, RULE_NAME, syncUserRule));
      RULE_HANDLES.push((0,_src_activities_rules_js__WEBPACK_IMPORTED_MODULE_9__.registerActivityControl)(_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_10__.ACTIVITY_ENRICH_EIDS, RULE_NAME, enrichEidsRule));
    }
    if (ACTIVE_RULES.purpose[2] != null) {
      RULE_HANDLES.push((0,_src_activities_rules_js__WEBPACK_IMPORTED_MODULE_9__.registerActivityControl)(_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_10__.ACTIVITY_FETCH_BIDS, RULE_NAME, fetchBidsRule));
    }
    if (ACTIVE_RULES.purpose[4] != null) {
      RULE_HANDLES.push((0,_src_activities_rules_js__WEBPACK_IMPORTED_MODULE_9__.registerActivityControl)(_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_10__.ACTIVITY_TRANSMIT_UFPD, RULE_NAME, ufpdRule), (0,_src_activities_rules_js__WEBPACK_IMPORTED_MODULE_9__.registerActivityControl)(_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_10__.ACTIVITY_ENRICH_UFPD, RULE_NAME, ufpdRule));
    }
    if (ACTIVE_RULES.purpose[7] != null) {
      RULE_HANDLES.push((0,_src_activities_rules_js__WEBPACK_IMPORTED_MODULE_9__.registerActivityControl)(_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_10__.ACTIVITY_REPORT_ANALYTICS, RULE_NAME, reportAnalyticsRule));
    }
    if (ACTIVE_RULES.feature[1] != null) {
      RULE_HANDLES.push((0,_src_activities_rules_js__WEBPACK_IMPORTED_MODULE_9__.registerActivityControl)(_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_10__.ACTIVITY_TRANSMIT_PRECISE_GEO, RULE_NAME, transmitPreciseGeoRule));
    }
    RULE_HANDLES.push((0,_src_activities_rules_js__WEBPACK_IMPORTED_MODULE_9__.registerActivityControl)(_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_10__.ACTIVITY_TRANSMIT_EIDS, RULE_NAME, transmitEidsRule));
  }
}
function uninstall() {
  while (RULE_HANDLES.length) RULE_HANDLES.pop()();
  hooksAdded = false;
}
_src_config_js__WEBPACK_IMPORTED_MODULE_1__.config.getConfig('consentManagement', config => setEnforcementConfig(config.consentManagement));
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_11__.registerModule)('tcfControl');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/tcfControl.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["topicsFpdModule"],{

/***/ "./modules/topicsFpdModule.js":
/*!************************************!*\
  !*** ./modules/topicsFpdModule.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports reset, coreStorage, topicStorageName, lastUpdated, getTopicsData, getTopics, processFpd, getCachedTopics, receiveMessage, storeInLocalStorage, loadTopicsForBidders */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_refererDetection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/refererDetection.js */ "./src/refererDetection.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_storageManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/storageManager.js */ "./src/storageManager.js");
/* harmony import */ var _src_activities_rules_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/activities/rules.js */ "./src/activities/rules.js");
/* harmony import */ var _src_activities_activities_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/activities/activities.js */ "./src/activities/activities.js");
/* harmony import */ var _src_activities_activityParams_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/activities/activityParams.js */ "./src/activities/activityParams.js");
/* harmony import */ var _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/activities/modules.js */ "./src/activities/modules.js");











const MODULE_NAME = 'topicsFpd';
const DEFAULT_EXPIRATION_DAYS = 21;
const DEFAULT_FETCH_RATE_IN_DAYS = 1;
let LOAD_TOPICS_INITIALISE = false;
let iframeLoadedURL = [];
function reset() {
  LOAD_TOPICS_INITIALISE = false;
  iframeLoadedURL = [];
}
const coreStorage = (0,_src_storageManager_js__WEBPACK_IMPORTED_MODULE_0__.getCoreStorageManager)(MODULE_NAME);
const topicStorageName = 'prebid:topics';
const lastUpdated = 'lastUpdated';
const TAXONOMIES = {
  // map from topic taxonomyVersion to IAB segment taxonomy
  '1': 600,
  '2': 601,
  '3': 602,
  '4': 603
};
function partitionBy(field, items) {
  return items.reduce((partitions, item) => {
    const key = item[field];
    if (!partitions.hasOwnProperty(key)) partitions[key] = [];
    partitions[key].push(item);
    return partitions;
  }, {});
}

/**
 * function to get list of loaded Iframes calling Topics API
 */
function getLoadedIframeURL() {
  return iframeLoadedURL;
}

/**
 * function to set/push iframe in the list which is loaded to called topics API.
 */
function setLoadedIframeURL(url) {
  return iframeLoadedURL.push(url);
}
function getTopicsData(name, topics) {
  let taxonomies = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TAXONOMIES;
  return Object.entries(partitionBy('taxonomyVersion', topics)).filter(_ref => {
    let [taxonomyVersion] = _ref;
    if (!taxonomies.hasOwnProperty(taxonomyVersion)) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Unrecognized taxonomyVersion from Topics API: "${taxonomyVersion}"; topic will be ignored`);
      return false;
    }
    return true;
  }).flatMap(_ref2 => {
    let [taxonomyVersion, topics] = _ref2;
    return Object.entries(partitionBy('modelVersion', topics)).map(_ref3 => {
      let [modelVersion, topics] = _ref3;
      const datum = {
        ext: {
          segtax: taxonomies[taxonomyVersion],
          segclass: modelVersion
        },
        segment: topics.map(topic => ({
          id: topic.topic.toString()
        }))
      };
      if (name != null) {
        datum.name = name;
      }
      return datum;
    });
  });
}
function isTopicsSupported() {
  let doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  return 'browsingTopics' in doc && doc.featurePolicy.allowsFeature('browsing-topics');
}
function getTopics() {
  let doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  let topics = null;
  try {
    if (isTopicsSupported(doc)) {
      topics = _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_2__.PbPromise.resolve(doc.browsingTopics());
    }
  } catch (e) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logError)('Could not call topics API', e);
  }
  if (topics == null) {
    topics = _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_2__.PbPromise.resolve([]);
  }
  return topics;
}
const topicsData = getTopics().then(topics => getTopicsData((0,_src_refererDetection_js__WEBPACK_IMPORTED_MODULE_3__.getRefererInfo)().domain, topics));
function processFpd(config, _ref4) {
  let {
    global
  } = _ref4;
  let {
    data = topicsData
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (!LOAD_TOPICS_INITIALISE) {
    loadTopicsForBidders();
    LOAD_TOPICS_INITIALISE = true;
  }
  return data.then(data => {
    data = [].concat(data, getCachedTopics()); // Add cached data in FPD data.
    if (data.length) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeDeep)(global, {
        user: {
          data
        }
      });
    }
    return {
      global
    };
  });
}

/**
 * function to fetch the cached topic data from storage for bidders and return it
 */
function getCachedTopics() {
  let cachedTopicData = [];
  const topics = _src_config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('userSync.topics');
  const bidderList = topics?.bidders || [];
  let storedSegments = new Map((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.safeJSONParse)(coreStorage.getDataFromLocalStorage(topicStorageName)));
  storedSegments && storedSegments.forEach((value, cachedBidder) => {
    // Check bidder exist in config for cached bidder data and then only retrieve the cached data
    let bidderConfigObj = bidderList.find(_ref5 => {
      let {
        bidder
      } = _ref5;
      return cachedBidder === bidder;
    });
    if (bidderConfigObj && (0,_src_activities_rules_js__WEBPACK_IMPORTED_MODULE_5__.isActivityAllowed)(_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_6__.ACTIVITY_ENRICH_UFPD, (0,_src_activities_activityParams_js__WEBPACK_IMPORTED_MODULE_7__.activityParams)(_src_activities_modules_js__WEBPACK_IMPORTED_MODULE_8__.MODULE_TYPE_BIDDER, cachedBidder))) {
      if (!isCachedDataExpired(value[lastUpdated], bidderConfigObj?.expiry || DEFAULT_EXPIRATION_DAYS)) {
        Object.keys(value).forEach(segData => {
          segData !== lastUpdated && cachedTopicData.push(value[segData]);
        });
      } else {
        // delete the specific bidder map from the store and store the updated maps
        storedSegments.delete(cachedBidder);
        coreStorage.setDataInLocalStorage(topicStorageName, JSON.stringify([...storedSegments]));
      }
    }
  });
  return cachedTopicData;
}

/**
 * Receive messages from iframe loaded for bidders to fetch topic
 * @param {MessageEvent} evt
 */
function receiveMessage(evt) {
  if (evt && evt.data) {
    try {
      let data = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.safeJSONParse)(evt.data);
      if (getLoadedIframeURL().includes(evt.origin) && data && data.segment && !(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(data.segment.topics)) {
        const {
          domain,
          topics,
          bidder
        } = data.segment;
        const iframeTopicsData = getTopicsData(domain, topics);
        iframeTopicsData && storeInLocalStorage(bidder, iframeTopicsData);
      }
    } catch (err) {}
  }
}

/**
Function to store Topics data received from iframe in storage(name: "prebid:topics")
 * @param {string} bidder
 * @param {object} topics
 */
function storeInLocalStorage(bidder, topics) {
  const storedSegments = new Map((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.safeJSONParse)(coreStorage.getDataFromLocalStorage(topicStorageName)));
  const topicsObj = {
    [lastUpdated]: new Date().getTime()
  };
  topics.forEach(topic => {
    topicsObj[topic.ext.segclass] = topic;
  });
  storedSegments.set(bidder, topicsObj);
  coreStorage.setDataInLocalStorage(topicStorageName, JSON.stringify([...storedSegments]));
}
function isCachedDataExpired(storedTime, cacheTime) {
  const _MS_PER_DAY = 1000 * 60 * 60 * 24;
  const currentTime = new Date().getTime();
  const daysDifference = Math.ceil((currentTime - storedTime) / _MS_PER_DAY);
  return daysDifference > cacheTime;
}

/**
 * Function to get random bidders based on count passed with array of bidders
 */
function getRandomBidders(arr, count) {
  return [...arr].sort(() => 0.5 - Math.random()).slice(0, count);
}

/**
 * function to add listener for message receiving from IFRAME
 */
function listenMessagesFromTopicIframe() {
  window.addEventListener('message', receiveMessage, false);
}

/**
 * function to load the iframes of the bidder to load the topics data
 */
function loadTopicsForBidders() {
  let doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  if (!isTopicsSupported(doc)) return;
  const topics = _src_config_js__WEBPACK_IMPORTED_MODULE_4__.config.getConfig('userSync.topics');
  if (topics) {
    listenMessagesFromTopicIframe();
    const randomBidders = getRandomBidders(topics.bidders || [], topics.maxTopicCaller || 1);
    randomBidders && randomBidders.forEach(_ref6 => {
      let {
        bidder,
        iframeURL,
        fetchUrl,
        fetchRate
      } = _ref6;
      if (bidder && iframeURL) {
        let ifrm = doc.createElement('iframe');
        ifrm.name = 'ifrm_'.concat(bidder);
        ifrm.src = ''.concat(iframeURL, '?bidder=').concat(bidder);
        ifrm.style.display = 'none';
        setLoadedIframeURL(new URL(iframeURL).origin);
        iframeURL && doc.documentElement.appendChild(ifrm);
      }
      if (bidder && fetchUrl) {
        let storedSegments = new Map((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.safeJSONParse)(coreStorage.getDataFromLocalStorage(topicStorageName)));
        const bidderLsEntry = storedSegments.get(bidder);
        if (!bidderLsEntry || bidderLsEntry && isCachedDataExpired(bidderLsEntry[lastUpdated], fetchRate || DEFAULT_FETCH_RATE_IN_DAYS)) {
          window.fetch(`${fetchUrl}?bidder=${bidder}`, {
            browsingTopics: true
          }).then(response => {
            return response.json();
          }).then(data => {
            if (data && data.segment && !(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(data.segment.topics)) {
              const {
                domain,
                topics,
                bidder
              } = data.segment;
              const fetchTopicsData = getTopicsData(domain, topics);
              fetchTopicsData && storeInLocalStorage(bidder, fetchTopicsData);
            }
          });
        }
      }
    });
  } else {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_1__.logWarn)(`Topics config not defined under userSync Object`);
  }
}
(0,_src_hook_js__WEBPACK_IMPORTED_MODULE_9__.submodule)('firstPartyData', {
  name: 'topics',
  queue: 1,
  processFpd
});
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_10__.registerModule)('topicsFpdModule');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/topicsFpdModule.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["topLevelPaapi"],{

/***/ "./modules/topLevelPaapi.js":
/*!**********************************!*\
  !*** ./modules/topLevelPaapi.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports getRenderingDataHook, markWinningBidHook, parsePaapiSize, getPaapiAdId, parsePaapiAdId, getPAAPIBids, topLevelPAAPI */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/hook.js */ "./src/hook.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/config.js */ "./src/config.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/utils.js */ "./src/utils.js");
/* harmony import */ var _libraries_weakStore_weakStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libraries/weakStore/weakStore.js */ "./libraries/weakStore/weakStore.js");
/* harmony import */ var _src_events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/events.js */ "./src/events.js");
/* harmony import */ var _src_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/constants.js */ "./src/constants.js");
/* harmony import */ var _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _src_adRendering_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/adRendering.js */ "./src/adRendering.js");










let getPAAPIConfig, expandFilters, moduleConfig;
const paapiBids = (0,_libraries_weakStore_weakStore_js__WEBPACK_IMPORTED_MODULE_0__.auctionStore)();
const MODULE_NAME = 'topLevelPaapi';
_src_config_js__WEBPACK_IMPORTED_MODULE_1__.config.getConfig('paapi', cfg => {
  moduleConfig = cfg.paapi?.topLevelSeller;
  if (moduleConfig) {
    _src_adRendering_js__WEBPACK_IMPORTED_MODULE_2__.getBidToRender.before(renderPaapiHook);
    _src_adRendering_js__WEBPACK_IMPORTED_MODULE_2__.getBidToRender.after(renderOverrideHook);
    _src_adRendering_js__WEBPACK_IMPORTED_MODULE_2__.getRenderingData.before(getRenderingDataHook);
    _src_adRendering_js__WEBPACK_IMPORTED_MODULE_2__.markWinningBid.before(markWinningBidHook);
  } else {
    _src_adRendering_js__WEBPACK_IMPORTED_MODULE_2__.getBidToRender.getHooks({
      hook: renderPaapiHook
    }).remove();
    _src_adRendering_js__WEBPACK_IMPORTED_MODULE_2__.getBidToRender.getHooks({
      hook: renderOverrideHook
    }).remove();
    _src_adRendering_js__WEBPACK_IMPORTED_MODULE_2__.getRenderingData.getHooks({
      hook: getRenderingDataHook
    }).remove();
    _src_adRendering_js__WEBPACK_IMPORTED_MODULE_2__.markWinningBid.getHooks({
      hook: markWinningBidHook
    }).remove();
  }
});
function isPaapiBid(bid) {
  return bid?.source === 'paapi';
}
function bidIfRenderable(bid) {
  if (bid && !bid.urn) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(MODULE_NAME, 'rendering in fenced frames is not supported. Consider using resolveToConfig: false', bid);
    return;
  }
  return bid;
}
const forRenderStack = [];
function renderPaapiHook(next, adId) {
  let forRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  let override = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_4__.PbPromise.resolve();
  forRenderStack.push(forRender);
  const ids = parsePaapiAdId(adId);
  if (ids) {
    override = override.then(bid => {
      if (bid) return bid;
      const [auctionId, adUnitCode] = ids;
      return paapiBids(auctionId)?.[adUnitCode]?.then(bid => {
        if (!bid) {
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logWarn)(MODULE_NAME, `No PAAPI bid found for auctionId: "${auctionId}", adUnit: "${adUnitCode}"`);
        }
        return bidIfRenderable(bid);
      });
    });
  }
  next(adId, forRender, override);
}
function renderOverrideHook(next, bidPm) {
  const forRender = forRenderStack.pop();
  if (moduleConfig?.overrideWinner) {
    bidPm = bidPm.then(bid => {
      if (isPaapiBid(bid) || bid?.status === _src_constants_js__WEBPACK_IMPORTED_MODULE_5__.BID_STATUS.RENDERED) return bid;
      return getPAAPIBids({
        adUnitCode: bid.adUnitCode
      }).then(res => {
        let paapiBid = bidIfRenderable(res[bid.adUnitCode]);
        if (paapiBid) {
          if (!forRender) return paapiBid;
          if (forRender && paapiBid.status !== _src_constants_js__WEBPACK_IMPORTED_MODULE_5__.BID_STATUS.RENDERED) {
            paapiBid.overriddenAdId = bid.adId;
            (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logInfo)(MODULE_NAME, 'overriding contextual bid with PAAPI bid', bid, paapiBid);
            return paapiBid;
          }
        }
        return bid;
      });
    });
  }
  next(bidPm);
}
function getRenderingDataHook(next, bid, options) {
  if (isPaapiBid(bid)) {
    next.bail({
      width: bid.width,
      height: bid.height,
      adUrl: bid.urn
    });
  } else {
    next(bid, options);
  }
}
function markWinningBidHook(next, bid) {
  if (isPaapiBid(bid)) {
    (0,_src_events_js__WEBPACK_IMPORTED_MODULE_6__.emit)(_src_constants_js__WEBPACK_IMPORTED_MODULE_5__.EVENTS.BID_WON, bid);
    next.bail();
  } else {
    next(bid);
  }
}
function getBaseAuctionConfig() {
  if (moduleConfig?.auctionConfig) {
    return Object.assign({
      resolveToConfig: false
    }, moduleConfig.auctionConfig);
  }
}
function onAuctionConfig(auctionId, auctionConfigs) {
  const base = getBaseAuctionConfig();
  if (base) {
    Object.entries(auctionConfigs).forEach(_ref => {
      let [adUnitCode, auctionConfig] = _ref;
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.mergeDeep)(auctionConfig, base);
      if (moduleConfig.autorun ?? true) {
        getPAAPIBids({
          adUnitCode,
          auctionId
        });
      }
    });
  }
}
function parsePaapiSize(size) {
  /* From https://github.com/WICG/turtledove/blob/main/FLEDGE.md#12-interest-group-attributes:
   *  Each size has the format {width: widthVal, height: heightVal},
   *  where the values can have either pixel units (e.g. 100 or '100px') or screen dimension coordinates (e.g. 100sw or 100sh).
   */
  if (typeof size === 'number') return size;
  if (typeof size === 'string') {
    const px = /^(\d+)(px)?$/.exec(size)?.[1];
    if (px) {
      return parseInt(px, 10);
    }
  }
  return null;
}
function getPaapiAdId(auctionId, adUnitCode) {
  return `paapi:/${auctionId.replace(/:/g, '::')}/:/${adUnitCode.replace(/:/g, '::')}`;
}
function parsePaapiAdId(adId) {
  const match = /^paapi:\/(.*)\/:\/(.*)$/.exec(adId);
  if (match) {
    return [match[1], match[2]].map(s => s.replace(/::/g, ':'));
  }
}

/**
 * Returns the PAAPI runAdAuction result for the given filters, as a map from ad unit code to auction result
 * (an object with `width`, `height`, and one of `urn` or `frameConfig`).
 *
 * @param filters
 * @param raa
 * @return {Promise<{[p: string]: any}>}
 */
function getPAAPIBids(filters) {
  let raa = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
    return navigator.runAdAuction(...arguments);
  };
  return Promise.all(Object.entries(expandFilters(filters)).map(_ref2 => {
    let [adUnitCode, auctionId] = _ref2;
    const bids = paapiBids(auctionId);
    if (bids && !bids.hasOwnProperty(adUnitCode)) {
      const auctionConfig = getPAAPIConfig({
        adUnitCode,
        auctionId
      })[adUnitCode];
      if (auctionConfig) {
        (0,_src_events_js__WEBPACK_IMPORTED_MODULE_6__.emit)(_src_constants_js__WEBPACK_IMPORTED_MODULE_5__.EVENTS.RUN_PAAPI_AUCTION, {
          auctionId,
          adUnitCode,
          auctionConfig
        });
        bids[adUnitCode] = new Promise((resolve, reject) => raa(auctionConfig).then(resolve, reject)).then(result => {
          if (result) {
            const bid = {
              source: 'paapi',
              adId: getPaapiAdId(auctionId, adUnitCode),
              width: parsePaapiSize(auctionConfig.requestedSize?.width),
              height: parsePaapiSize(auctionConfig.requestedSize?.height),
              adUnitCode,
              auctionId,
              [typeof result === 'string' ? 'urn' : 'frameConfig']: result,
              auctionConfig
            };
            (0,_src_events_js__WEBPACK_IMPORTED_MODULE_6__.emit)(_src_constants_js__WEBPACK_IMPORTED_MODULE_5__.EVENTS.PAAPI_BID, bid);
            return bid;
          } else {
            (0,_src_events_js__WEBPACK_IMPORTED_MODULE_6__.emit)(_src_constants_js__WEBPACK_IMPORTED_MODULE_5__.EVENTS.PAAPI_NO_BID, {
              auctionId,
              adUnitCode,
              auctionConfig
            });
            return null;
          }
        }).catch(error => {
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_3__.logError)(MODULE_NAME, `error (auction "${auctionId}", adUnit "${adUnitCode}"):`, error);
          (0,_src_events_js__WEBPACK_IMPORTED_MODULE_6__.emit)(_src_constants_js__WEBPACK_IMPORTED_MODULE_5__.EVENTS.PAAPI_ERROR, {
            auctionId,
            adUnitCode,
            error,
            auctionConfig
          });
          return null;
        });
      }
    }
    return bids?.[adUnitCode]?.then(res => [adUnitCode, res]);
  }).filter(e => e)).then(result => Object.fromEntries(result));
}
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_7__.getGlobal)().getPAAPIBids = filters => getPAAPIBids(filters);
const topLevelPAAPI = {
  name: MODULE_NAME,
  init(params) {
    getPAAPIConfig = params.getPAAPIConfig;
    expandFilters = params.expandFilters;
  },
  onAuctionConfig
};
(0,_src_hook_js__WEBPACK_IMPORTED_MODULE_8__.submodule)('paapi', topLevelPAAPI);
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_7__.registerModule)('topLevelPaapi');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["weakStore","chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/topLevelPaapi.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

"use strict";
(self["pbjsChunk"] = self["pbjsChunk"] || []).push([["userId"],{

/***/ "./modules/userId/eids.js":
/*!********************************!*\
  !*** ./modules/userId/eids.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EID_CONFIG: () => (/* binding */ EID_CONFIG),
/* harmony export */   getEids: () => (/* binding */ getEids)
/* harmony export */ });
/* unused harmony export createEidsArray */
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");


/**
 * @typedef {import('./index.js').SubmodulePriorityMap} SubmodulePriorityMap
 */

const EID_CONFIG = new Map();

// this function will create an eid object for the given UserId sub-module
function createEidObject(userIdData, subModuleKey, eidConf) {
  if (eidConf && userIdData) {
    let eid = {};
    eid.source = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFn)(eidConf['getSource']) ? eidConf['getSource'](userIdData) : eidConf['source'];
    const value = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFn)(eidConf['getValue']) ? eidConf['getValue'](userIdData) : userIdData;
    if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr)(value)) {
      const uid = {
        id: value,
        atype: eidConf['atype']
      };
      // getUidExt
      if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFn)(eidConf['getUidExt'])) {
        const uidExt = eidConf['getUidExt'](userIdData);
        if (uidExt) {
          uid.ext = uidExt;
        }
      }
      eid.uids = [uid];
      if (eidConf['inserter'] || (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFn)(eidConf['getInserter'])) {
        const inserter = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFn)(eidConf['getInserter']) ? eidConf['getInserter'](userIdData) : eidConf['inserter'];
        if (inserter != null) {
          eid.inserter = inserter;
        }
      }
      if (eidConf['matcher'] || (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFn)(eidConf['getMatcher'])) {
        const matcher = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFn)(eidConf['getMatcher']) ? eidConf['getMatcher'](userIdData) : eidConf['matcher'];
        if (matcher != null) {
          eid.matcher = matcher;
        }
      }
      if (eidConf['mm'] != null) {
        eid.mm = eidConf['mm'];
      }
      // getEidExt
      if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFn)(eidConf['getEidExt'])) {
        const eidExt = eidConf['getEidExt'](userIdData);
        if (eidExt) {
          eid.ext = eidExt;
        }
      }
      return eid;
    }
  }
  return null;
}
function createEidsArray(bidRequestUserId) {
  let eidConfigs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EID_CONFIG;
  const allEids = {};
  function collect(eid) {
    const key = JSON.stringify([eid.source?.toLowerCase(), ...Object.keys(eid).filter(k => !['uids', 'source'].includes(k)).sort().map(k => eid[k])]);
    if (allEids.hasOwnProperty(key)) {
      allEids[key].uids.push(...eid.uids);
    } else {
      allEids[key] = eid;
    }
  }
  Object.entries(bidRequestUserId).forEach(_ref => {
    let [name, values] = _ref;
    values = Array.isArray(values) ? values : [values];
    const eidConf = eidConfigs.get(name);
    let eids;
    if (name === 'pubProvidedId') {
      eids = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.deepClone)(values);
    } else if (typeof eidConf === 'function') {
      try {
        eids = eidConf(values);
        if (!Array.isArray(eids)) {
          eids = [eids];
        }
        eids.forEach(eid => eid.uids = eid.uids.filter(_ref2 => {
          let {
            id
          } = _ref2;
          return (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.isStr)(id);
        }));
        eids = eids.filter(_ref3 => {
          let {
            uids
          } = _ref3;
          return uids?.length > 0;
        });
      } catch (e) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_0__.logError)(`Could not generate EID for "${name}"`, e);
      }
    } else {
      eids = values.map(value => createEidObject(value, name, eidConf));
    }
    if (Array.isArray(eids)) {
      eids.filter(eid => eid != null).forEach(collect);
    }
  });
  return Object.values(allEids);
}

/**
 * @param {SubmodulePriorityMap} priorityMap
 */
function getEids(priorityMap) {
  const eidConfigs = new Map();
  const idValues = {};
  Object.entries(priorityMap).forEach(_ref4 => {
    let [key, getActiveModule] = _ref4;
    const submodule = getActiveModule();
    if (submodule) {
      idValues[key] = submodule.idObj[key];
      let eidConf = submodule.submodule.eids?.[key];
      if (typeof eidConf === 'function') {
        // if eid config is given as a function, append the active module configuration to its args
        eidConf = (orig => function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return orig(...args, submodule.config);
        })(eidConf);
      }
      eidConfigs.set(key, eidConf);
    }
  });
  return createEidsArray(idValues, eidConfigs);
}

/***/ }),

/***/ "./modules/userId/index.js":
/*!*********************************!*\
  !*** ./modules/userId/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports PBJS_USER_ID_OPTOUT_NAME, coreStorage, dep, syncDelay, auctionDelay, setSubmoduleRegistry, setStoredValue, deleteStoredValue, enrichEids, addIdData, startAuctionHook, addUserIdsHook, getConsentHash, getValidSubmoduleConfigs, requestDataDeletion, attachIdSystem, init, resetUserIds */
/* harmony import */ var _src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../src/prebidGlobal.js */ "./src/prebidGlobal.js");
/* harmony import */ var _src_config_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../src/config.js */ "./src/config.js");
/* harmony import */ var _src_events_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../src/events.js */ "./src/events.js");
/* harmony import */ var _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../src/adapterManager.js */ "./src/adapterManager.js");
/* harmony import */ var _src_constants_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../src/constants.js */ "./src/constants.js");
/* harmony import */ var _src_hook_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../src/hook.js */ "./src/hook.js");
/* harmony import */ var _eids_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./eids.js */ "./modules/userId/eids.js");
/* harmony import */ var _src_storageManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/storageManager.js */ "./src/storageManager.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../src/utils.js */ "./src/utils.js");
/* harmony import */ var _src_utils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../src/utils.js */ "./node_modules/dset/dist/index.mjs");
/* harmony import */ var _src_adserver_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../src/adserver.js */ "./src/adserver.js");
/* harmony import */ var _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../src/utils/promise.js */ "./src/utils/promise.js");
/* harmony import */ var _src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/utils/perfMetrics.js */ "./src/utils/perfMetrics.js");
/* harmony import */ var _src_fpd_rootDomain_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../src/fpd/rootDomain.js */ "./src/fpd/rootDomain.js");
/* harmony import */ var _src_consentHandler_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../src/consentHandler.js */ "./src/consentHandler.js");
/* harmony import */ var _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../src/activities/modules.js */ "./src/activities/modules.js");
/* harmony import */ var _src_activities_rules_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/activities/rules.js */ "./src/activities/rules.js");
/* harmony import */ var _src_activities_activities_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../src/activities/activities.js */ "./src/activities/activities.js");
/* harmony import */ var _src_activities_activityParams_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../src/activities/activityParams.js */ "./src/activities/activityParams.js");
/* harmony import */ var _src_userSync_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../src/userSync.js */ "./src/userSync.js");
/* harmony import */ var _src_prebid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/prebid.js */ "./src/prebid.js");

/**
 * This module adds User ID support to prebid.js
 * @module modules/userId
 */

/**
 * @typedef Submodule
 * @property {string} name - used to link submodule with config
 * @property {decode} decode
 * @property {getId} getId
 * @property {Object} eids
 * @property {number} [gvlid] - vendor ID
 * @property {extendId} [extendId]
 * @property {function} [domainOverride] - use a predefined domain override for cookies or provide your own
 * @property {function(): string} [findRootDomain] - returns the root domain
 */

/**
 * Performs action to obtain id and return a value in the callback's response argument.
 * If IdResponse#id is defined, then it will be written to the current active storage.
 * If IdResponse#callback is defined, then it'll called at the end of auction.
 * It's permissible to return neither, one, or both fields.
 * @callback getId
 * @param {SubmoduleConfig} config
 * @param {ConsentData|undefined} [consentData]
 * @param {Object|undefined} [cacheIdObj]
 * @returns {IdResponse|undefined} A response object that contains id and/or callback.
 */

/**
 * Similar to `getId`, this optional method returns response to for id that exists already.
 * If IdResponse#id is defined, then it will be written to the current active storage even if it exists already.
 * If IdResponse#callback is defined, then it'll called at the end of auction.
 * It's permissible to return neither, one, or both fields.
 * @callback extendId
 * @param {SubmoduleConfig} config
 * @param {ConsentData|undefined} consentData
 * @param {Object} storedId - existing id, if any
 * @returns {IdResponse|function} A response object that contains id and/or callback.
 */

/**
 * Decode a stored value for passing to bid requests
 * @callback decode
 * @param {Object|string} value
 * @param {SubmoduleConfig|undefined} [config]
 * @returns {Object|undefined}
 */

/**
 * @typedef {Object} SubmoduleConfig
 * @property {string} name - the User ID submodule name (used to link submodule with config)
 * @property {(SubmoduleStorage|undefined)} storage - browser storage config
 * @property {(SubmoduleParams|undefined)} params - params config for use by the submodule.getId function
 * @property {(Object|undefined)} value - if not empty, this value is added to bid requests for access in adapters
 * @property {string[]} [enabledStorageTypes]
 */

/**
 * @typedef {Object} SubmoduleStorage
 * @property {string} type - browser storage type (html5 or cookie)
 * @property {string} name - key name to use when saving/reading to local storage or cookies
 * @property {number} expires - time to live for browser storage in days
 * @property {(number|undefined)} refreshInSeconds - if not empty, this value defines the maximum time span in seconds before refreshing user ID stored in browser
 */

/**
 * @typedef {Object} LiveIntentCollectConfig
 * @property {(string|undefined)} fpiStorageStrategy - defines whether the first party identifiers that LiveConnect creates and updates are stored in a cookie jar, local storage, or not created at all
 * @property {(number|undefined)} fpiExpirationDays - the expiration time of an identifier created and updated by LiveConnect
 * @property {(string|undefined)} collectorUrl - defines where the LiveIntentId signal pixels are pointing to
 * @property {(string|undefined)} appId - the  unique identifier of the application in question
 */

/**
 * @typedef {Object} SubmoduleParams
 * @property {(string|undefined)} partner - partner url param value
 * @property {(string|undefined)} url - webservice request url used to load Id data
 * @property {(string|undefined)} pixelUrl - publisher pixel to extend/modify cookies
 * @property {(boolean|undefined)} create - create id if missing.  default is true.
 * @property {(boolean|undefined)} extend - extend expiration time on each access.  default is false.
 * @property {(string|undefined)} pid - placement id url param value
 * @property {(string|undefined)} publisherId - the unique identifier of the publisher in question
 * @property {(string|undefined)} ajaxTimeout - the number of milliseconds a resolution request can take before automatically being terminated
 * @property {(Array|undefined)} identifiersToResolve - the identifiers from either ls|cookie to be attached to the getId query
 * @property {(LiveIntentCollectConfig|undefined)} liCollectConfig - the config for LiveIntent's collect requests
 * @property {(string|undefined)} pd - publisher provided data for reconciling ID5 IDs
 * @property {(string|undefined)} emailHash - if provided, the hashed email address of a user
 * @property {(string|undefined)} notUse3P - use to retrieve envelope from 3p endpoint
 */

/**
 * @typedef {Object} SubmoduleContainer
 * @property {Submodule} submodule
 * @property {SubmoduleConfig} config
 * @property {(Object|undefined)} idObj - cache decoded id value (this is copied to every adUnit bid)
 * @property {(function|undefined)} callback - holds reference to submodule.getId() result if it returned a function. Will be set to undefined after callback executes
 * @property {StorageManager} storageMgr
 * @property {string[]} [enabledStorageTypes]
 */

/**
 * @typedef {Object} ConsentData
 * @property {Object} gdpr
 * @property {Object} gpp
 * @property {Object} usp
 * @property {Object} coppa
 */

/**
 * @typedef {Object} IdResponse
 * @property {Object} [id] - id data
 * @property {function} [callback] - function that will return an id
 */

/**
 * @typedef {{[idKey: string]: () => SubmoduleContainer[]}} SubmodulePriorityMap
 */





















const MODULE_NAME = 'User ID';
const COOKIE = _src_storageManager_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE_TYPE_COOKIES;
const LOCAL_STORAGE = _src_storageManager_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE_TYPE_LOCALSTORAGE;
const PBJS_USER_ID_OPTOUT_NAME = '_pbjs_id_optout';
const coreStorage = (0,_src_storageManager_js__WEBPACK_IMPORTED_MODULE_1__.getCoreStorageManager)('userId');
const dep = {
  isAllowed: _src_activities_rules_js__WEBPACK_IMPORTED_MODULE_2__.isActivityAllowed
};

/** @type {SubmoduleContainer[]} */
let submodules = [];

/** @type {PriorityMaps} */
let initializedSubmodules;

/** @type {SubmoduleConfig[]} */
let configRegistry = [];

/** @type {Object} */
let idPriority = {};

/** @type {Submodule[]} */
let submoduleRegistry = [];

/** @type {(number|undefined)} */
let timeoutID;

/** @type {(number|undefined)} */
let syncDelay;

/** @type {(number|undefined)} */
let auctionDelay;

/** @type {(string|undefined)} */
let ppidSource;
let configListener;
const uidMetrics = (() => {
  let metrics;
  return () => {
    if (metrics == null) {
      metrics = (0,_src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_3__.newMetrics)();
    }
    return metrics;
  };
})();
function submoduleMetrics(moduleName) {
  return uidMetrics().fork().renameWith(n => [`userId.mod.${n}`, `userId.mods.${moduleName}.${n}`]);
}

/** @param {Submodule[]} submodules */
function setSubmoduleRegistry(submodules) {
  submoduleRegistry = submodules;
  updateEIDConfig(submodules);
}
function cookieSetter(submodule, storageMgr) {
  storageMgr = storageMgr || submodule.storageMgr;
  const domainOverride = typeof submodule.submodule.domainOverride === 'function' ? submodule.submodule.domainOverride() : null;
  const name = submodule.config.storage.name;
  return function setCookie(suffix, value, expiration) {
    storageMgr.setCookie(name + (suffix || ''), value, expiration, 'Lax', domainOverride);
  };
}
function setValueInCookie(submodule, valueStr, expiresStr) {
  const storage = submodule.config.storage;
  const setCookie = cookieSetter(submodule);
  setCookie(null, valueStr, expiresStr);
  setCookie('_cst', getConsentHash(), expiresStr);
  if (typeof storage.refreshInSeconds === 'number') {
    setCookie('_last', new Date().toUTCString(), expiresStr);
  }
}
function setValueInLocalStorage(submodule, valueStr, expiresStr) {
  const storage = submodule.config.storage;
  const mgr = submodule.storageMgr;
  mgr.setDataInLocalStorage(`${storage.name}_exp`, expiresStr);
  mgr.setDataInLocalStorage(`${storage.name}_cst`, getConsentHash());
  mgr.setDataInLocalStorage(storage.name, encodeURIComponent(valueStr));
  if (typeof storage.refreshInSeconds === 'number') {
    mgr.setDataInLocalStorage(`${storage.name}_last`, new Date().toUTCString());
  }
}

/**
 * @param {SubmoduleContainer} submodule
 * @param {(Object|string)} value
 */
function setStoredValue(submodule, value) {
  /**
   * @type {SubmoduleStorage}
   */
  const storage = submodule.config.storage;
  try {
    const expiresStr = new Date(Date.now() + storage.expires * (60 * 60 * 24 * 1000)).toUTCString();
    const valueStr = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.isPlainObject)(value) ? JSON.stringify(value) : value;
    submodule.enabledStorageTypes.forEach(storageType => {
      switch (storageType) {
        case COOKIE:
          setValueInCookie(submodule, valueStr, expiresStr);
          break;
        case LOCAL_STORAGE:
          setValueInLocalStorage(submodule, valueStr, expiresStr);
          break;
      }
    });
  } catch (error) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)(error);
  }
}
function deleteValueFromCookie(submodule) {
  const setCookie = cookieSetter(submodule, coreStorage);
  const expiry = new Date(Date.now() - 1000 * 60 * 60 * 24).toUTCString();
  ['', '_last', '_cst'].forEach(suffix => {
    try {
      setCookie(suffix, '', expiry);
    } catch (e) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)(e);
    }
  });
}
function deleteValueFromLocalStorage(submodule) {
  ['', '_last', '_exp', '_cst'].forEach(suffix => {
    try {
      coreStorage.removeDataFromLocalStorage(submodule.config.storage.name + suffix);
    } catch (e) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)(e);
    }
  });
}
function deleteStoredValue(submodule) {
  populateEnabledStorageTypes(submodule);
  submodule.enabledStorageTypes.forEach(storageType => {
    switch (storageType) {
      case COOKIE:
        deleteValueFromCookie(submodule);
        break;
      case LOCAL_STORAGE:
        deleteValueFromLocalStorage(submodule);
        break;
    }
  });
}
function getValueFromCookie(submodule, storedKey) {
  return submodule.storageMgr.getCookie(storedKey);
}
function getValueFromLocalStorage(submodule, storedKey) {
  const mgr = submodule.storageMgr;
  const storage = submodule.config.storage;
  const storedValueExp = mgr.getDataFromLocalStorage(`${storage.name}_exp`);

  // empty string means no expiration set
  if (storedValueExp === '') {
    return mgr.getDataFromLocalStorage(storedKey);
  } else if (storedValueExp && new Date(storedValueExp).getTime() - Date.now() > 0) {
    return decodeURIComponent(mgr.getDataFromLocalStorage(storedKey));
  }
}

/**
 * @param {SubmoduleContainer} submodule
 * @param {String|undefined} key optional key of the value
 * @returns {string}
 */
function getStoredValue(submodule) {
  let key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  const storage = submodule.config.storage;
  const storedKey = key ? `${storage.name}_${key}` : storage.name;
  let storedValue;
  try {
    submodule.enabledStorageTypes.find(storageType => {
      switch (storageType) {
        case COOKIE:
          storedValue = getValueFromCookie(submodule, storedKey);
          break;
        case LOCAL_STORAGE:
          storedValue = getValueFromLocalStorage(submodule, storedKey);
          break;
      }
      return !!storedValue;
    });

    // support storing a string or a stringified object
    if (typeof storedValue === 'string' && storedValue.trim().charAt(0) === '{') {
      storedValue = JSON.parse(storedValue);
    }
  } catch (e) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)(e);
  }
  return storedValue;
}

/**
 * @param {SubmoduleContainer[]} submodules
 * @param {function} cb - callback for after processing is done.
 * @param {PriorityMaps} priorityMaps
 */
function processSubmoduleCallbacks(submodules, cb, priorityMaps) {
  cb = uidMetrics().fork().startTiming('userId.callbacks.total').stopBefore(cb);
  const done = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.delayExecution)(() => {
    clearTimeout(timeoutID);
    cb();
  }, submodules.length);
  submodules.forEach(function (submodule) {
    const moduleDone = submoduleMetrics(submodule.submodule.name).startTiming('callback').stopBefore(done);
    function callbackCompleted(idObj) {
      // if valid, id data should be saved to cookie/html storage
      if (idObj) {
        if (submodule.config.storage) {
          setStoredValue(submodule, idObj);
        }
        // cache decoded value (this is copied to every adUnit bid)
        submodule.idObj = submodule.submodule.decode(idObj, submodule.config);
        priorityMaps.refresh();
        updatePPID(priorityMaps);
      } else {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)(`${MODULE_NAME}: ${submodule.submodule.name} - request id responded with an empty value`);
      }
      moduleDone();
    }
    try {
      submodule.callback(callbackCompleted, getStoredValue.bind(null, submodule));
    } catch (e) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)(`Error in userID module '${submodule.submodule.name}':`, e);
      moduleDone();
    }
    // clear callback, this prop is used to test if all submodule callbacks are complete below
    submodule.callback = undefined;
  });
}

/**
 * @param {SubmodulePriorityMap} priorityMap
 * @returns {{}}
 */
function getIds(priorityMap) {
  return Object.fromEntries(Object.entries(priorityMap).map(_ref => {
    let [key, getActiveModule] = _ref;
    return [key, getActiveModule()?.idObj?.[key]];
  }).filter(_ref2 => {
    let [_, value] = _ref2;
    return value != null;
  }));
}
function getPrimaryIds(submodule) {
  if (submodule.primaryIds) return submodule.primaryIds;
  const ids = Object.keys(submodule.eids ?? {});
  if (ids.length > 1) {
    throw new Error(`ID submodule ${submodule.name} can provide multiple IDs, but does not specify 'primaryIds'`);
  }
  return ids;
}

/**
 * Given a collection of items, where each item maps to any number of IDs (getKeys) and an ID module (getIdMod),
 * return a map from ID key to all items that map to that ID key, in order of priority (highest priority first).
 *
 * @template T
 * @param {T[]} items
 * @param {(item: T) => string[]} getKeys
 * @param {(item: T) => Submodule} getIdMod
 * @returns {{[key: string]: T[]}}
 */
function orderByPriority(items, getKeys, getIdMod) {
  const tally = {};
  items.forEach(item => {
    const module = getIdMod(item);
    const primaryIds = getPrimaryIds(module);
    getKeys(item).forEach(key => {
      const keyItems = tally[key] = tally[key] ?? [];
      const keyPriority = idPriority[key]?.indexOf(module.name) ?? (primaryIds.includes(key) ? 0 : -1);
      const pos = keyItems.findIndex(_ref3 => {
        let [priority] = _ref3;
        return priority < keyPriority;
      });
      keyItems.splice(pos === -1 ? keyItems.length : pos, 0, [keyPriority, item]);
    });
  });
  return Object.fromEntries(Object.entries(tally).map(_ref4 => {
    let [key, items] = _ref4;
    return [key, items.map(_ref5 => {
      let [_, item] = _ref5;
      return item;
    })];
  }));
}

/**
 * @typedef {Object} PriorityMaps
 * @property {SubmoduleContainer[]} submodules all active submodules
 * @property {SubmodulePriorityMap} global priority map for global (not bidder-specific) submodules
 * @property {SubmodulePriorityMap} combined priority map for ALL submodules, disregarding bidder filters
 * @property {{[bidder: string]: SubmodulePriorityMap}} bidder priority maps for each bidder's specific submodules
 * @property {(submodules: SubmoduleContainer[]) => void} refresh refresh priority maps, optionally adding or updating some submodules.
 *    Should be called every time a submodule's ID is updated.
 */

/**
 * @returns PriorityMaps
 */
function mkPriorityMaps() {
  const map = {
    submodules: [],
    global: {},
    bidder: {},
    combined: {},
    /**
     * @param {SubmoduleContainer[]} addtlModules
     */
    refresh() {
      let addtlModules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      const refreshing = new Set(addtlModules.map(mod => mod.submodule));
      map.submodules = map.submodules.filter(mod => !refreshing.has(mod.submodule)).concat(addtlModules);
      update();
    }
  };
  function update() {
    const modulesById = orderByPriority(map.submodules, submod => Object.keys(submod.idObj ?? {}), submod => submod.submodule);
    const global = {};
    const bidder = {};
    function activeModuleGetter(key, useGlobals, modules) {
      return function () {
        for (const {
          allowed,
          bidders,
          module
        } of modules) {
          if (!dep.isAllowed(_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_5__.ACTIVITY_ENRICH_EIDS, (0,_src_activities_activityParams_js__WEBPACK_IMPORTED_MODULE_6__.activityParams)(_src_activities_modules_js__WEBPACK_IMPORTED_MODULE_7__.MODULE_TYPE_UID, module?.config?.name, {
            init: false
          }))) {
            continue;
          }
          const value = module.idObj?.[key];
          if (value != null) {
            if (allowed) {
              return module;
            } else if (useGlobals) {
              // value != null, allowed = false, useGlobals = true:
              // this module has the preferred ID but it cannot be used (because it's restricted to only some bidders
              // and we are calculating global IDs).
              // since we don't (yet) have a way to express "global except for these bidders" in FPD,
              // do not keep looking for alternative IDs in other (lower priority) modules; the ID will be provided only
              // to the bidders this module is configured for.
              const listModules = modules => modules.map(mod => mod.module.submodule.name).join(', ');
              (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logWarn)(`userID modules ${listModules(modules)} provide the same ID ('${key}'); ${module.submodule.name} is the preferred source, but it's configured only for some bidders, unlike ${listModules(modules.filter(mod => mod.bidders == null))}. Other bidders will not see the "${key}" ID.`);
              return null;
            } else if (bidders == null) {
              // value != null, allowed = false, useGlobals = false, bidders == null:
              // this module has the preferred ID but it should not be used because it's not bidder-restricted and
              // we are calculating bidder-specific ids. Do not keep looking in other lower priority modules, as the ID
              // will be set globally.
              return null;
            }
          }
        }
        return null;
      };
    }
    Object.entries(modulesById).forEach(_ref6 => {
      let [key, modules] = _ref6;
      let allNonGlobal = true;
      const bidderFilters = new Set();
      modules = modules.map(module => {
        let bidders = null;
        if (Array.isArray(module.config.bidders) && module.config.bidders.length > 0) {
          bidders = module.config.bidders;
          bidders.forEach(bidder => bidderFilters.add(bidder));
        } else {
          allNonGlobal = false;
        }
        return {
          module,
          bidders
        };
      });
      if (!allNonGlobal) {
        global[key] = activeModuleGetter(key, true, modules.map(_ref7 => {
          let {
            bidders,
            module
          } = _ref7;
          return {
            allowed: bidders == null,
            bidders,
            module
          };
        }));
      }
      bidderFilters.forEach(bidderCode => {
        bidder[bidderCode] = bidder[bidderCode] ?? {};
        bidder[bidderCode][key] = activeModuleGetter(key, false, modules.map(_ref8 => {
          let {
            bidders,
            module
          } = _ref8;
          return {
            allowed: bidders?.includes(bidderCode),
            bidders,
            module
          };
        }));
      });
    });
    const combined = Object.values(bidder).concat([global]).reduce((combo, map) => Object.assign(combo, map), {});
    Object.assign(map, {
      global,
      bidder,
      combined
    });
  }
  return map;
}
function enrichEids(ortb2Fragments) {
  const {
    global: globalFpd,
    bidder: bidderFpd
  } = ortb2Fragments;
  const {
    global: globalMods,
    bidder: bidderMods
  } = initializedSubmodules;
  const globalEids = (0,_eids_js__WEBPACK_IMPORTED_MODULE_8__.getEids)(globalMods);
  if (globalEids.length > 0) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_9__.dset)(globalFpd, 'user.ext.eids', (globalFpd.user?.ext?.eids ?? []).concat(globalEids));
  }
  Object.entries(bidderMods).forEach(_ref9 => {
    let [bidder, moduleMap] = _ref9;
    const bidderEids = (0,_eids_js__WEBPACK_IMPORTED_MODULE_8__.getEids)(moduleMap);
    if (bidderEids.length > 0) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_9__.dset)(bidderFpd, `${bidder}.user.ext.eids`, (bidderFpd[bidder]?.user?.ext?.eids ?? []).concat(bidderEids));
    }
  });
  return ortb2Fragments;
}
function addIdData(_ref10) {
  let {
    adUnits,
    ortb2Fragments
  } = _ref10;
  ortb2Fragments = ortb2Fragments ?? {
    global: {},
    bidder: {}
  };
  enrichEids(ortb2Fragments);
  if ([adUnits].some(i => !Array.isArray(i) || !i.length)) {
    return;
  }
  const globalIds = getIds(initializedSubmodules.global);
  const globalEids = ortb2Fragments.global.user?.ext?.eids || [];
  adUnits.forEach(adUnit => {
    if (adUnit.bids && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(adUnit.bids)) {
      adUnit.bids.forEach(bid => {
        const bidderIds = Object.assign({}, globalIds, getIds(initializedSubmodules.bidder[bid.bidder] ?? {}));
        const bidderEids = globalEids.concat(ortb2Fragments.bidder?.[bid.bidder]?.user?.ext?.eids || []);
        if (Object.keys(bidderIds).length > 0) {
          bid.userId = bidderIds;
        }
        if (bidderEids.length > 0) {
          bid.userIdAsEids = bidderEids;
        }
      });
    }
  });
}
const INIT_CANCELED = {};
function idSystemInitializer() {
  let {
    mkDelay = _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_10__.delay
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const startInit = (0,_src_utils_promise_js__WEBPACK_IMPORTED_MODULE_10__.defer)();
  const startCallbacks = (0,_src_utils_promise_js__WEBPACK_IMPORTED_MODULE_10__.defer)();
  let cancel;
  let initialized = false;
  let initMetrics;
  function cancelAndTry(promise) {
    initMetrics = uidMetrics().fork();
    if (cancel != null) {
      cancel.reject(INIT_CANCELED);
    }
    cancel = (0,_src_utils_promise_js__WEBPACK_IMPORTED_MODULE_10__.defer)();
    return _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_10__.PbPromise.race([promise, cancel.promise]).finally(initMetrics.startTiming('userId.total'));
  }

  // grab a reference to global vars so that the promise chains remain isolated;
  // multiple calls to `init` (from tests) might otherwise cause them to interfere with each other
  let initModules = initializedSubmodules;
  let allModules = submodules;
  function checkRefs(fn) {
    // unfortunately tests have their own global state that needs to be guarded, so even if we keep ours tidy,
    // we cannot let things like submodule callbacks run (they pollute things like the global `server` XHR mock)
    return function () {
      if (initModules === initializedSubmodules && allModules === submodules) {
        return fn(...arguments);
      }
    };
  }
  function timeConsent() {
    return _src_consentHandler_js__WEBPACK_IMPORTED_MODULE_11__.allConsent.promise.finally(initMetrics.startTiming('userId.init.consent'));
  }
  let done = cancelAndTry(_src_utils_promise_js__WEBPACK_IMPORTED_MODULE_10__.PbPromise.all([_src_hook_js__WEBPACK_IMPORTED_MODULE_12__.ready, startInit.promise]).then(timeConsent).then(checkRefs(() => {
    initSubmodules(initModules, allModules);
  })).then(() => startCallbacks.promise.finally(initMetrics.startTiming('userId.callbacks.pending'))).then(checkRefs(() => {
    const modWithCb = initModules.submodules.filter(item => (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.isFn)(item.callback));
    if (modWithCb.length) {
      return new _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_10__.PbPromise(resolve => processSubmoduleCallbacks(modWithCb, resolve, initModules));
    }
  })));

  /**
   * with `ready` = true, starts initialization; with `refresh` = true, reinitialize submodules (optionally
   * filtered by `submoduleNames`).
   */
  return function () {
    let {
      refresh = false,
      submoduleNames = null,
      ready = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (ready && !initialized) {
      initialized = true;
      startInit.resolve();
      // submodule callbacks should run immediately if `auctionDelay` > 0, or `syncDelay` ms after the
      // auction ends otherwise
      if (auctionDelay > 0) {
        startCallbacks.resolve();
      } else {
        _src_events_js__WEBPACK_IMPORTED_MODULE_13__.on(_src_constants_js__WEBPACK_IMPORTED_MODULE_14__.EVENTS.AUCTION_END, function auctionEndHandler() {
          _src_events_js__WEBPACK_IMPORTED_MODULE_13__.off(_src_constants_js__WEBPACK_IMPORTED_MODULE_14__.EVENTS.AUCTION_END, auctionEndHandler);
          mkDelay(syncDelay).then(startCallbacks.resolve);
        });
      }
    }
    if (refresh && initialized) {
      done = cancelAndTry(done.catch(() => null).then(timeConsent) // fetch again in case a refresh was forced before this was resolved
      .then(checkRefs(() => {
        const cbModules = initSubmodules(initModules, allModules.filter(sm => submoduleNames == null || submoduleNames.includes(sm.submodule.name)), true).filter(sm => {
          return sm.callback != null;
        });
        if (cbModules.length) {
          return new _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_10__.PbPromise(resolve => processSubmoduleCallbacks(cbModules, resolve, initModules));
        }
      })));
    }
    return done;
  };
}
let initIdSystem;
function getPPID() {
  let eids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getUserIdsAsEids() || [];
  // userSync.ppid should be one of the 'source' values in getUserIdsAsEids() eg pubcid.org or id5-sync.com
  const matchingUserId = ppidSource && eids.find(userID => userID.source === ppidSource);
  if (matchingUserId && typeof matchingUserId?.uids?.[0]?.id === 'string') {
    const ppidValue = matchingUserId.uids[0].id.replace(/[\W_]/g, '');
    if (ppidValue.length >= 32 && ppidValue.length <= 150) {
      return ppidValue;
    } else {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logWarn)(`User ID - Googletag Publisher Provided ID for ${ppidSource} is not between 32 and 150 characters - ${ppidValue}`);
    }
  }
}

/**
 * Hook is executed before adapters, but after consentManagement. Consent data is requied because
 * this module requires GDPR consent with Purpose #1 to save data locally.
 * The two main actions handled by the hook are:
 * 1. check gdpr consentData and handle submodule initialization.
 * 2. append user id data (loaded from cookied/html or from the getId method) to bids to be accessed in adapters.
 * @param {Object} reqBidsConfigObj required; This is the same param that's used in pbjs.requestBids.
 * @param {function} fn required; The next function in the chain, used by hook.js
 */
const startAuctionHook = (0,_src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_3__.timedAuctionHook)('userId', function requestBidsHook(fn, reqBidsConfigObj) {
  let {
    mkDelay = _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_10__.delay,
    getIds = getUserIdsAsync
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_10__.PbPromise.race([getIds().catch(() => null), mkDelay(auctionDelay)]).then(() => {
    addIdData(reqBidsConfigObj);
    uidMetrics().join((0,_src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_3__.useMetrics)(reqBidsConfigObj.metrics), {
      propagate: false,
      includeGroups: true
    });
    // calling fn allows prebid to continue processing
    fn.call(this, reqBidsConfigObj);
  });
});

/**
 * Append user id data from config to bids to be accessed in adapters when there are no submodules.
 * @param {function} fn required; The next function in the chain, used by hook.js
 * @param {Object} reqBidsConfigObj required; This is the same param that's used in pbjs.requestBids.
 */
const addUserIdsHook = (0,_src_utils_perfMetrics_js__WEBPACK_IMPORTED_MODULE_3__.timedAuctionHook)('userId', function requestBidsHook(fn, reqBidsConfigObj) {
  addIdData(reqBidsConfigObj);
  // calling fn allows prebid to continue processing
  fn.call(this, reqBidsConfigObj);
});

/**
 * Is startAuctionHook added
 * @returns {boolean}
 */
function addedStartAuctionHook() {
  return !!_src_prebid_js__WEBPACK_IMPORTED_MODULE_0__.startAuction.getHooks({
    hook: startAuctionHook
  }).length;
}

/**
 * This function will be exposed in global-name-space so that userIds stored by Prebid UserId module can be used by external codes as well.
 * Simple use case will be passing these UserIds to A9 wrapper solution
 */
function getUserIds() {
  return getIds(initializedSubmodules.combined);
}

/**
 * This function will be exposed in global-name-space so that userIds stored by Prebid UserId module can be used by external codes as well.
 * Simple use case will be passing these UserIds to A9 wrapper solution
 */
function getUserIdsAsEids() {
  return (0,_eids_js__WEBPACK_IMPORTED_MODULE_8__.getEids)(initializedSubmodules.combined);
}

/**
 * This function will be exposed in global-name-space so that userIds stored by Prebid UserId module can be used by external codes as well.
 * Simple use case will be passing these UserIds to A9 wrapper solution
 */

function getUserIdsAsEidBySource(sourceName) {
  return getUserIdsAsEids().filter(eid => eid.source === sourceName)[0];
}

/**
 * This function will be exposed in global-name-space so that userIds for a source can be exposed
 * Sample use case is exposing this function to ESP
 */
function getEncryptedEidsForSource(source, encrypt, customFunction) {
  return retryOnCancel().then(() => {
    let eidsSignals = {};
    if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.isFn)(customFunction)) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)(`${MODULE_NAME} - Getting encrypted signal from custom function : ${customFunction.name} & source : ${source} `);
      // Publishers are expected to define a common function which will be proxy for signal function.
      const customSignals = customFunction(source);
      eidsSignals[source] = customSignals ? encryptSignals(customSignals) : null; // by default encrypt using base64 to avoid JSON errors
    } else {
      // initialize signal with eids by default
      const eid = getUserIdsAsEidBySource(source);
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)(`${MODULE_NAME} - Getting encrypted signal for eids :${JSON.stringify(eid)}`);
      if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.isEmpty)(eid)) {
        eidsSignals[eid.source] = encrypt === true ? encryptSignals(eid) : eid.uids[0].id; // If encryption is enabled append version (1||) and encrypt entire object
      }
    }
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)(`${MODULE_NAME} - Fetching encrypted eids: ${eidsSignals[source]}`);
    return eidsSignals[source];
  });
}
function encryptSignals(signals) {
  let version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  let encryptedSig = '';
  switch (version) {
    case 1:
      // Base64 Encryption
      encryptedSig = typeof signals === 'object' ? window.btoa(JSON.stringify(signals)) : window.btoa(signals); // Test encryption. To be replaced with better algo
      break;
    default:
      break;
  }
  return `${version}||${encryptedSig}`;
}

/**
 * This function will be exposed in the global-name-space so that publisher can register the signals-ESP.
 */
function registerSignalSources() {
  if (!(0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.isGptPubadsDefined)()) {
    return;
  }
  window.googletag.secureSignalProviders = window.googletag.secureSignalProviders || [];
  const encryptedSignalSources = _src_config_js__WEBPACK_IMPORTED_MODULE_15__.config.getConfig('userSync.encryptedSignalSources');
  if (encryptedSignalSources) {
    const registerDelay = encryptedSignalSources.registerDelay || 0;
    setTimeout(() => {
      encryptedSignalSources['sources'] && encryptedSignalSources['sources'].forEach(_ref11 => {
        let {
          source,
          encrypt,
          customFunc
        } = _ref11;
        source.forEach(src => {
          window.googletag.secureSignalProviders.push({
            id: src,
            collectorFunction: () => getEncryptedEidsForSource(src, encrypt, customFunc)
          });
        });
      });
    }, registerDelay);
  } else {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logWarn)(`${MODULE_NAME} - ESP : encryptedSignalSources config not defined under userSync Object`);
  }
}
function retryOnCancel(initParams) {
  return initIdSystem(initParams).then(() => getUserIds(), e => {
    if (e === INIT_CANCELED) {
      // there's a pending refresh - because GreedyPromise runs this synchronously, we are now in the middle
      // of canceling the previous init, before the refresh logic has had a chance to run.
      // Use a "normal" Promise to clear the stack and let it complete (or this will just recurse infinitely)
      return Promise.resolve().then(getUserIdsAsync);
    } else {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)('Error initializing userId', e);
      return _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_10__.PbPromise.reject(e);
    }
  });
}

/**
 * Force (re)initialization of ID submodules.
 *
 * This will force a refresh of the specified ID submodules regardless of `auctionDelay` / `syncDelay` settings, and
 * return a promise that resolves to the same value as `getUserIds()` when the refresh is complete.
 * If a refresh is already in progress, it will be canceled (rejecting promises returned by previous calls to `refreshUserIds`).
 *
 * @param {string[]} [submoduleNames] submodules to refresh. If omitted, refresh all submodules.
 * @param {Function} [callback] called when the refresh is complete
 */
function refreshUserIds() {
  let {
    submoduleNames
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let callback = arguments.length > 1 ? arguments[1] : undefined;
  return retryOnCancel({
    refresh: true,
    submoduleNames
  }).then(userIds => {
    if (callback && (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.isFn)(callback)) {
      callback();
    }
    return userIds;
  });
}

/**
 * @returns a promise that resolves to the same value as `getUserIds()`, but only once all ID submodules have completed
 * initialization. This can also be used to synchronize calls to other ID accessors, e.g.
 *
 * ```
 * pbjs.getUserIdsAsync().then(() => {
 *   const eids = pbjs.getUserIdsAsEids(); // guaranteed to be completely initialized at this point
 * });
 * ```
 */

function getUserIdsAsync() {
  return retryOnCancel();
}
function getConsentHash() {
  // transform decimal string into base64 to save some space on cookies
  let hash = Number(_src_consentHandler_js__WEBPACK_IMPORTED_MODULE_11__.allConsent.hash);
  const bytes = [];
  while (hash > 0) {
    bytes.push(String.fromCharCode(hash & 255));
    hash = hash >>> 8;
  }
  return btoa(bytes.join());
}
function consentChanged(submodule) {
  const storedConsent = getStoredValue(submodule, 'cst');
  return !storedConsent || storedConsent !== getConsentHash();
}
function populateSubmoduleId(submodule, forceRefresh) {
  const consentData = _src_consentHandler_js__WEBPACK_IMPORTED_MODULE_11__.allConsent.getConsentData();

  // There are two submodule configuration types to handle: storage or value
  // 1. storage: retrieve user id data from cookie/html storage or with the submodule's getId method
  // 2. value: pass directly to bids
  if (submodule.config.storage) {
    let storedId = getStoredValue(submodule);
    let response;
    let refreshNeeded = false;
    if (typeof submodule.config.storage.refreshInSeconds === 'number') {
      const storedDate = new Date(getStoredValue(submodule, 'last'));
      refreshNeeded = storedDate && Date.now() - storedDate.getTime() > submodule.config.storage.refreshInSeconds * 1000;
    }
    if (!storedId || refreshNeeded || forceRefresh || consentChanged(submodule)) {
      const extendedConfig = Object.assign({
        enabledStorageTypes: submodule.enabledStorageTypes
      }, submodule.config);

      // No id previously saved, or a refresh is needed, or consent has changed. Request a new id from the submodule.
      response = submodule.submodule.getId(extendedConfig, consentData, storedId);
    } else if (typeof submodule.submodule.extendId === 'function') {
      // If the id exists already, give submodule a chance to decide additional actions that need to be taken
      response = submodule.submodule.extendId(submodule.config, consentData, storedId);
    }
    if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.isPlainObject)(response)) {
      if (response.id) {
        // A getId/extendId result assumed to be valid user id data, which should be saved to users local storage or cookies
        setStoredValue(submodule, response.id);
        storedId = response.id;
      }
      if (typeof response.callback === 'function') {
        // Save async callback to be invoked after auction
        submodule.callback = response.callback;
      }
    }
    if (storedId) {
      // cache decoded value (this is copied to every adUnit bid)
      submodule.idObj = submodule.submodule.decode(storedId, submodule.config);
    }
  } else if (submodule.config.value) {
    // cache decoded value (this is copied to every adUnit bid)
    submodule.idObj = submodule.config.value;
  } else {
    const response = submodule.submodule.getId(submodule.config, consentData);
    if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.isPlainObject)(response)) {
      if (typeof response.callback === 'function') {
        submodule.callback = response.callback;
      }
      if (response.id) {
        submodule.idObj = submodule.submodule.decode(response.id, submodule.config);
      }
    }
  }
}
function updatePPID(priorityMaps) {
  const eids = (0,_eids_js__WEBPACK_IMPORTED_MODULE_8__.getEids)(priorityMaps.combined);
  if (eids.length && ppidSource) {
    const ppid = getPPID(eids);
    if (ppid) {
      if ((0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.isGptPubadsDefined)()) {
        window.googletag.pubads().setPublisherProvidedId(ppid);
      } else {
        window.googletag = window.googletag || {};
        window.googletag.cmd = window.googletag.cmd || [];
        window.googletag.cmd.push(function () {
          window.googletag.pubads().setPublisherProvidedId(ppid);
        });
      }
    }
  }
}
function initSubmodules(priorityMaps, submodules) {
  let forceRefresh = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return uidMetrics().fork().measureTime('userId.init.modules', function () {
    if (!submodules.length) return []; // to simplify log messages from here on

    submodules.forEach(submod => populateEnabledStorageTypes(submod));

    /**
     * filter out submodules that:
     *
     *  - cannot use the storage they've been set up with (storage not available / not allowed / disabled)
     *  - are not allowed to perform the `enrichEids` activity
     */
    submodules = submodules.filter(submod => {
      return (!submod.config.storage || canUseStorage(submod)) && dep.isAllowed(_src_activities_activities_js__WEBPACK_IMPORTED_MODULE_5__.ACTIVITY_ENRICH_EIDS, (0,_src_activities_activityParams_js__WEBPACK_IMPORTED_MODULE_6__.activityParams)(_src_activities_modules_js__WEBPACK_IMPORTED_MODULE_7__.MODULE_TYPE_UID, submod.config.name));
    });
    if (!submodules.length) {
      (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logWarn)(`${MODULE_NAME} - no ID module configured`);
      return [];
    }
    const initialized = submodules.reduce((carry, submodule) => {
      return submoduleMetrics(submodule.submodule.name).measureTime('init', () => {
        try {
          populateSubmoduleId(submodule, forceRefresh);
          carry.push(submodule);
        } catch (e) {
          (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)(`Error in userID module '${submodule.submodule.name}':`, e);
        }
        return carry;
      });
    }, []);
    priorityMaps.refresh(initialized);
    updatePPID(priorityMaps);
    return initialized;
  });
}
function getConfiguredStorageTypes(config) {
  return config?.storage?.type?.trim().split(/\s*&\s*/) || [];
}
function hasValidStorageTypes(config) {
  const storageTypes = getConfiguredStorageTypes(config);
  return storageTypes.every(storageType => ALL_STORAGE_TYPES.has(storageType));
}

/**
 * list of submodule configurations with valid 'storage' or 'value' obj definitions
 * storage config: contains values for storing/retrieving User ID data in browser storage
 * value config: object properties that are copied to bids (without saving to storage)
 * @param {SubmoduleConfig[]} configRegistry
 * @returns {SubmoduleConfig[]}
 */
function getValidSubmoduleConfigs(configRegistry) {
  function err(msg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logWarn)(`Invalid userSync.userId config: ${msg}`, ...args);
  }
  if (!Array.isArray(configRegistry)) {
    if (configRegistry != null) {
      err('must be an array', configRegistry);
    }
    return [];
  }
  return configRegistry.filter(config => {
    if (!config?.name) {
      return err('must specify "name"', config);
    } else if (config.storage) {
      if (!config.storage.name || !config.storage.type) {
        return err('must specify "storage.name" and "storage.type"', config);
      } else if (!hasValidStorageTypes(config)) {
        return err('invalid "storage.type"', config);
      }
      ['expires', 'refreshInSeconds'].forEach(param => {
        let value = config.storage[param];
        if (value != null && typeof value !== 'number') {
          value = Number(value);
          if (isNaN(value)) {
            err(`storage.${param} must be a number and will be ignored`, config);
            delete config.storage[param];
          } else {
            config.storage[param] = value;
          }
        }
      });
    }
    return true;
  });
}
const ALL_STORAGE_TYPES = new Set([LOCAL_STORAGE, COOKIE]);
function canUseLocalStorage(submodule) {
  if (!submodule.storageMgr.localStorageIsEnabled()) {
    return false;
  }
  if (coreStorage.getDataFromLocalStorage(PBJS_USER_ID_OPTOUT_NAME)) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)(`${MODULE_NAME} - opt-out localStorage found, storage disabled`);
    return false;
  }
  return true;
}
function canUseCookies(submodule) {
  if (!submodule.storageMgr.cookiesAreEnabled()) {
    return false;
  }
  if (coreStorage.getCookie(PBJS_USER_ID_OPTOUT_NAME)) {
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)(`${MODULE_NAME} - opt-out cookie found, storage disabled`);
    return false;
  }
  return true;
}
function populateEnabledStorageTypes(submodule) {
  if (submodule.enabledStorageTypes) {
    return;
  }
  const storageTypes = getConfiguredStorageTypes(submodule.config);
  submodule.enabledStorageTypes = storageTypes.filter(type => {
    switch (type) {
      case LOCAL_STORAGE:
        return canUseLocalStorage(submodule);
      case COOKIE:
        return canUseCookies(submodule);
    }
    return false;
  });
}
function canUseStorage(submodule) {
  return !!submodule.enabledStorageTypes.length;
}
function updateEIDConfig(submodules) {
  _eids_js__WEBPACK_IMPORTED_MODULE_8__.EID_CONFIG.clear();
  Object.entries(orderByPriority(submodules, mod => Object.keys(mod.eids || {}), mod => mod)).forEach(_ref12 => {
    let [key, submodules] = _ref12;
    return _eids_js__WEBPACK_IMPORTED_MODULE_8__.EID_CONFIG.set(key, submodules[0].eids[key]);
  });
}

/**
 * update submodules by validating against existing configs and storage types
 */
function updateSubmodules() {
  updateEIDConfig(submoduleRegistry);
  const configs = getValidSubmoduleConfigs(configRegistry);
  if (!configs.length) {
    return;
  }
  // do this to avoid reprocessing submodules
  // TODO: the logic does not match the comment - addedSubmodules is always a copy of submoduleRegistry
  // (if it did it would not be correct - it's not enough to find new modules, as others may have been removed or changed)
  const addedSubmodules = submoduleRegistry.filter(i => !(submodules || []).find(j => j.name === i.name));
  submodules.splice(0, submodules.length);
  // find submodule and the matching configuration, if found create and append a SubmoduleContainer
  addedSubmodules.map(i => {
    const submoduleConfig = (configs || []).find(j => j.name && (j.name.toLowerCase() === i.name.toLowerCase() || i.aliasName && j.name.toLowerCase() === i.aliasName.toLowerCase()));
    if (submoduleConfig && i.name !== submoduleConfig.name) submoduleConfig.name = i.name;
    return submoduleConfig ? {
      submodule: i,
      config: submoduleConfig,
      callback: undefined,
      idObj: undefined,
      storageMgr: (0,_src_storageManager_js__WEBPACK_IMPORTED_MODULE_1__.getStorageManager)({
        moduleType: _src_activities_modules_js__WEBPACK_IMPORTED_MODULE_7__.MODULE_TYPE_UID,
        moduleName: submoduleConfig.name
      })
    } : null;
  }).filter(submodule => submodule !== null).forEach(sm => submodules.push(sm));
  if (submodules.length) {
    if (!addedStartAuctionHook()) {
      _src_prebid_js__WEBPACK_IMPORTED_MODULE_0__.startAuction.getHooks({
        hook: addUserIdsHook
      }).remove();
      _src_prebid_js__WEBPACK_IMPORTED_MODULE_0__.startAuction.before(startAuctionHook, 100); // use higher priority than dataController / rtd
      _src_adapterManager_js__WEBPACK_IMPORTED_MODULE_16__["default"].callDataDeletionRequest.before(requestDataDeletion);
      _src_adserver_js__WEBPACK_IMPORTED_MODULE_17__.getPPID.after(next => next(getPPID()));
    }
    (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)(`${MODULE_NAME} - usersync config updated for ${submodules.length} submodules: `, submodules.map(a => a.submodule.name));
  }
}

/**
 * This function will update the idPriority according to the provided configuration
 * @param {Object} idPriorityConfig
 * @param {Submodule[]} submodules
 */
function updateIdPriority(idPriorityConfig, submodules) {
  if (idPriorityConfig) {
    const result = {};
    const aliasToName = new Map(submodules.map(s => s.aliasName ? [s.aliasName, s.name] : []));
    Object.keys(idPriorityConfig).forEach(key => {
      const priority = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(idPriorityConfig[key]) ? [...idPriorityConfig[key]].reverse() : [];
      result[key] = priority.map(s => aliasToName.has(s) ? aliasToName.get(s) : s);
    });
    idPriority = result;
  } else {
    idPriority = {};
  }
  initializedSubmodules.refresh();
  updateEIDConfig(submodules);
}
function requestDataDeletion(next) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logInfo)('UserID: received data deletion request; deleting all stored IDs...');
  submodules.forEach(submodule => {
    if (typeof submodule.submodule.onDataDeletionRequest === 'function') {
      try {
        submodule.submodule.onDataDeletionRequest(submodule.config, submodule.idObj, ...args);
      } catch (e) {
        (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.logError)(`Error calling onDataDeletionRequest for ID submodule ${submodule.submodule.name}`, e);
      }
    }
    deleteStoredValue(submodule);
  });
  next.apply(this, args);
}

/**
 * enable submodule in User ID
 * @param {Submodule} submodule
 */
function attachIdSystem(submodule) {
  submodule.findRootDomain = _src_fpd_rootDomain_js__WEBPACK_IMPORTED_MODULE_18__.findRootDomain;
  if (!(submoduleRegistry || []).find(i => i.name === submodule.name)) {
    submoduleRegistry.push(submodule);
    _src_consentHandler_js__WEBPACK_IMPORTED_MODULE_11__.GDPR_GVLIDS.register(_src_activities_modules_js__WEBPACK_IMPORTED_MODULE_7__.MODULE_TYPE_UID, submodule.name, submodule.gvlid);
    updateSubmodules();
    // TODO: a test case wants this to work even if called after init (the setConfig({userId}))
    // so we trigger a refresh. But is that even possible outside of tests?
    initIdSystem({
      refresh: true,
      submoduleNames: [submodule.name]
    });
  }
}
function normalizePromise(fn) {
  // for public methods that return promises, make sure we return a "normal" one - to avoid
  // exposing confusing stack traces
  return function () {
    return Promise.resolve(fn.apply(this, arguments));
  };
}

/**
 * test browser support for storage config types (local storage or cookie), initializes submodules but consentManagement is required,
 * so a callback is added to fire after the consentManagement module.
 * @param {{getConfig:function}} config
 */
function init(config) {
  let {
    mkDelay = _src_utils_promise_js__WEBPACK_IMPORTED_MODULE_10__.delay
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  ppidSource = undefined;
  submodules = [];
  configRegistry = [];
  initializedSubmodules = mkPriorityMaps();
  initIdSystem = idSystemInitializer({
    mkDelay
  });
  if (configListener != null) {
    configListener();
  }
  submoduleRegistry = [];

  // listen for config userSyncs to be set
  configListener = config.getConfig('userSync', conf => {
    // Note: support for 'usersync' was dropped as part of Prebid.js 4.0
    const userSync = conf.userSync;
    if (userSync) {
      ppidSource = userSync.ppid;
      if (userSync.userIds) {
        configRegistry = userSync.userIds;
        syncDelay = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.isNumber)(userSync.syncDelay) ? userSync.syncDelay : _src_userSync_js__WEBPACK_IMPORTED_MODULE_19__.USERSYNC_DEFAULT_CONFIG.syncDelay;
        auctionDelay = (0,_src_utils_js__WEBPACK_IMPORTED_MODULE_4__.isNumber)(userSync.auctionDelay) ? userSync.auctionDelay : _src_userSync_js__WEBPACK_IMPORTED_MODULE_19__.USERSYNC_DEFAULT_CONFIG.auctionDelay;
        updateSubmodules();
        updateIdPriority(userSync.idPriority, submoduleRegistry);
        initIdSystem({
          ready: true
        });
      }
    }
  });

  // exposing getUserIds function in global-name-space so that userIds stored in Prebid can be used by external codes.
  (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_20__.getGlobal)().getUserIds = getUserIds;
  (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_20__.getGlobal)().getUserIdsAsEids = getUserIdsAsEids;
  (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_20__.getGlobal)().getEncryptedEidsForSource = normalizePromise(getEncryptedEidsForSource);
  (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_20__.getGlobal)().registerSignalSources = registerSignalSources;
  (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_20__.getGlobal)().refreshUserIds = normalizePromise(refreshUserIds);
  (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_20__.getGlobal)().getUserIdsAsync = normalizePromise(getUserIdsAsync);
  (0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_20__.getGlobal)().getUserIdsAsEidBySource = getUserIdsAsEidBySource;
  if (!addedStartAuctionHook()) {
    // Add ortb2.user.ext.eids even if 0 submodules are added
    _src_prebid_js__WEBPACK_IMPORTED_MODULE_0__.startAuction.before(addUserIdsHook, 100); // use higher priority than dataController / rtd
  }
}
function resetUserIds() {
  _src_config_js__WEBPACK_IMPORTED_MODULE_15__.config.setConfig({
    userSync: {}
  });
  init(_src_config_js__WEBPACK_IMPORTED_MODULE_15__.config);
}

// init config update listener to start the application
init(_src_config_js__WEBPACK_IMPORTED_MODULE_15__.config);
(0,_src_hook_js__WEBPACK_IMPORTED_MODULE_12__.module)('userId', attachIdSystem, {
  postInstallAllowed: true
});
(0,_src_prebidGlobal_js__WEBPACK_IMPORTED_MODULE_20__.registerModule)('userId');

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["chunk-core","viewport","greedy","creative-renderer-display"], () => (__webpack_exec__("./modules/userId/index.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);

})()
 
   pbjs.processQueue();
 
} else {
 try {
  if(window.pbjs.getConfig('debug')) {
    console.warn('Attempted to load a copy of Prebid.js that clashes with the existing \'pbjs\' instance. Load aborted.');
  }
 } catch (e) {}
}
//# sourceMappingURL=prebid.js.map
